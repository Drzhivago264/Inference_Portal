import type { BaseNode, Document, Metadata, NodeWithScore } from "../../Node.js";
import { ImageNode } from "../../Node.js";
import type { BaseRetriever, RetrieveParams } from "../../Retriever.js";
import type { ServiceContext } from "../../ServiceContext.js";
import type { Event } from "../../callbacks/CallbackManager.js";
import type { BaseEmbedding, MultiModalEmbedding } from "../../embeddings/index.js";
import { RetrieverQueryEngine } from "../../engines/query/RetrieverQueryEngine.js";
import type { BaseNodePostprocessor } from "../../postprocessors/types.js";
import type { StorageContext } from "../../storage/StorageContext.js";
import type { BaseIndexStore } from "../../storage/indexStore/types.js";
import type { MetadataFilters, VectorStore, VectorStoreQuery, VectorStoreQueryResult } from "../../storage/vectorStore/types.js";
import type { BaseSynthesizer } from "../../synthesizers/types.js";
import type { BaseQueryEngine } from "../../types.js";
import type { BaseIndexInit } from "../BaseIndex.js";
import { BaseIndex } from "../BaseIndex.js";
import { IndexDict } from "../json-to-index-struct.js";
interface IndexStructOptions {
    indexStruct?: IndexDict;
    indexId?: string;
}
export interface VectorIndexOptions extends IndexStructOptions {
    nodes?: BaseNode[];
    serviceContext?: ServiceContext;
    storageContext?: StorageContext;
    imageVectorStore?: VectorStore;
    vectorStore?: VectorStore;
    logProgress?: boolean;
}
export interface VectorIndexConstructorProps extends BaseIndexInit<IndexDict> {
    indexStore: BaseIndexStore;
    imageVectorStore?: VectorStore;
}
/**
 * The VectorStoreIndex, an index that stores the nodes only according to their vector embedings.
 */
export declare class VectorStoreIndex extends BaseIndex<IndexDict> {
    vectorStore: VectorStore;
    indexStore: BaseIndexStore;
    embedModel: BaseEmbedding;
    imageVectorStore?: VectorStore;
    imageEmbedModel?: MultiModalEmbedding;
    private constructor();
    /**
     * The async init function creates a new VectorStoreIndex.
     * @param options
     * @returns
     */
    static init(options: VectorIndexOptions): Promise<VectorStoreIndex>;
    private static setupIndexStructFromStorage;
    /**
     * Calculates the embeddings for the given nodes.
     *
     * @param nodes - An array of BaseNode objects representing the nodes for which embeddings are to be calculated.
     * @param {Object} [options] - An optional object containing additional parameters.
     *   @param {boolean} [options.logProgress] - A boolean indicating whether to log progress to the console (useful for debugging).
     */
    getNodeEmbeddingResults(nodes: BaseNode[], options?: {
        logProgress?: boolean;
    }): Promise<BaseNode[]>;
    /**
     * Get embeddings for nodes and place them into the index.
     * @param nodes
     * @returns
     */
    buildIndexFromNodes(nodes: BaseNode[], options?: {
        logProgress?: boolean;
    }): Promise<void>;
    /**
     * High level API: split documents, get embeddings, and build index.
     * @param documents
     * @param args
     * @returns
     */
    static fromDocuments(documents: Document[], args?: VectorIndexOptions): Promise<VectorStoreIndex>;
    static fromVectorStore(vectorStore: VectorStore, serviceContext: ServiceContext, imageVectorStore?: VectorStore): Promise<VectorStoreIndex>;
    asRetriever(options?: Omit<VectorIndexRetrieverOptions, "index">): VectorIndexRetriever;
    asQueryEngine(options?: {
        retriever?: BaseRetriever;
        responseSynthesizer?: BaseSynthesizer;
        preFilters?: MetadataFilters;
        nodePostprocessors?: BaseNodePostprocessor[];
    }): BaseQueryEngine & RetrieverQueryEngine;
    protected insertNodesToStore(vectorStore: VectorStore, nodes: BaseNode[]): Promise<void>;
    insertNodes(nodes: BaseNode[], options?: {
        logProgress?: boolean;
    }): Promise<void>;
    deleteRefDoc(refDocId: string, deleteFromDocStore?: boolean): Promise<void>;
    protected deleteRefDocFromStore(vectorStore: VectorStore, refDocId: string): Promise<void>;
    /**
     * Calculates the embeddings for the given image nodes.
     *
     * @param nodes - An array of ImageNode objects representing the nodes for which embeddings are to be calculated.
     * @param {Object} [options] - An optional object containing additional parameters.
     *   @param {boolean} [options.logProgress] - A boolean indicating whether to log progress to the console (useful for debugging).
     */
    getImageNodeEmbeddingResults(nodes: ImageNode[], options?: {
        logProgress?: boolean;
    }): Promise<ImageNode[]>;
}
/**
 * VectorIndexRetriever retrieves nodes from a VectorIndex.
 */
export type VectorIndexRetrieverOptions = {
    index: VectorStoreIndex;
    similarityTopK?: number;
    imageSimilarityTopK?: number;
};
export declare class VectorIndexRetriever implements BaseRetriever {
    index: VectorStoreIndex;
    similarityTopK: number;
    imageSimilarityTopK: number;
    private serviceContext;
    constructor({ index, similarityTopK, imageSimilarityTopK, }: VectorIndexRetrieverOptions);
    retrieve({ query, parentEvent, preFilters, }: RetrieveParams): Promise<NodeWithScore[]>;
    protected textRetrieve(query: string, preFilters?: MetadataFilters): Promise<NodeWithScore[]>;
    private textToImageRetrieve;
    protected sendEvent(query: string, nodesWithScores: NodeWithScore<Metadata>[], parentEvent: Event | undefined): void;
    protected buildVectorStoreQuery(embedModel: BaseEmbedding, query: string, similarityTopK: number, preFilters?: MetadataFilters): Promise<VectorStoreQuery>;
    protected buildNodeListFromQueryResult(result: VectorStoreQueryResult): NodeWithScore<Metadata>[];
    getServiceContext(): ServiceContext;
}
export {};
