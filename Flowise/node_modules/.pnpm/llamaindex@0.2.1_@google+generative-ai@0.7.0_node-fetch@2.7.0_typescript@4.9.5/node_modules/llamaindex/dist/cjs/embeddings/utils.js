"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    SimilarityType: function() {
        return SimilarityType;
    },
    getTopKEmbeddings: function() {
        return getTopKEmbeddings;
    },
    getTopKEmbeddingsLearner: function() {
        return getTopKEmbeddingsLearner;
    },
    getTopKMMREmbeddings: function() {
        return getTopKMMREmbeddings;
    },
    imageToDataUrl: function() {
        return imageToDataUrl;
    },
    imageToString: function() {
        return imageToString;
    },
    readImage: function() {
        return readImage;
    },
    similarity: function() {
        return similarity;
    },
    stringToImage: function() {
        return stringToImage;
    }
});
const _env = require("@llamaindex/env");
const _lodash = /*#__PURE__*/ _interop_require_default(require("lodash"));
const _magicbytes = require("magic-bytes.js");
const _constants = require("../constants.js");
const _types = require("../storage/vectorStore/types.js");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var SimilarityType;
(function(SimilarityType) {
    SimilarityType["DEFAULT"] = "cosine";
    SimilarityType["DOT_PRODUCT"] = "dot_product";
    SimilarityType["EUCLIDEAN"] = "euclidean";
})(SimilarityType || (SimilarityType = {}));
function similarity(embedding1, embedding2, mode = "cosine") {
    if (embedding1.length !== embedding2.length) {
        throw new Error("Embedding length mismatch");
    }
    // NOTE I've taken enough Kahan to know that we should probably leave the
    // numeric programming to numeric programmers. The naive approach here
    // will probably cause some avoidable loss of floating point precision
    // ml-distance is worth watching although they currently also use the naive
    // formulas
    function norm(x) {
        let result = 0;
        for(let i = 0; i < x.length; i++){
            result += x[i] * x[i];
        }
        return Math.sqrt(result);
    }
    switch(mode){
        case "euclidean":
            {
                const difference = embedding1.map((x, i)=>x - embedding2[i]);
                return -norm(difference);
            }
        case "dot_product":
            {
                let result = 0;
                for(let i = 0; i < embedding1.length; i++){
                    result += embedding1[i] * embedding2[i];
                }
                return result;
            }
        case "cosine":
            {
                return similarity(embedding1, embedding2, "dot_product") / (norm(embedding1) * norm(embedding2));
            }
        default:
            throw new Error("Not implemented yet");
    }
}
function getTopKEmbeddings(queryEmbedding, embeddings, similarityTopK = _constants.DEFAULT_SIMILARITY_TOP_K, embeddingIds = null, similarityCutoff = null) {
    if (embeddingIds == null) {
        embeddingIds = Array(embeddings.length).map((_, i)=>i);
    }
    if (embeddingIds.length !== embeddings.length) {
        throw new Error("getTopKEmbeddings: embeddings and embeddingIds length mismatch");
    }
    const similarities = [];
    for(let i = 0; i < embeddings.length; i++){
        const sim = similarity(queryEmbedding, embeddings[i]);
        if (similarityCutoff == null || sim > similarityCutoff) {
            similarities.push({
                similarity: sim,
                id: embeddingIds[i]
            });
        }
    }
    similarities.sort((a, b)=>b.similarity - a.similarity); // Reverse sort
    const resultSimilarities = [];
    const resultIds = [];
    for(let i = 0; i < similarityTopK; i++){
        if (i >= similarities.length) {
            break;
        }
        resultSimilarities.push(similarities[i].similarity);
        resultIds.push(similarities[i].id);
    }
    return [
        resultSimilarities,
        resultIds
    ];
}
function getTopKEmbeddingsLearner(queryEmbedding, embeddings, similarityTopK, embeddingsIds, queryMode = _types.VectorStoreQueryMode.SVM) {
    throw new Error("Not implemented yet");
// To support SVM properly we're probably going to have to use something like
// https://github.com/mljs/libsvm which itself hasn't been updated in a while
}
function getTopKMMREmbeddings(queryEmbedding, embeddings, similarityFn = null, similarityTopK = null, embeddingIds = null, _similarityCutoff = null, mmrThreshold = null) {
    const threshold = mmrThreshold || 0.5;
    similarityFn = similarityFn || similarity;
    if (embeddingIds === null || embeddingIds.length === 0) {
        embeddingIds = Array.from({
            length: embeddings.length
        }, (_, i)=>i);
    }
    const fullEmbedMap = new Map(embeddingIds.map((value, i)=>[
            value,
            i
        ]));
    const embedMap = new Map(fullEmbedMap);
    const embedSimilarity = new Map();
    let score = Number.NEGATIVE_INFINITY;
    let highScoreId = null;
    for(let i = 0; i < embeddings.length; i++){
        const emb = embeddings[i];
        const similarity = similarityFn(queryEmbedding, emb);
        embedSimilarity.set(embeddingIds[i], similarity);
        if (similarity * threshold > score) {
            highScoreId = embeddingIds[i];
            score = similarity * threshold;
        }
    }
    const results = [];
    const embeddingLength = embeddings.length;
    const similarityTopKCount = similarityTopK || embeddingLength;
    while(results.length < Math.min(similarityTopKCount, embeddingLength)){
        results.push([
            score,
            highScoreId
        ]);
        embedMap.delete(highScoreId);
        const recentEmbeddingId = highScoreId;
        score = Number.NEGATIVE_INFINITY;
        for (const embedId of Array.from(embedMap.keys())){
            const overlapWithRecent = similarityFn(embeddings[embedMap.get(embedId)], embeddings[fullEmbedMap.get(recentEmbeddingId)]);
            if (threshold * embedSimilarity.get(embedId) - (1 - threshold) * overlapWithRecent > score) {
                score = threshold * embedSimilarity.get(embedId) - (1 - threshold) * overlapWithRecent;
                highScoreId = embedId;
            }
        }
    }
    const resultSimilarities = results.map(([s, _])=>s);
    const resultIds = results.map(([_, n])=>n);
    return [
        resultSimilarities,
        resultIds
    ];
}
async function blobToDataUrl(input) {
    const buffer = Buffer.from(await input.arrayBuffer());
    const mimes = (0, _magicbytes.filetypemime)(buffer);
    if (mimes.length < 1) {
        throw new Error("Unsupported image type");
    }
    return "data:" + mimes[0] + ";base64," + buffer.toString("base64");
}
async function readImage(input) {
    const { RawImage } = await import("@xenova/transformers");
    if (input instanceof Blob) {
        return await RawImage.fromBlob(input);
    } else if (_lodash.default.isString(input) || input instanceof URL) {
        return await RawImage.fromURL(input);
    } else {
        throw new Error(`Unsupported input type: ${typeof input}`);
    }
}
async function imageToString(input) {
    if (input instanceof Blob) {
        // if the image is a Blob, convert it to a base64 data URL
        return await blobToDataUrl(input);
    } else if (_lodash.default.isString(input)) {
        return input;
    } else if (input instanceof URL) {
        return input.toString();
    } else {
        throw new Error(`Unsupported input type: ${typeof input}`);
    }
}
function stringToImage(input) {
    if (input.startsWith("data:")) {
        // if the input is a base64 data URL, convert it back to a Blob
        const base64Data = input.split(",")[1];
        const byteArray = Buffer.from(base64Data, "base64");
        return new Blob([
            byteArray
        ]);
    } else if (input.startsWith("http://") || input.startsWith("https://")) {
        return new URL(input);
    } else if (_lodash.default.isString(input)) {
        return input;
    } else {
        throw new Error(`Unsupported input type: ${typeof input}`);
    }
}
async function imageToDataUrl(input) {
    // first ensure, that the input is a Blob
    if (input instanceof URL && input.protocol === "file:" || _lodash.default.isString(input)) {
        // string or file URL
        const dataBuffer = await _env.defaultFS.readFile(input instanceof URL ? input.pathname : input);
        input = new Blob([
            dataBuffer
        ]);
    } else if (!(input instanceof Blob)) {
        if (input instanceof URL) {
            throw new Error(`Unsupported URL with protocol: ${input.protocol}`);
        } else {
            throw new Error(`Unsupported input type: ${typeof input}`);
        }
    }
    return await blobToDataUrl(input);
}
