"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "SubQuestionQueryEngine", {
    enumerable: true,
    get: function() {
        return SubQuestionQueryEngine;
    }
});
const _env = require("@llamaindex/env");
const _Node = require("../../Node.js");
const _QuestionGenerator = require("../../QuestionGenerator.js");
const _ServiceContext = require("../../ServiceContext.js");
const _Mixin = require("../../prompts/Mixin.js");
const _index = require("../../synthesizers/index.js");
class SubQuestionQueryEngine extends _Mixin.PromptMixin {
    responseSynthesizer;
    questionGen;
    queryEngines;
    metadatas;
    constructor(init){
        super();
        this.questionGen = init.questionGen;
        this.responseSynthesizer = init.responseSynthesizer ?? new _index.ResponseSynthesizer();
        this.queryEngines = init.queryEngineTools;
        this.metadatas = init.queryEngineTools.map((tool)=>tool.metadata);
    }
    _getPromptModules() {
        return {
            questionGen: this.questionGen,
            responseSynthesizer: this.responseSynthesizer
        };
    }
    static fromDefaults(init) {
        const serviceContext = init.serviceContext ?? (0, _ServiceContext.serviceContextFromDefaults)({});
        const questionGen = init.questionGen ?? new _QuestionGenerator.LLMQuestionGenerator();
        const responseSynthesizer = init.responseSynthesizer ?? new _index.ResponseSynthesizer({
            responseBuilder: new _index.CompactAndRefine(serviceContext),
            serviceContext
        });
        return new SubQuestionQueryEngine({
            questionGen,
            responseSynthesizer,
            queryEngineTools: init.queryEngineTools
        });
    }
    async query(params) {
        const { query, stream } = params;
        const subQuestions = await this.questionGen.generate(this.metadatas, query);
        // groups final retrieval+synthesis operation
        const parentEvent = params.parentEvent || {
            id: (0, _env.randomUUID)(),
            type: "wrapper",
            tags: [
                "final"
            ]
        };
        // groups all sub-queries
        const subQueryParentEvent = {
            id: (0, _env.randomUUID)(),
            parentId: parentEvent.id,
            type: "wrapper",
            tags: [
                "intermediate"
            ]
        };
        const subQNodes = await Promise.all(subQuestions.map((subQ)=>this.querySubQ(subQ, subQueryParentEvent)));
        const nodesWithScore = subQNodes.filter((node)=>node !== null).map((node)=>node);
        if (stream) {
            return this.responseSynthesizer.synthesize({
                query,
                nodesWithScore,
                parentEvent,
                stream: true
            });
        }
        return this.responseSynthesizer.synthesize({
            query,
            nodesWithScore,
            parentEvent
        });
    }
    async querySubQ(subQ, parentEvent) {
        try {
            const question = subQ.subQuestion;
            const queryEngine = this.queryEngines.find((tool)=>tool.metadata.name === subQ.toolName);
            if (!queryEngine) {
                return null;
            }
            const responseText = await queryEngine?.call?.({
                query: question,
                parentEvent
            });
            if (!responseText) {
                return null;
            }
            const nodeText = `Sub question: ${question}\nResponse: ${responseText}`;
            const node = new _Node.TextNode({
                text: nodeText
            });
            return {
                node,
                score: 0
            };
        } catch (error) {
            return null;
        }
    }
}
