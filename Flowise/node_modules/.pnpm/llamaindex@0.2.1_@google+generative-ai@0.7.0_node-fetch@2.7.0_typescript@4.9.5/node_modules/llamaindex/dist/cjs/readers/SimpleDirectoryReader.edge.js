"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "SimpleDirectoryReader", {
    enumerable: true,
    get: function() {
        return SimpleDirectoryReader;
    }
});
const _env = require("@llamaindex/env");
const _FileSystem = require("../storage/FileSystem.js");
const _TextFileReader = require("./TextFileReader.js");
var ReaderStatus;
(function(ReaderStatus) {
    ReaderStatus[ReaderStatus["STARTED"] = 0] = "STARTED";
    ReaderStatus[ReaderStatus["COMPLETE"] = 1] = "COMPLETE";
    ReaderStatus[ReaderStatus["ERROR"] = 2] = "ERROR";
})(ReaderStatus || (ReaderStatus = {}));
class SimpleDirectoryReader {
    observer;
    constructor(observer){
        this.observer = observer;
    }
    async loadData(params) {
        if (typeof params === "string") {
            params = {
                directoryPath: params
            };
        }
        const { directoryPath, fs = _env.defaultFS, defaultReader = new _TextFileReader.TextFileReader(), fileExtToReader } = params;
        // Observer can decide to skip the directory
        if (!this.doObserverCheck("directory", directoryPath, 0)) {
            return [];
        }
        const docs = [];
        for await (const filePath of (0, _FileSystem.walk)(fs, directoryPath)){
            try {
                const fileExt = _env.path.extname(filePath).slice(1).toLowerCase();
                // Observer can decide to skip each file
                if (!this.doObserverCheck("file", filePath, 0)) {
                    continue;
                }
                let reader;
                if (fileExtToReader && fileExt in fileExtToReader) {
                    reader = fileExtToReader[fileExt];
                } else if (defaultReader != null) {
                    reader = defaultReader;
                } else {
                    const msg = `No reader for file extension of ${filePath}`;
                    console.warn(msg);
                    // In an error condition, observer's false cancels the whole process.
                    if (!this.doObserverCheck("file", filePath, 2, msg)) {
                        return [];
                    }
                    continue;
                }
                const fileDocs = await reader.loadData(filePath, fs);
                // Observer can still cancel addition of the resulting docs from this file
                if (this.doObserverCheck("file", filePath, 1)) {
                    docs.push(...fileDocs);
                }
            } catch (e) {
                const msg = `Error reading file ${filePath}: ${e}`;
                console.error(msg);
                // In an error condition, observer's false cancels the whole process.
                if (!this.doObserverCheck("file", filePath, 2, msg)) {
                    return [];
                }
            }
        }
        // After successful import of all files, directory completion
        // is only a notification for observer, cannot be cancelled.
        this.doObserverCheck("directory", directoryPath, 1);
        return docs;
    }
    doObserverCheck(category, name, status, message) {
        if (this.observer) {
            return this.observer(category, name, status, message);
        }
        return true;
    }
}
