"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getNodesFromDocument", {
    enumerable: true,
    get: function() {
        return getNodesFromDocument;
    }
});
const _lodash = /*#__PURE__*/ _interop_require_default(require("lodash"));
const _Node = require("../Node.js");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Splits the text of a document into smaller parts.
 * @param document - The document to split.
 * @param textSplitter - The text splitter to use.
 * @returns An array of text splits.
 */ function getTextSplitsFromDocument(document, textSplitter) {
    const text = document.getText();
    return textSplitter(text);
}
function getNodesFromDocument(doc, textSplitter, includeMetadata = true, includePrevNextRel = true) {
    if (doc instanceof _Node.ImageDocument) {
        // TODO: use text splitter on text of image documents
        return [
            doc
        ];
    }
    if (!(doc instanceof _Node.Document)) {
        throw new Error("Expected either an Image Document or Document");
    }
    const document = doc;
    const nodes = [];
    const textSplits = getTextSplitsFromDocument(document, textSplitter);
    textSplits.forEach((textSplit)=>{
        const node = new _Node.TextNode({
            text: textSplit,
            metadata: includeMetadata ? _lodash.default.cloneDeep(document.metadata) : {},
            excludedEmbedMetadataKeys: _lodash.default.cloneDeep(document.excludedEmbedMetadataKeys),
            excludedLlmMetadataKeys: _lodash.default.cloneDeep(document.excludedLlmMetadataKeys)
        });
        node.relationships[_Node.NodeRelationship.SOURCE] = document.asRelatedNodeInfo();
        nodes.push(node);
    });
    if (includePrevNextRel) {
        nodes.forEach((node, index)=>{
            if (index > 0) {
                node.relationships[_Node.NodeRelationship.PREVIOUS] = nodes[index - 1].asRelatedNodeInfo();
            }
            if (index < nodes.length - 1) {
                node.relationships[_Node.NodeRelationship.NEXT] = nodes[index + 1].asRelatedNodeInfo();
            }
        });
    }
    return nodes;
}
