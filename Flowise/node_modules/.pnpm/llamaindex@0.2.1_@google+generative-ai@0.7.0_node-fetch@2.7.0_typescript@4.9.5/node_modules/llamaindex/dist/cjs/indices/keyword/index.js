"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    KeywordTableIndex: function() {
        return KeywordTableIndex;
    },
    KeywordTableLLMRetriever: function() {
        return KeywordTableLLMRetriever;
    },
    KeywordTableRAKERetriever: function() {
        return KeywordTableRAKERetriever;
    },
    KeywordTableRetrieverMode: function() {
        return KeywordTableRetrieverMode;
    },
    KeywordTableSimpleRetriever: function() {
        return KeywordTableSimpleRetriever;
    }
});
const _Node = require("../../Node.js");
const _Prompt = require("../../Prompt.js");
const _ServiceContext = require("../../ServiceContext.js");
const _index = require("../../engines/query/index.js");
const _StorageContext = require("../../storage/StorageContext.js");
const _BaseIndex = require("../BaseIndex.js");
const _jsontoindexstruct = require("../json-to-index-struct.js");
const _utils = require("./utils.js");
var KeywordTableRetrieverMode;
(function(KeywordTableRetrieverMode) {
    KeywordTableRetrieverMode["DEFAULT"] = "DEFAULT";
    KeywordTableRetrieverMode["SIMPLE"] = "SIMPLE";
    KeywordTableRetrieverMode["RAKE"] = "RAKE";
})(KeywordTableRetrieverMode || (KeywordTableRetrieverMode = {}));
// Base Keyword Table Retriever
class BaseKeywordTableRetriever {
    index;
    indexStruct;
    docstore;
    serviceContext;
    maxKeywordsPerQuery;
    numChunksPerQuery;
    keywordExtractTemplate;
    queryKeywordExtractTemplate;
    constructor({ index, keywordExtractTemplate, queryKeywordExtractTemplate, maxKeywordsPerQuery = 10, numChunksPerQuery = 10 }){
        this.index = index;
        this.indexStruct = index.indexStruct;
        this.docstore = index.docStore;
        this.serviceContext = index.serviceContext;
        this.maxKeywordsPerQuery = maxKeywordsPerQuery;
        this.numChunksPerQuery = numChunksPerQuery;
        this.keywordExtractTemplate = keywordExtractTemplate || _Prompt.defaultKeywordExtractPrompt;
        this.queryKeywordExtractTemplate = queryKeywordExtractTemplate || _Prompt.defaultQueryKeywordExtractPrompt;
    }
    async retrieve({ query }) {
        const keywords = await this.getKeywords(query);
        const chunkIndicesCount = {};
        const filteredKeywords = keywords.filter((keyword)=>this.indexStruct.table.has(keyword));
        for (const keyword of filteredKeywords){
            for (const nodeId of this.indexStruct.table.get(keyword) || []){
                chunkIndicesCount[nodeId] = (chunkIndicesCount[nodeId] ?? 0) + 1;
            }
        }
        const sortedChunkIndices = Object.keys(chunkIndicesCount).sort((a, b)=>chunkIndicesCount[b] - chunkIndicesCount[a]).slice(0, this.numChunksPerQuery);
        const sortedNodes = await this.docstore.getNodes(sortedChunkIndices);
        return sortedNodes.map((node)=>({
                node
            }));
    }
    getServiceContext() {
        return this.index.serviceContext;
    }
}
class KeywordTableLLMRetriever extends BaseKeywordTableRetriever {
    async getKeywords(query) {
        const response = await this.serviceContext.llm.complete({
            prompt: this.queryKeywordExtractTemplate({
                question: query,
                maxKeywords: this.maxKeywordsPerQuery
            })
        });
        const keywords = (0, _utils.extractKeywordsGivenResponse)(response.text, "KEYWORDS:");
        return [
            ...keywords
        ];
    }
}
class KeywordTableSimpleRetriever extends BaseKeywordTableRetriever {
    getKeywords(query) {
        return Promise.resolve([
            ...(0, _utils.simpleExtractKeywords)(query, this.maxKeywordsPerQuery)
        ]);
    }
}
class KeywordTableRAKERetriever extends BaseKeywordTableRetriever {
    getKeywords(query) {
        return Promise.resolve([
            ...(0, _utils.rakeExtractKeywords)(query, this.maxKeywordsPerQuery)
        ]);
    }
}
const KeywordTableRetrieverMap = {
    ["DEFAULT"]: KeywordTableLLMRetriever,
    ["SIMPLE"]: KeywordTableSimpleRetriever,
    ["RAKE"]: KeywordTableRAKERetriever
};
class KeywordTableIndex extends _BaseIndex.BaseIndex {
    constructor(init){
        super(init);
    }
    static async init(options) {
        const storageContext = options.storageContext ?? await (0, _StorageContext.storageContextFromDefaults)({});
        const serviceContext = options.serviceContext ?? (0, _ServiceContext.serviceContextFromDefaults)({});
        const { docStore, indexStore } = storageContext;
        // Setup IndexStruct from storage
        const indexStructs = await indexStore.getIndexStructs();
        let indexStruct;
        if (options.indexStruct && indexStructs.length > 0) {
            throw new Error("Cannot initialize index with both indexStruct and indexStore");
        }
        if (options.indexStruct) {
            indexStruct = options.indexStruct;
        } else if (indexStructs.length == 1) {
            indexStruct = indexStructs[0];
        } else if (indexStructs.length > 1 && options.indexId) {
            indexStruct = await indexStore.getIndexStruct(options.indexId);
        } else {
            indexStruct = null;
        }
        // check indexStruct type
        if (indexStruct && indexStruct.type !== _jsontoindexstruct.IndexStructType.KEYWORD_TABLE) {
            throw new Error("Attempting to initialize KeywordTableIndex with non-keyword table indexStruct");
        }
        if (indexStruct) {
            if (options.nodes) {
                throw new Error("Cannot initialize KeywordTableIndex with both nodes and indexStruct");
            }
        } else {
            if (!options.nodes) {
                throw new Error("Cannot initialize KeywordTableIndex without nodes or indexStruct");
            }
            indexStruct = await KeywordTableIndex.buildIndexFromNodes(options.nodes, storageContext.docStore, serviceContext);
            await indexStore.addIndexStruct(indexStruct);
        }
        return new KeywordTableIndex({
            storageContext,
            serviceContext,
            docStore,
            indexStore,
            indexStruct
        });
    }
    asRetriever(options) {
        const { mode = "DEFAULT", ...otherOptions } = options ?? {};
        const KeywordTableRetriever = KeywordTableRetrieverMap[mode];
        if (KeywordTableRetriever) {
            return new KeywordTableRetriever({
                index: this,
                ...otherOptions
            });
        }
        throw new Error(`Unknown retriever mode: ${mode}`);
    }
    asQueryEngine(options) {
        const { retriever, responseSynthesizer } = options ?? {};
        return new _index.RetrieverQueryEngine(retriever ?? this.asRetriever(), responseSynthesizer, options?.preFilters, options?.nodePostprocessors);
    }
    static async extractKeywords(text, serviceContext) {
        const response = await serviceContext.llm.complete({
            prompt: (0, _Prompt.defaultKeywordExtractPrompt)({
                context: text
            })
        });
        return (0, _utils.extractKeywordsGivenResponse)(response.text, "KEYWORDS:");
    }
    /**
   * High level API: split documents, get keywords, and build index.
   * @param documents
   * @param storageContext
   * @param serviceContext
   * @returns
   */ static async fromDocuments(documents, args = {}) {
        let { storageContext, serviceContext } = args;
        storageContext = storageContext ?? await (0, _StorageContext.storageContextFromDefaults)({});
        serviceContext = serviceContext ?? (0, _ServiceContext.serviceContextFromDefaults)({});
        const docStore = storageContext.docStore;
        docStore.addDocuments(documents, true);
        for (const doc of documents){
            docStore.setDocumentHash(doc.id_, doc.hash);
        }
        const nodes = serviceContext.nodeParser.getNodesFromDocuments(documents);
        const index = await KeywordTableIndex.init({
            nodes,
            storageContext,
            serviceContext
        });
        return index;
    }
    /**
   * Get keywords for nodes and place them into the index.
   * @param nodes
   * @param serviceContext
   * @param vectorStore
   * @returns
   */ static async buildIndexFromNodes(nodes, docStore, serviceContext) {
        const indexStruct = new _BaseIndex.KeywordTable();
        await docStore.addDocuments(nodes, true);
        for (const node of nodes){
            const keywords = await KeywordTableIndex.extractKeywords(node.getContent(_Node.MetadataMode.LLM), serviceContext);
            indexStruct.addNode([
                ...keywords
            ], node.id_);
        }
        return indexStruct;
    }
    async insertNodes(nodes) {
        for (const node of nodes){
            const keywords = await KeywordTableIndex.extractKeywords(node.getContent(_Node.MetadataMode.LLM), this.serviceContext);
            this.indexStruct.addNode([
                ...keywords
            ], node.id_);
        }
    }
    deleteNode(nodeId) {
        const keywordsToDelete = new Set();
        for (const [keyword, existingNodeIds] of Object.entries(this.indexStruct.table)){
            const index = existingNodeIds.indexOf(nodeId);
            if (index !== -1) {
                existingNodeIds.splice(index, 1);
                // Delete keywords that have zero nodes
                if (existingNodeIds.length === 0) {
                    keywordsToDelete.add(keyword);
                }
            }
        }
        this.indexStruct.deleteNode([
            ...keywordsToDelete
        ], nodeId);
    }
    async deleteNodes(nodeIds, deleteFromDocStore) {
        nodeIds.forEach((nodeId)=>{
            this.deleteNode(nodeId);
        });
        if (deleteFromDocStore) {
            for (const nodeId of nodeIds){
                await this.docStore.deleteDocument(nodeId, false);
            }
        }
        await this.storageContext.indexStore.addIndexStruct(this.indexStruct);
    }
    async deleteRefDoc(refDocId, deleteFromDocStore) {
        const refDocInfo = await this.docStore.getRefDocInfo(refDocId);
        if (!refDocInfo) {
            return;
        }
        await this.deleteNodes(refDocInfo.nodeIds, false);
        if (deleteFromDocStore) {
            await this.docStore.deleteRefDoc(refDocId, false);
        }
        return;
    }
}
