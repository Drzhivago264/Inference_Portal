"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    VectorIndexRetriever: function() {
        return VectorIndexRetriever;
    },
    VectorStoreIndex: function() {
        return VectorStoreIndex;
    }
});
const _GlobalsHelper = require("../../GlobalsHelper.js");
const _Node = require("../../Node.js");
const _ServiceContext = require("../../ServiceContext.js");
const _constants = require("../../constants.js");
const _index = require("../../embeddings/index.js");
const _RetrieverQueryEngine = require("../../engines/query/RetrieverQueryEngine.js");
const _index1 = require("../../ingestion/index.js");
const _StorageContext = require("../../storage/StorageContext.js");
const _types = require("../../storage/vectorStore/types.js");
const _BaseIndex = require("../BaseIndex.js");
const _jsontoindexstruct = require("../json-to-index-struct.js");
class VectorStoreIndex extends _BaseIndex.BaseIndex {
    vectorStore;
    indexStore;
    embedModel;
    imageVectorStore;
    imageEmbedModel;
    constructor(init){
        super(init);
        this.indexStore = init.indexStore;
        this.vectorStore = init.vectorStore ?? init.storageContext.vectorStore;
        this.embedModel = init.serviceContext.embedModel;
        this.imageVectorStore = init.imageVectorStore ?? init.storageContext.imageVectorStore;
        if (this.imageVectorStore) {
            this.imageEmbedModel = new _index.ClipEmbedding();
        }
    }
    /**
   * The async init function creates a new VectorStoreIndex.
   * @param options
   * @returns
   */ static async init(options) {
        const storageContext = options.storageContext ?? await (0, _StorageContext.storageContextFromDefaults)({});
        const serviceContext = options.serviceContext ?? (0, _ServiceContext.serviceContextFromDefaults)({});
        const indexStore = storageContext.indexStore;
        const docStore = storageContext.docStore;
        let indexStruct = await VectorStoreIndex.setupIndexStructFromStorage(indexStore, options);
        if (!options.nodes && !indexStruct) {
            throw new Error("Cannot initialize VectorStoreIndex without nodes or indexStruct");
        }
        indexStruct = indexStruct ?? new _jsontoindexstruct.IndexDict();
        const index = new this({
            storageContext,
            serviceContext,
            docStore,
            indexStruct,
            indexStore,
            vectorStore: options.vectorStore,
            imageVectorStore: options.imageVectorStore
        });
        if (options.nodes) {
            // If nodes are passed in, then we need to update the index
            await index.buildIndexFromNodes(options.nodes, {
                logProgress: options.logProgress
            });
        }
        return index;
    }
    static async setupIndexStructFromStorage(indexStore, options) {
        const indexStructs = await indexStore.getIndexStructs();
        let indexStruct;
        if (options.indexStruct && indexStructs.length > 0) {
            throw new Error("Cannot initialize index with both indexStruct and indexStore");
        }
        if (options.indexStruct) {
            indexStruct = options.indexStruct;
        } else if (indexStructs.length == 1) {
            indexStruct = indexStructs[0].type === _jsontoindexstruct.IndexStructType.SIMPLE_DICT ? indexStructs[0] : undefined;
            indexStruct = indexStructs[0];
        } else if (indexStructs.length > 1 && options.indexId) {
            indexStruct = await indexStore.getIndexStruct(options.indexId);
        }
        // Check indexStruct type
        if (indexStruct && indexStruct.type !== _jsontoindexstruct.IndexStructType.SIMPLE_DICT) {
            throw new Error("Attempting to initialize VectorStoreIndex with non-vector indexStruct");
        }
        return indexStruct;
    }
    /**
   * Calculates the embeddings for the given nodes.
   *
   * @param nodes - An array of BaseNode objects representing the nodes for which embeddings are to be calculated.
   * @param {Object} [options] - An optional object containing additional parameters.
   *   @param {boolean} [options.logProgress] - A boolean indicating whether to log progress to the console (useful for debugging).
   */ async getNodeEmbeddingResults(nodes, options) {
        const texts = nodes.map((node)=>node.getContent(_Node.MetadataMode.EMBED));
        const embeddings = await this.embedModel.getTextEmbeddingsBatch(texts, {
            logProgress: options?.logProgress
        });
        return nodes.map((node, i)=>{
            node.embedding = embeddings[i];
            return node;
        });
    }
    /**
   * Get embeddings for nodes and place them into the index.
   * @param nodes
   * @returns
   */ async buildIndexFromNodes(nodes, options) {
        // Check if the index already has nodes with the same hash
        const newNodes = nodes.filter((node)=>Object.entries(this.indexStruct.nodesDict).reduce((acc, [key, value])=>{
                if (value.hash === node.hash) {
                    acc = false;
                }
                return acc;
            }, true));
        await this.insertNodes(newNodes, options);
    }
    /**
   * High level API: split documents, get embeddings, and build index.
   * @param documents
   * @param args
   * @returns
   */ static async fromDocuments(documents, args = {}) {
        args.storageContext = args.storageContext ?? await (0, _StorageContext.storageContextFromDefaults)({});
        args.serviceContext = args.serviceContext ?? (0, _ServiceContext.serviceContextFromDefaults)({});
        const docStore = args.storageContext.docStore;
        for (const doc of documents){
            docStore.setDocumentHash(doc.id_, doc.hash);
        }
        if (args.logProgress) {
            console.log("Using node parser on documents...");
        }
        args.nodes = await (0, _index1.runTransformations)(documents, [
            args.serviceContext.nodeParser
        ]);
        if (args.logProgress) {
            console.log("Finished parsing documents.");
        }
        return await this.init(args);
    }
    static async fromVectorStore(vectorStore, serviceContext, imageVectorStore) {
        if (!vectorStore.storesText) {
            throw new Error("Cannot initialize from a vector store that does not store text");
        }
        const storageContext = await (0, _StorageContext.storageContextFromDefaults)({
            vectorStore,
            imageVectorStore
        });
        const index = await this.init({
            nodes: [],
            storageContext,
            serviceContext
        });
        return index;
    }
    asRetriever(options) {
        return new VectorIndexRetriever({
            index: this,
            ...options
        });
    }
    asQueryEngine(options) {
        const { retriever, responseSynthesizer } = options ?? {};
        return new _RetrieverQueryEngine.RetrieverQueryEngine(retriever ?? this.asRetriever(), responseSynthesizer, options?.preFilters, options?.nodePostprocessors);
    }
    async insertNodesToStore(vectorStore, nodes) {
        const newIds = await vectorStore.add(nodes);
        // NOTE: if the vector store doesn't store text,
        // we need to add the nodes to the index struct and document store
        // NOTE: if the vector store keeps text,
        // we only need to add image and index nodes
        for(let i = 0; i < nodes.length; ++i){
            const type = nodes[i].getType();
            if (!vectorStore.storesText || type === _Node.ObjectType.INDEX || type === _Node.ObjectType.IMAGE) {
                const nodeWithoutEmbedding = nodes[i].clone();
                nodeWithoutEmbedding.embedding = undefined;
                this.indexStruct.addNode(nodeWithoutEmbedding, newIds[i]);
                await this.docStore.addDocuments([
                    nodeWithoutEmbedding
                ], true);
            }
        }
    }
    async insertNodes(nodes, options) {
        if (!nodes || nodes.length === 0) {
            return;
        }
        const { imageNodes, textNodes } = (0, _Node.splitNodesByType)(nodes);
        if (imageNodes.length > 0) {
            if (!this.imageVectorStore) {
                throw new Error("Cannot insert image nodes without image vector store");
            }
            const imageNodesWithEmbedding = await this.getImageNodeEmbeddingResults(imageNodes, options);
            await this.insertNodesToStore(this.imageVectorStore, imageNodesWithEmbedding);
        }
        const embeddingResults = await this.getNodeEmbeddingResults(textNodes, options);
        await this.insertNodesToStore(this.vectorStore, embeddingResults);
        await this.indexStore.addIndexStruct(this.indexStruct);
    }
    async deleteRefDoc(refDocId, deleteFromDocStore = true) {
        await this.deleteRefDocFromStore(this.vectorStore, refDocId);
        if (this.imageVectorStore) {
            await this.deleteRefDocFromStore(this.imageVectorStore, refDocId);
        }
        if (deleteFromDocStore) {
            await this.docStore.deleteDocument(refDocId, false);
        }
    }
    async deleteRefDocFromStore(vectorStore, refDocId) {
        vectorStore.delete(refDocId);
        if (!vectorStore.storesText) {
            const refDocInfo = await this.docStore.getRefDocInfo(refDocId);
            if (refDocInfo) {
                for (const nodeId of refDocInfo.nodeIds){
                    this.indexStruct.delete(nodeId);
                    vectorStore.delete(nodeId);
                }
            }
            await this.indexStore.addIndexStruct(this.indexStruct);
        }
    }
    /**
   * Calculates the embeddings for the given image nodes.
   *
   * @param nodes - An array of ImageNode objects representing the nodes for which embeddings are to be calculated.
   * @param {Object} [options] - An optional object containing additional parameters.
   *   @param {boolean} [options.logProgress] - A boolean indicating whether to log progress to the console (useful for debugging).
   */ async getImageNodeEmbeddingResults(nodes, options) {
        if (!this.imageEmbedModel) {
            return [];
        }
        const nodesWithEmbeddings = [];
        for(let i = 0; i < nodes.length; ++i){
            const node = nodes[i];
            if (options?.logProgress) {
                console.log(`Getting embedding for node ${i + 1}/${nodes.length}`);
            }
            node.embedding = await this.imageEmbedModel.getImageEmbedding(node.image);
            nodesWithEmbeddings.push(node);
        }
        return nodesWithEmbeddings;
    }
}
class VectorIndexRetriever {
    index;
    similarityTopK;
    imageSimilarityTopK;
    serviceContext;
    constructor({ index, similarityTopK, imageSimilarityTopK }){
        this.index = index;
        this.serviceContext = this.index.serviceContext;
        this.similarityTopK = similarityTopK ?? _constants.DEFAULT_SIMILARITY_TOP_K;
        this.imageSimilarityTopK = imageSimilarityTopK ?? _constants.DEFAULT_SIMILARITY_TOP_K;
    }
    async retrieve({ query, parentEvent, preFilters }) {
        let nodesWithScores = await this.textRetrieve(query, preFilters);
        nodesWithScores = nodesWithScores.concat(await this.textToImageRetrieve(query, preFilters));
        this.sendEvent(query, nodesWithScores, parentEvent);
        return nodesWithScores;
    }
    async textRetrieve(query, preFilters) {
        const options = {};
        const q = await this.buildVectorStoreQuery(this.index.embedModel, query, this.similarityTopK, preFilters);
        const result = await this.index.vectorStore.query(q, options);
        return this.buildNodeListFromQueryResult(result);
    }
    async textToImageRetrieve(query, preFilters) {
        if (!this.index.imageEmbedModel || !this.index.imageVectorStore) {
            // no-op if image embedding and vector store are not set
            return [];
        }
        const q = await this.buildVectorStoreQuery(this.index.imageEmbedModel, query, this.imageSimilarityTopK, preFilters);
        const result = await this.index.imageVectorStore.query(q, preFilters);
        return this.buildNodeListFromQueryResult(result);
    }
    sendEvent(query, nodesWithScores, parentEvent) {
        if (this.serviceContext.callbackManager.onRetrieve) {
            this.serviceContext.callbackManager.onRetrieve({
                query,
                nodes: nodesWithScores,
                event: _GlobalsHelper.globalsHelper.createEvent({
                    parentEvent,
                    type: "retrieve"
                })
            });
        }
    }
    async buildVectorStoreQuery(embedModel, query, similarityTopK, preFilters) {
        const queryEmbedding = await embedModel.getQueryEmbedding(query);
        return {
            queryEmbedding: queryEmbedding,
            mode: _types.VectorStoreQueryMode.DEFAULT,
            similarityTopK: similarityTopK,
            filters: preFilters ?? undefined
        };
    }
    buildNodeListFromQueryResult(result) {
        const nodesWithScores = [];
        for(let i = 0; i < result.ids.length; i++){
            const nodeFromResult = result.nodes?.[i];
            if (!this.index.indexStruct.nodesDict[result.ids[i]] && nodeFromResult) {
                this.index.indexStruct.nodesDict[result.ids[i]] = nodeFromResult;
            }
            const node = this.index.indexStruct.nodesDict[result.ids[i]];
            // XXX: Hack, if it's an image node, we reconstruct the image from the URL
            // Alternative: Store image in doc store and retrieve it here
            if (node instanceof _Node.ImageNode) {
                node.image = node.getUrl();
            }
            nodesWithScores.push({
                node: node,
                score: result.similarities[i]
            });
        }
        return nodesWithScores;
    }
    getServiceContext() {
        return this.serviceContext;
    }
}
