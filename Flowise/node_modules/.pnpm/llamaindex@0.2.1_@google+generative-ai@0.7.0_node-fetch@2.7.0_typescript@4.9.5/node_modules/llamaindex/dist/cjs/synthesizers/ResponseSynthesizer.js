"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ResponseSynthesizer", {
    enumerable: true,
    get: function() {
        return ResponseSynthesizer;
    }
});
const _Node = require("../Node.js");
const _Response = require("../Response.js");
const _ServiceContext = require("../ServiceContext.js");
const _utils = require("../llm/utils.js");
const _Mixin = require("../prompts/Mixin.js");
const _builders = require("./builders.js");
class ResponseSynthesizer extends _Mixin.PromptMixin {
    responseBuilder;
    serviceContext;
    metadataMode;
    constructor({ responseBuilder, serviceContext, metadataMode = _Node.MetadataMode.NONE } = {}){
        super();
        this.serviceContext = serviceContext ?? (0, _ServiceContext.serviceContextFromDefaults)();
        this.responseBuilder = responseBuilder ?? (0, _builders.getResponseBuilder)(this.serviceContext);
        this.metadataMode = metadataMode;
    }
    _getPromptModules() {
        return {};
    }
    _getPrompts() {
        const prompts = this.responseBuilder.getPrompts?.();
        return {
            ...prompts
        };
    }
    _updatePrompts(promptsDict) {
        this.responseBuilder.updatePrompts?.(promptsDict);
    }
    async synthesize({ query, nodesWithScore, parentEvent, stream }) {
        const textChunks = nodesWithScore.map(({ node })=>node.getContent(this.metadataMode));
        const nodes = nodesWithScore.map(({ node })=>node);
        if (stream) {
            const response = await this.responseBuilder.getResponse({
                query,
                textChunks,
                parentEvent,
                stream
            });
            return (0, _utils.streamConverter)(response, (chunk)=>new _Response.Response(chunk, nodes));
        }
        const response = await this.responseBuilder.getResponse({
            query,
            textChunks,
            parentEvent
        });
        return new _Response.Response(response, nodes);
    }
}
