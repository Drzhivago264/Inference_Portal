"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ClipEmbedding: function() {
        return ClipEmbedding;
    },
    ClipEmbeddingModelType: function() {
        return ClipEmbeddingModelType;
    }
});
const _MultiModalEmbedding = require("./MultiModalEmbedding.js");
const _utils = require("./utils.js");
var ClipEmbeddingModelType;
(function(ClipEmbeddingModelType) {
    ClipEmbeddingModelType["XENOVA_CLIP_VIT_BASE_PATCH32"] = "Xenova/clip-vit-base-patch32";
    ClipEmbeddingModelType["XENOVA_CLIP_VIT_BASE_PATCH16"] = "Xenova/clip-vit-base-patch16";
})(ClipEmbeddingModelType || (ClipEmbeddingModelType = {}));
class ClipEmbedding extends _MultiModalEmbedding.MultiModalEmbedding {
    modelType = "Xenova/clip-vit-base-patch16";
    tokenizer;
    processor;
    visionModel;
    textModel;
    async getTokenizer() {
        if (!this.tokenizer) {
            const { AutoTokenizer } = await import("@xenova/transformers");
            this.tokenizer = await AutoTokenizer.from_pretrained(this.modelType);
        }
        return this.tokenizer;
    }
    async getProcessor() {
        if (!this.processor) {
            const { AutoProcessor } = await import("@xenova/transformers");
            this.processor = await AutoProcessor.from_pretrained(this.modelType);
        }
        return this.processor;
    }
    async getVisionModel() {
        if (!this.visionModel) {
            const { CLIPVisionModelWithProjection } = await import("@xenova/transformers");
            this.visionModel = await CLIPVisionModelWithProjection.from_pretrained(this.modelType);
        }
        return this.visionModel;
    }
    async getTextModel() {
        if (!this.textModel) {
            const { CLIPTextModelWithProjection } = await import("@xenova/transformers");
            this.textModel = await CLIPTextModelWithProjection.from_pretrained(this.modelType);
        }
        return this.textModel;
    }
    async getImageEmbedding(image) {
        const loadedImage = await (0, _utils.readImage)(image);
        const imageInputs = await (await this.getProcessor())(loadedImage);
        const { image_embeds } = await (await this.getVisionModel())(imageInputs);
        return Array.from(image_embeds.data);
    }
    async getTextEmbedding(text) {
        const textInputs = await (await this.getTokenizer())([
            text
        ], {
            padding: true,
            truncation: true
        });
        const { text_embeds } = await (await this.getTextModel())(textInputs);
        return text_embeds.data;
    }
    async getQueryEmbedding(query) {
        return this.getTextEmbedding(query);
    }
}
