"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "CorrectnessEvaluator", {
    enumerable: true,
    get: function() {
        return CorrectnessEvaluator;
    }
});
const _Node = require("../Node.js");
const _ServiceContext = require("../ServiceContext.js");
const _Mixin = require("../prompts/Mixin.js");
const _prompts = require("./prompts.js");
const _utils = require("./utils.js");
class CorrectnessEvaluator extends _Mixin.PromptMixin {
    serviceContext;
    scoreThreshold;
    parserFunction;
    correctnessPrompt = _prompts.defaultCorrectnessSystemPrompt;
    constructor(params){
        super();
        this.serviceContext = params.serviceContext || (0, _ServiceContext.serviceContextFromDefaults)();
        this.correctnessPrompt = _prompts.defaultCorrectnessSystemPrompt;
        this.scoreThreshold = params.scoreThreshold || 4.0;
        this.parserFunction = params.parserFunction || _utils.defaultEvaluationParser;
    }
    _updatePrompts(prompts) {
        if ("correctnessPrompt" in prompts) {
            this.correctnessPrompt = prompts["correctnessPrompt"];
        }
    }
    /**
   *
   * @param query Query to evaluate
   * @param response  Response to evaluate
   * @param contexts Array of contexts
   * @param reference  Reference response
   */ async evaluate({ query, response, contexts, reference }) {
        if (query === null || response === null) {
            throw new Error("query, and response must be provided");
        }
        const messages = [
            {
                role: "system",
                content: this.correctnessPrompt()
            },
            {
                role: "user",
                content: (0, _prompts.defaultUserPrompt)({
                    query,
                    generatedAnswer: response,
                    referenceAnswer: reference || "(NO REFERENCE ANSWER SUPPLIED)"
                })
            }
        ];
        const evalResponse = await this.serviceContext.llm.chat({
            messages
        });
        const [score, reasoning] = this.parserFunction(evalResponse.message.content);
        return {
            query: query,
            response: response,
            passing: score >= this.scoreThreshold || score === null,
            score: score,
            feedback: reasoning
        };
    }
    /**
   * @param query Query to evaluate
   * @param response  Response to evaluate
   */ async evaluateResponse({ query, response }) {
        const responseStr = response?.response;
        const contexts = [];
        if (response) {
            for (const node of response.sourceNodes || []){
                contexts.push(node.getContent(_Node.MetadataMode.ALL));
            }
        }
        return this.evaluate({
            query,
            response: responseStr,
            contexts
        });
    }
}
