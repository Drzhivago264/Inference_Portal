"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ReActOutputParser", {
    enumerable: true,
    get: function() {
        return ReActOutputParser;
    }
});
const _types = require("./types.js");
function extractJsonStr(text) {
    const pattern = /\{.*\}/s;
    const match = text.match(pattern);
    if (!match) {
        throw new Error(`Could not extract json string from output: ${text}`);
    }
    return match[0];
}
function extractToolUse(inputText) {
    const pattern = /\s*Thought: (.*?)\nAction: ([a-zA-Z0-9_]+).*?\nAction Input: .*?(\{.*?\})/s;
    const match = inputText.match(pattern);
    if (!match) {
        throw new Error(`Could not extract tool use from input text: ${inputText}`);
    }
    const thought = match[1].trim();
    const action = match[2].trim();
    const actionInput = match[3].trim();
    return [
        thought,
        action,
        actionInput
    ];
}
function actionInputParser(jsonStr) {
    const processedString = jsonStr.replace(/(?<!\w)\'|\'(?!\w)/g, '"');
    const pattern = /"(\w+)":\s*"([^"]*)"/g;
    const matches = [
        ...processedString.matchAll(pattern)
    ];
    return Object.fromEntries(matches);
}
function extractFinalResponse(inputText) {
    const pattern = /\s*Thought:(.*?)Answer:(.*?)(?:$)/s;
    const match = inputText.match(pattern);
    if (!match) {
        throw new Error(`Could not extract final answer from input text: ${inputText}`);
    }
    const thought = match[1].trim();
    const answer = match[2].trim();
    return [
        thought,
        answer
    ];
}
class ReActOutputParser extends _types.BaseOutputParser {
    parse(output, isStreaming = false) {
        if (!output.includes("Thought:")) {
            // NOTE: handle the case where the agent directly outputs the answer
            // instead of following the thought-answer format
            return new _types.ResponseReasoningStep({
                thought: "(Implicit) I can answer without any more tools!",
                response: output,
                isStreaming
            });
        }
        if (output.includes("Answer:")) {
            const [thought, answer] = extractFinalResponse(output);
            return new _types.ResponseReasoningStep({
                thought: thought,
                response: answer,
                isStreaming
            });
        }
        if (output.includes("Action:")) {
            const [thought, action, action_input] = extractToolUse(output);
            const json_str = extractJsonStr(action_input);
            // First we try json, if this fails we use ast
            let actionInputDict;
            try {
                actionInputDict = JSON.parse(json_str);
            } catch (e) {
                actionInputDict = actionInputParser(json_str);
            }
            return new _types.ActionReasoningStep({
                thought: thought,
                action: action,
                actionInput: actionInputDict
            });
        }
        throw new Error(`Could not parse output: ${output}`);
    }
    format(output) {
        throw new Error("Not implemented");
    }
}
