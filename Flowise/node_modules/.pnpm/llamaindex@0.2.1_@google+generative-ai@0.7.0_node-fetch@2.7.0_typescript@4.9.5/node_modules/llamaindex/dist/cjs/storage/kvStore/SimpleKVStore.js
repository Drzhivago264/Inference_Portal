"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "SimpleKVStore", {
    enumerable: true,
    get: function() {
        return SimpleKVStore;
    }
});
const _env = require("@llamaindex/env");
const _lodash = /*#__PURE__*/ _interop_require_default(require("lodash"));
const _FileSystem = require("../FileSystem.js");
const _constants = require("../constants.js");
const _types = require("./types.js");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class SimpleKVStore extends _types.BaseKVStore {
    data;
    persistPath;
    fs;
    constructor(data = {}){
        super();
        this.data = data;
    }
    async put(key, val, collection = _constants.DEFAULT_COLLECTION) {
        if (!(collection in this.data)) {
            this.data[collection] = {};
        }
        this.data[collection][key] = _lodash.default.clone(val); // Creating a shallow copy of the object
        if (this.persistPath) {
            await this.persist(this.persistPath, this.fs);
        }
    }
    async get(key, collection = _constants.DEFAULT_COLLECTION) {
        const collectionData = this.data[collection];
        if (_lodash.default.isNil(collectionData)) {
            return null;
        }
        if (!(key in collectionData)) {
            return null;
        }
        return _lodash.default.clone(collectionData[key]); // Creating a shallow copy of the object
    }
    async getAll(collection = _constants.DEFAULT_COLLECTION) {
        return _lodash.default.clone(this.data[collection]); // Creating a shallow copy of the object
    }
    async delete(key, collection = _constants.DEFAULT_COLLECTION) {
        if (key in this.data[collection]) {
            delete this.data[collection][key];
            if (this.persistPath) {
                await this.persist(this.persistPath, this.fs);
            }
            return true;
        }
        return false;
    }
    async persist(persistPath, fs = _env.defaultFS) {
        // TODO: decide on a way to polyfill path
        const dirPath = _env.path.dirname(persistPath);
        if (!await (0, _FileSystem.exists)(fs, dirPath)) {
            await fs.mkdir(dirPath);
        }
        await fs.writeFile(persistPath, JSON.stringify(this.data));
    }
    static async fromPersistPath(persistPath, fs = _env.defaultFS) {
        const dirPath = _env.path.dirname(persistPath);
        if (!await (0, _FileSystem.exists)(fs, dirPath)) {
            await fs.mkdir(dirPath);
        }
        let data = {};
        try {
            const fileData = await fs.readFile(persistPath);
            data = JSON.parse(fileData.toString());
        } catch (e) {
            console.error(`No valid data found at path: ${persistPath} starting new store.`);
        }
        const store = new SimpleKVStore(data);
        store.persistPath = persistPath;
        store.fs = fs;
        return store;
    }
    toDict() {
        return this.data;
    }
    static fromDict(saveDict) {
        return new SimpleKVStore(saveDict);
    }
}
