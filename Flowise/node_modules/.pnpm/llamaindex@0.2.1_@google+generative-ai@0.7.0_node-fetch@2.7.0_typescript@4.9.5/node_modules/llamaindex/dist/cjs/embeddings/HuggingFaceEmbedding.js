"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    HuggingFaceEmbedding: function() {
        return HuggingFaceEmbedding;
    },
    HuggingFaceEmbeddingModelType: function() {
        return HuggingFaceEmbeddingModelType;
    }
});
const _types = require("./types.js");
var HuggingFaceEmbeddingModelType;
(function(HuggingFaceEmbeddingModelType) {
    HuggingFaceEmbeddingModelType["XENOVA_ALL_MINILM_L6_V2"] = "Xenova/all-MiniLM-L6-v2";
    HuggingFaceEmbeddingModelType["XENOVA_ALL_MPNET_BASE_V2"] = "Xenova/all-mpnet-base-v2";
})(HuggingFaceEmbeddingModelType || (HuggingFaceEmbeddingModelType = {}));
class HuggingFaceEmbedding extends _types.BaseEmbedding {
    modelType = "Xenova/all-MiniLM-L6-v2";
    quantized = true;
    extractor;
    constructor(init){
        super();
        Object.assign(this, init);
    }
    async getExtractor() {
        if (!this.extractor) {
            const { pipeline } = await import("@xenova/transformers");
            this.extractor = await pipeline("feature-extraction", this.modelType, {
                quantized: this.quantized
            });
        }
        return this.extractor;
    }
    async getTextEmbedding(text) {
        const extractor = await this.getExtractor();
        const output = await extractor(text, {
            pooling: "mean",
            normalize: true
        });
        return Array.from(output.data);
    }
    async getQueryEmbedding(query) {
        return this.getTextEmbedding(query);
    }
}
