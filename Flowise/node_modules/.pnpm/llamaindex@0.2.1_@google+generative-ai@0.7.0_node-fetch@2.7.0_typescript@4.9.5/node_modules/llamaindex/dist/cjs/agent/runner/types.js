"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AgentState: function() {
        return AgentState;
    },
    BaseAgentRunner: function() {
        return BaseAgentRunner;
    },
    TaskState: function() {
        return TaskState;
    }
});
const _types = require("../types.js");
class TaskState {
    task;
    stepQueue;
    completedSteps;
    constructor(init){
        Object.assign(this, init);
    }
}
class BaseAgentRunner extends _types.BaseAgent {
    constructor(init){
        super();
    }
    getCompletedStep(taskId, stepId, kwargs) {
        const completedSteps = this.getCompletedSteps(taskId, kwargs);
        for (const stepOutput of completedSteps){
            if (stepOutput.taskStep.stepId === stepId) {
                return stepOutput;
            }
        }
        throw new Error(`Step ${stepId} not found in task ${taskId}`);
    }
}
class AgentState {
    taskDict;
    constructor(init){
        Object.assign(this, init);
        if (!this.taskDict) {
            this.taskDict = {};
        }
    }
    getTask(taskId) {
        return this.taskDict[taskId].task;
    }
    getCompletedSteps(taskId) {
        return this.taskDict[taskId].completedSteps || [];
    }
    getStepQueue(taskId) {
        return this.taskDict[taskId].stepQueue || [];
    }
    addSteps(taskId, steps) {
        if (!this.taskDict[taskId].stepQueue) {
            this.taskDict[taskId].stepQueue = [];
        }
        this.taskDict[taskId].stepQueue.push(...steps);
    }
    addCompletedStep(taskId, stepOutputs) {
        if (!this.taskDict[taskId].completedSteps) {
            this.taskDict[taskId].completedSteps = [];
        }
        this.taskDict[taskId].completedSteps.push(...stepOutputs);
    }
}
