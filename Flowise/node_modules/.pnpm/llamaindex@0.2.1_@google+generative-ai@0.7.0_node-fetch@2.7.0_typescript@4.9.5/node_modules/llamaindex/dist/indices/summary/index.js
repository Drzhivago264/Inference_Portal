import _ from "lodash";
import { globalsHelper } from "../../GlobalsHelper.js";
import { defaultChoiceSelectPrompt } from "../../Prompt.js";
import { serviceContextFromDefaults } from "../../ServiceContext.js";
import { RetrieverQueryEngine } from "../../engines/query/index.js";
import { storageContextFromDefaults } from "../../storage/StorageContext.js";
import { CompactAndRefine, ResponseSynthesizer } from "../../synthesizers/index.js";
import { BaseIndex } from "../BaseIndex.js";
import { IndexList, IndexStructType } from "../json-to-index-struct.js";
import { defaultFormatNodeBatchFn, defaultParseChoiceSelectAnswerFn } from "./utils.js";
export var SummaryRetrieverMode;
(function(SummaryRetrieverMode) {
    SummaryRetrieverMode["DEFAULT"] = "default";
    // EMBEDDING = "embedding",
    SummaryRetrieverMode["LLM"] = "llm";
})(SummaryRetrieverMode || (SummaryRetrieverMode = {}));
/**
 * A SummaryIndex keeps nodes in a sequential order for use with summarization.
 */ export class SummaryIndex extends BaseIndex {
    constructor(init){
        super(init);
    }
    static async init(options) {
        const storageContext = options.storageContext ?? await storageContextFromDefaults({});
        const serviceContext = options.serviceContext ?? serviceContextFromDefaults({});
        const { docStore, indexStore } = storageContext;
        // Setup IndexStruct from storage
        const indexStructs = await indexStore.getIndexStructs();
        let indexStruct;
        if (options.indexStruct && indexStructs.length > 0) {
            throw new Error("Cannot initialize index with both indexStruct and indexStore");
        }
        if (options.indexStruct) {
            indexStruct = options.indexStruct;
        } else if (indexStructs.length == 1) {
            indexStruct = indexStructs[0].type === IndexStructType.LIST ? indexStructs[0] : null;
        } else if (indexStructs.length > 1 && options.indexId) {
            indexStruct = await indexStore.getIndexStruct(options.indexId);
        } else {
            indexStruct = null;
        }
        // check indexStruct type
        if (indexStruct && indexStruct.type !== IndexStructType.LIST) {
            throw new Error("Attempting to initialize SummaryIndex with non-list indexStruct");
        }
        if (indexStruct) {
            if (options.nodes) {
                throw new Error("Cannot initialize SummaryIndex with both nodes and indexStruct");
            }
        } else {
            if (!options.nodes) {
                throw new Error("Cannot initialize SummaryIndex without nodes or indexStruct");
            }
            indexStruct = await SummaryIndex.buildIndexFromNodes(options.nodes, storageContext.docStore);
            await indexStore.addIndexStruct(indexStruct);
        }
        return new SummaryIndex({
            storageContext,
            serviceContext,
            docStore,
            indexStore,
            indexStruct
        });
    }
    static async fromDocuments(documents, args = {}) {
        let { storageContext, serviceContext } = args;
        storageContext = storageContext ?? await storageContextFromDefaults({});
        serviceContext = serviceContext ?? serviceContextFromDefaults({});
        const docStore = storageContext.docStore;
        docStore.addDocuments(documents, true);
        for (const doc of documents){
            docStore.setDocumentHash(doc.id_, doc.hash);
        }
        const nodes = serviceContext.nodeParser.getNodesFromDocuments(documents);
        const index = await SummaryIndex.init({
            nodes,
            storageContext,
            serviceContext
        });
        return index;
    }
    asRetriever(options) {
        const { mode = "default" } = options ?? {};
        switch(mode){
            case "default":
                return new SummaryIndexRetriever(this);
            case "llm":
                return new SummaryIndexLLMRetriever(this);
            default:
                throw new Error(`Unknown retriever mode: ${mode}`);
        }
    }
    asQueryEngine(options) {
        let { retriever, responseSynthesizer } = options ?? {};
        if (!retriever) {
            retriever = this.asRetriever();
        }
        if (!responseSynthesizer) {
            const responseBuilder = new CompactAndRefine(this.serviceContext);
            responseSynthesizer = new ResponseSynthesizer({
                serviceContext: this.serviceContext,
                responseBuilder
            });
        }
        return new RetrieverQueryEngine(retriever, responseSynthesizer, options?.preFilters, options?.nodePostprocessors);
    }
    static async buildIndexFromNodes(nodes, docStore, indexStruct) {
        indexStruct = indexStruct || new IndexList();
        await docStore.addDocuments(nodes, true);
        for (const node of nodes){
            indexStruct.addNode(node);
        }
        return indexStruct;
    }
    async insertNodes(nodes) {
        for (const node of nodes){
            this.indexStruct.addNode(node);
        }
    }
    async deleteRefDoc(refDocId, deleteFromDocStore) {
        const refDocInfo = await this.docStore.getRefDocInfo(refDocId);
        if (!refDocInfo) {
            return;
        }
        await this.deleteNodes(refDocInfo.nodeIds, false);
        if (deleteFromDocStore) {
            await this.docStore.deleteRefDoc(refDocId, false);
        }
        return;
    }
    async deleteNodes(nodeIds, deleteFromDocStore) {
        this.indexStruct.nodes = this.indexStruct.nodes.filter((existingNodeId)=>!nodeIds.includes(existingNodeId));
        if (deleteFromDocStore) {
            for (const nodeId of nodeIds){
                await this.docStore.deleteDocument(nodeId, false);
            }
        }
        await this.storageContext.indexStore.addIndexStruct(this.indexStruct);
    }
    async getRefDocInfo() {
        const nodeDocIds = this.indexStruct.nodes;
        const nodes = await this.docStore.getNodes(nodeDocIds);
        const refDocInfoMap = {};
        for (const node of nodes){
            const refNode = node.sourceNode;
            if (_.isNil(refNode)) {
                continue;
            }
            const refDocInfo = await this.docStore.getRefDocInfo(refNode.nodeId);
            if (_.isNil(refDocInfo)) {
                continue;
            }
            refDocInfoMap[refNode.nodeId] = refDocInfo;
        }
        return refDocInfoMap;
    }
}
/**
 * Simple retriever for SummaryIndex that returns all nodes
 */ export class SummaryIndexRetriever {
    index;
    constructor(index){
        this.index = index;
    }
    async retrieve({ query, parentEvent }) {
        const nodeIds = this.index.indexStruct.nodes;
        const nodes = await this.index.docStore.getNodes(nodeIds);
        const result = nodes.map((node)=>({
                node: node,
                score: 1
            }));
        if (this.index.serviceContext.callbackManager.onRetrieve) {
            this.index.serviceContext.callbackManager.onRetrieve({
                query,
                nodes: result,
                event: globalsHelper.createEvent({
                    parentEvent,
                    type: "retrieve"
                })
            });
        }
        return result;
    }
    getServiceContext() {
        return this.index.serviceContext;
    }
}
/**
 * LLM retriever for SummaryIndex which lets you select the most relevant chunks.
 */ export class SummaryIndexLLMRetriever {
    index;
    choiceSelectPrompt;
    choiceBatchSize;
    formatNodeBatchFn;
    parseChoiceSelectAnswerFn;
    serviceContext;
    // eslint-disable-next-line max-params
    constructor(index, choiceSelectPrompt, choiceBatchSize = 10, formatNodeBatchFn, parseChoiceSelectAnswerFn, serviceContext){
        this.index = index;
        this.choiceSelectPrompt = choiceSelectPrompt || defaultChoiceSelectPrompt;
        this.choiceBatchSize = choiceBatchSize;
        this.formatNodeBatchFn = formatNodeBatchFn || defaultFormatNodeBatchFn;
        this.parseChoiceSelectAnswerFn = parseChoiceSelectAnswerFn || defaultParseChoiceSelectAnswerFn;
        this.serviceContext = serviceContext || index.serviceContext;
    }
    async retrieve({ query, parentEvent }) {
        const nodeIds = this.index.indexStruct.nodes;
        const results = [];
        for(let idx = 0; idx < nodeIds.length; idx += this.choiceBatchSize){
            const nodeIdsBatch = nodeIds.slice(idx, idx + this.choiceBatchSize);
            const nodesBatch = await this.index.docStore.getNodes(nodeIdsBatch);
            const fmtBatchStr = this.formatNodeBatchFn(nodesBatch);
            const input = {
                context: fmtBatchStr,
                query: query
            };
            const rawResponse = (await this.serviceContext.llm.complete({
                prompt: this.choiceSelectPrompt(input)
            })).text;
            // parseResult is a map from doc number to relevance score
            const parseResult = this.parseChoiceSelectAnswerFn(rawResponse, nodesBatch.length);
            const choiceNodeIds = nodeIdsBatch.filter((nodeId, idx)=>{
                return `${idx}` in parseResult;
            });
            const choiceNodes = await this.index.docStore.getNodes(choiceNodeIds);
            const nodeWithScores = choiceNodes.map((node, i)=>({
                    node: node,
                    score: _.get(parseResult, `${i + 1}`, 1)
                }));
            results.push(...nodeWithScores);
        }
        if (this.serviceContext.callbackManager.onRetrieve) {
            this.serviceContext.callbackManager.onRetrieve({
                query,
                nodes: results,
                event: globalsHelper.createEvent({
                    parentEvent,
                    type: "retrieve"
                })
            });
        }
        return results;
    }
    getServiceContext() {
        return this.serviceContext;
    }
}
