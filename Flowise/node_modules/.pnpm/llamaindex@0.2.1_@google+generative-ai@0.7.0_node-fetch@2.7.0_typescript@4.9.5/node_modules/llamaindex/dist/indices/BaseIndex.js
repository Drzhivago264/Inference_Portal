import { runTransformations } from "../ingestion/IngestionPipeline.js";
import { IndexStruct } from "./IndexStruct.js";
import { IndexStructType } from "./json-to-index-struct.js";
// A table of keywords mapping keywords to text chunks.
export class KeywordTable extends IndexStruct {
    table = new Map();
    type = IndexStructType.KEYWORD_TABLE;
    addNode(keywords, nodeId) {
        keywords.forEach((keyword)=>{
            if (!this.table.has(keyword)) {
                this.table.set(keyword, new Set());
            }
            this.table.get(keyword).add(nodeId);
        });
    }
    deleteNode(keywords, nodeId) {
        keywords.forEach((keyword)=>{
            if (this.table.has(keyword)) {
                this.table.get(keyword).delete(nodeId);
            }
        });
    }
    toJson() {
        return {
            ...super.toJson(),
            table: this.table,
            type: this.type
        };
    }
}
/**
 * Indexes are the data structure that we store our nodes and embeddings in so
 * they can be retrieved for our queries.
 */ export class BaseIndex {
    serviceContext;
    storageContext;
    docStore;
    vectorStore;
    indexStore;
    indexStruct;
    constructor(init){
        this.serviceContext = init.serviceContext;
        this.storageContext = init.storageContext;
        this.docStore = init.docStore;
        this.vectorStore = init.vectorStore;
        this.indexStore = init.indexStore;
        this.indexStruct = init.indexStruct;
    }
    /**
   * Insert a document into the index.
   * @param document
   */ async insert(document) {
        const nodes = await runTransformations([
            document
        ], [
            this.serviceContext.nodeParser
        ]);
        await this.insertNodes(nodes);
        this.docStore.setDocumentHash(document.id_, document.hash);
    }
}
