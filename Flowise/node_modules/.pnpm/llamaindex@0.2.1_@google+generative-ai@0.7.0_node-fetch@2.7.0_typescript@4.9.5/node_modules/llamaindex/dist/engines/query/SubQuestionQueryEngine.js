import { randomUUID } from "@llamaindex/env";
import { TextNode } from "../../Node.js";
import { LLMQuestionGenerator } from "../../QuestionGenerator.js";
import { serviceContextFromDefaults } from "../../ServiceContext.js";
import { PromptMixin } from "../../prompts/Mixin.js";
import { CompactAndRefine, ResponseSynthesizer } from "../../synthesizers/index.js";
/**
 * SubQuestionQueryEngine decomposes a question into subquestions and then
 */ export class SubQuestionQueryEngine extends PromptMixin {
    responseSynthesizer;
    questionGen;
    queryEngines;
    metadatas;
    constructor(init){
        super();
        this.questionGen = init.questionGen;
        this.responseSynthesizer = init.responseSynthesizer ?? new ResponseSynthesizer();
        this.queryEngines = init.queryEngineTools;
        this.metadatas = init.queryEngineTools.map((tool)=>tool.metadata);
    }
    _getPromptModules() {
        return {
            questionGen: this.questionGen,
            responseSynthesizer: this.responseSynthesizer
        };
    }
    static fromDefaults(init) {
        const serviceContext = init.serviceContext ?? serviceContextFromDefaults({});
        const questionGen = init.questionGen ?? new LLMQuestionGenerator();
        const responseSynthesizer = init.responseSynthesizer ?? new ResponseSynthesizer({
            responseBuilder: new CompactAndRefine(serviceContext),
            serviceContext
        });
        return new SubQuestionQueryEngine({
            questionGen,
            responseSynthesizer,
            queryEngineTools: init.queryEngineTools
        });
    }
    async query(params) {
        const { query, stream } = params;
        const subQuestions = await this.questionGen.generate(this.metadatas, query);
        // groups final retrieval+synthesis operation
        const parentEvent = params.parentEvent || {
            id: randomUUID(),
            type: "wrapper",
            tags: [
                "final"
            ]
        };
        // groups all sub-queries
        const subQueryParentEvent = {
            id: randomUUID(),
            parentId: parentEvent.id,
            type: "wrapper",
            tags: [
                "intermediate"
            ]
        };
        const subQNodes = await Promise.all(subQuestions.map((subQ)=>this.querySubQ(subQ, subQueryParentEvent)));
        const nodesWithScore = subQNodes.filter((node)=>node !== null).map((node)=>node);
        if (stream) {
            return this.responseSynthesizer.synthesize({
                query,
                nodesWithScore,
                parentEvent,
                stream: true
            });
        }
        return this.responseSynthesizer.synthesize({
            query,
            nodesWithScore,
            parentEvent
        });
    }
    async querySubQ(subQ, parentEvent) {
        try {
            const question = subQ.subQuestion;
            const queryEngine = this.queryEngines.find((tool)=>tool.metadata.name === subQ.toolName);
            if (!queryEngine) {
                return null;
            }
            const responseText = await queryEngine?.call?.({
                query: question,
                parentEvent
            });
            if (!responseText) {
                return null;
            }
            const nodeText = `Sub question: ${question}\nResponse: ${responseText}`;
            const node = new TextNode({
                text: nodeText
            });
            return {
                node,
                score: 0
            };
        } catch (error) {
            return null;
        }
    }
}
