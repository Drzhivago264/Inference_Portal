import { randomUUID } from "@llamaindex/env";
import { CallbackManager } from "../../callbacks/CallbackManager.js";
import { AgentChatResponse, ChatResponseMode, StreamingAgentChatResponse } from "../../engines/chat/index.js";
import { ChatMemoryBuffer } from "../../memory/ChatMemoryBuffer.js";
import { Task, TaskStep } from "../types.js";
import { AgentState, BaseAgentRunner, TaskState } from "./types.js";
const validateStepFromArgs = (taskId, input, step, kwargs)=>{
    if (step) {
        if (input) {
            throw new Error("Cannot specify both `step` and `input`");
        }
        return step;
    } else {
        if (!input) return;
        return new TaskStep(taskId, step, input, kwargs);
    }
};
export class AgentRunner extends BaseAgentRunner {
    agentWorker;
    state;
    memory;
    callbackManager;
    initTaskStateKwargs;
    deleteTaskOnFinish;
    defaultToolChoice;
    /**
   * Creates an AgentRunner.
   */ constructor(params){
        super();
        this.agentWorker = params.agentWorker;
        this.state = params.state ?? new AgentState();
        this.memory = params.memory ?? new ChatMemoryBuffer({
            chatHistory: params.chatHistory
        });
        this.callbackManager = params.callbackManager ?? new CallbackManager();
        this.initTaskStateKwargs = params.initTaskStateKwargs ?? {};
        this.deleteTaskOnFinish = params.deleteTaskOnFinish ?? false;
        this.defaultToolChoice = params.defaultToolChoice ?? "auto";
    }
    /**
   * Creates a task.
   * @param input
   * @param kwargs
   */ createTask(input, kwargs) {
        let extraState;
        if (!this.initTaskStateKwargs) {
            if (kwargs && "extraState" in kwargs) {
                if (extraState) {
                    delete extraState["extraState"];
                }
            }
        } else {
            if (kwargs && "extraState" in kwargs) {
                throw new Error("Cannot specify both `extraState` and `initTaskStateKwargs`");
            } else {
                extraState = this.initTaskStateKwargs;
            }
        }
        const task = new Task({
            taskId: randomUUID(),
            input,
            memory: this.memory,
            extraState,
            ...kwargs
        });
        const initialStep = this.agentWorker.initializeStep(task);
        const taskState = new TaskState({
            task,
            stepQueue: [
                initialStep
            ]
        });
        this.state.taskDict[task.taskId] = taskState;
        return task;
    }
    /**
   * Deletes the task.
   * @param taskId
   */ deleteTask(taskId) {
        delete this.state.taskDict[taskId];
    }
    /**
   * Returns the list of tasks.
   */ listTasks() {
        return Object.values(this.state.taskDict).map((taskState)=>taskState.task);
    }
    /**
   * Returns the task.
   */ getTask(taskId) {
        return this.state.taskDict[taskId].task;
    }
    /**
   * Returns the completed steps in the task.
   * @param taskId
   * @param kwargs
   */ getCompletedSteps(taskId) {
        return this.state.taskDict[taskId].completedSteps;
    }
    /**
   * Returns the next steps in the task.
   * @param taskId
   * @param kwargs
   */ getUpcomingSteps(taskId, kwargs) {
        return this.state.taskDict[taskId].stepQueue;
    }
    async _runStep(taskId, step, mode = ChatResponseMode.WAIT, kwargs) {
        const task = this.state.getTask(taskId);
        const curStep = step || this.state.getStepQueue(taskId).shift();
        let curStepOutput;
        if (!curStep) {
            throw new Error(`No step found for task ${taskId}`);
        }
        if (mode === ChatResponseMode.WAIT) {
            curStepOutput = await this.agentWorker.runStep(curStep, task, kwargs);
        } else if (mode === ChatResponseMode.STREAM) {
            curStepOutput = await this.agentWorker.streamStep(curStep, task, kwargs);
        } else {
            throw new Error(`Invalid mode: ${mode}`);
        }
        const nextSteps = curStepOutput.nextSteps;
        this.state.addSteps(taskId, nextSteps);
        this.state.addCompletedStep(taskId, [
            curStepOutput
        ]);
        return curStepOutput;
    }
    /**
   * Runs the next step in the task.
   * @param taskId
   * @param kwargs
   * @param step
   * @returns
   */ async runStep(taskId, input, step, kwargs = {}) {
        const curStep = validateStepFromArgs(taskId, input, step, kwargs);
        return this._runStep(taskId, curStep, ChatResponseMode.WAIT, kwargs);
    }
    /**
   * Runs the step and returns the response.
   * @param taskId
   * @param input
   * @param step
   * @param kwargs
   */ async streamStep(taskId, input, step, kwargs) {
        const curStep = validateStepFromArgs(taskId, input, step, kwargs);
        return this._runStep(taskId, curStep, ChatResponseMode.STREAM, kwargs);
    }
    /**
   * Finalizes the response and returns it.
   * @param taskId
   * @param kwargs
   * @param stepOutput
   * @returns
   */ async finalizeResponse(taskId, stepOutput, kwargs) {
        if (!stepOutput) {
            stepOutput = this.getCompletedSteps(taskId)[this.getCompletedSteps(taskId).length - 1];
        }
        if (!stepOutput.isLast) {
            throw new Error("finalizeResponse can only be called on the last step output");
        }
        if (!(stepOutput.output instanceof StreamingAgentChatResponse)) {
            if (!(stepOutput.output instanceof AgentChatResponse)) {
                throw new Error(`When \`isLast\` is True, cur_step_output.output must be AGENT_CHAT_RESPONSE_TYPE: ${stepOutput.output}`);
            }
        }
        this.agentWorker.finalizeTask(this.getTask(taskId), kwargs);
        if (this.deleteTaskOnFinish) {
            this.deleteTask(taskId);
        }
        return stepOutput.output;
    }
    async _chat({ message, toolChoice, stream }) {
        const task = this.createTask(message);
        let resultOutput;
        const mode = stream ? ChatResponseMode.STREAM : ChatResponseMode.WAIT;
        while(true){
            const curStepOutput = await this._runStep(task.taskId, undefined, mode, {
                toolChoice
            });
            if (curStepOutput.isLast) {
                resultOutput = curStepOutput;
                break;
            }
            toolChoice = "auto";
        }
        return this.finalizeResponse(task.taskId, resultOutput);
    }
    async chat({ message, chatHistory, toolChoice, stream }) {
        if (!toolChoice) {
            toolChoice = this.defaultToolChoice;
        }
        const chatResponse = await this._chat({
            message,
            chatHistory,
            toolChoice,
            stream
        });
        return chatResponse;
    }
    _getPromptModules() {
        return [];
    }
    _getPrompts() {
        return [];
    }
    /**
   * Resets the agent.
   */ reset() {
        this.state = new AgentState();
    }
    getCompletedStep(taskId, stepId, kwargs) {
        const completedSteps = this.getCompletedSteps(taskId);
        for (const stepOutput of completedSteps){
            if (stepOutput.taskStep.stepId === stepId) {
                return stepOutput;
            }
        }
        throw new Error(`Step ${stepId} not found in task ${taskId}`);
    }
    /**
   * Undoes the step.
   * @param taskId
   */ undoStep(taskId) {}
}
