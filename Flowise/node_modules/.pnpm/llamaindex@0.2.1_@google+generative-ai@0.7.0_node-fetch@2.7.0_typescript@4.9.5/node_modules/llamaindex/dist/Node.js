import { createSHA256, path, randomUUID } from "@llamaindex/env";
import _ from "lodash";
export var NodeRelationship;
(function(NodeRelationship) {
    NodeRelationship["SOURCE"] = "SOURCE";
    NodeRelationship["PREVIOUS"] = "PREVIOUS";
    NodeRelationship["NEXT"] = "NEXT";
    NodeRelationship["PARENT"] = "PARENT";
    NodeRelationship["CHILD"] = "CHILD";
})(NodeRelationship || (NodeRelationship = {}));
export var ObjectType;
(function(ObjectType) {
    ObjectType["TEXT"] = "TEXT";
    ObjectType["IMAGE"] = "IMAGE";
    ObjectType["INDEX"] = "INDEX";
    ObjectType["DOCUMENT"] = "DOCUMENT";
    ObjectType["IMAGE_DOCUMENT"] = "IMAGE_DOCUMENT";
})(ObjectType || (ObjectType = {}));
export var MetadataMode;
(function(MetadataMode) {
    MetadataMode["ALL"] = "ALL";
    MetadataMode["EMBED"] = "EMBED";
    MetadataMode["LLM"] = "LLM";
    MetadataMode["NONE"] = "NONE";
})(MetadataMode || (MetadataMode = {}));
/**
 * Generic abstract class for retrievable nodes
 */ export class BaseNode {
    /**
   * The unique ID of the Node/Document. The trailing underscore is here
   * to avoid collisions with the id keyword in Python.
   *
   * Set to a UUID by default.
   */ id_ = randomUUID();
    embedding;
    // Metadata fields
    metadata = {};
    excludedEmbedMetadataKeys = [];
    excludedLlmMetadataKeys = [];
    relationships = {};
    hash = "";
    constructor(init){
        Object.assign(this, init);
    }
    get sourceNode() {
        const relationship = this.relationships["SOURCE"];
        if (Array.isArray(relationship)) {
            throw new Error("Source object must be a single RelatedNodeInfo object");
        }
        return relationship;
    }
    get prevNode() {
        const relationship = this.relationships["PREVIOUS"];
        if (Array.isArray(relationship)) {
            throw new Error("Previous object must be a single RelatedNodeInfo object");
        }
        return relationship;
    }
    get nextNode() {
        const relationship = this.relationships["NEXT"];
        if (Array.isArray(relationship)) {
            throw new Error("Next object must be a single RelatedNodeInfo object");
        }
        return relationship;
    }
    get parentNode() {
        const relationship = this.relationships["PARENT"];
        if (Array.isArray(relationship)) {
            throw new Error("Parent object must be a single RelatedNodeInfo object");
        }
        return relationship;
    }
    get childNodes() {
        const relationship = this.relationships["CHILD"];
        if (!Array.isArray(relationship)) {
            throw new Error("Child object must be a an array of RelatedNodeInfo objects");
        }
        return relationship;
    }
    getEmbedding() {
        if (this.embedding === undefined) {
            throw new Error("Embedding not set");
        }
        return this.embedding;
    }
    asRelatedNodeInfo() {
        return {
            nodeId: this.id_,
            metadata: this.metadata,
            hash: this.hash
        };
    }
    /**
   * Called by built in JSON.stringify (see https://javascript.info/json)
   * Properties are read-only as they are not deep-cloned (not necessary for stringification).
   * @see toMutableJSON - use to return a mutable JSON instead
   */ toJSON() {
        return {
            ...this,
            type: this.getType()
        };
    }
    clone() {
        return jsonToNode(this.toMutableJSON());
    }
    /**
   * Converts the object to a JSON representation.
   * Properties can be safely modified as a deep clone of the properties are created.
   * @return {Record<string, any>} - The JSON representation of the object.
   */ toMutableJSON() {
        return _.cloneDeep(this.toJSON());
    }
}
/**
 * TextNode is the default node type for text. Most common node type in LlamaIndex.TS
 */ export class TextNode extends BaseNode {
    text = "";
    textTemplate = "";
    startCharIdx;
    endCharIdx;
    // textTemplate: NOTE write your own formatter if needed
    // metadataTemplate: NOTE write your own formatter if needed
    metadataSeparator = "\n";
    constructor(init){
        super(init);
        Object.assign(this, init);
        if (new.target === TextNode) {
            // Don't generate the hash repeatedly so only do it if this is
            // constructing the derived class
            this.hash = init?.hash ?? this.generateHash();
        }
    }
    /**
   * Generate a hash of the text node.
   * The ID is not part of the hash as it can change independent of content.
   * @returns
   */ generateHash() {
        const hashFunction = createSHA256();
        hashFunction.update(`type=${this.getType()}`);
        hashFunction.update(`startCharIdx=${this.startCharIdx} endCharIdx=${this.endCharIdx}`);
        hashFunction.update(this.getContent("ALL"));
        return hashFunction.digest();
    }
    getType() {
        return "TEXT";
    }
    getContent(metadataMode = "NONE") {
        const metadataStr = this.getMetadataStr(metadataMode).trim();
        return `${metadataStr}\n\n${this.text}`.trim();
    }
    getMetadataStr(metadataMode) {
        if (metadataMode === "NONE") {
            return "";
        }
        const usableMetadataKeys = new Set(Object.keys(this.metadata).sort());
        if (metadataMode === "LLM") {
            for (const key of this.excludedLlmMetadataKeys){
                usableMetadataKeys.delete(key);
            }
        } else if (metadataMode === "EMBED") {
            for (const key of this.excludedEmbedMetadataKeys){
                usableMetadataKeys.delete(key);
            }
        }
        return [
            ...usableMetadataKeys
        ].map((key)=>`${key}: ${this.metadata[key]}`).join(this.metadataSeparator);
    }
    setContent(value) {
        this.text = value;
        this.hash = this.generateHash();
    }
    getNodeInfo() {
        return {
            start: this.startCharIdx,
            end: this.endCharIdx
        };
    }
    getText() {
        return this.getContent("NONE");
    }
}
export class IndexNode extends TextNode {
    indexId = "";
    constructor(init){
        super(init);
        Object.assign(this, init);
        if (new.target === IndexNode) {
            this.hash = init?.hash ?? this.generateHash();
        }
    }
    getType() {
        return "INDEX";
    }
}
/**
 * A document is just a special text node with a docId.
 */ export class Document extends TextNode {
    constructor(init){
        super(init);
        Object.assign(this, init);
        if (new.target === Document) {
            this.hash = init?.hash ?? this.generateHash();
        }
    }
    getType() {
        return "DOCUMENT";
    }
}
export function jsonToNode(json, type) {
    if (!json.type && !type) {
        throw new Error("Node type not found");
    }
    const nodeType = type || json.type;
    switch(nodeType){
        case "TEXT":
            return new TextNode(json);
        case "INDEX":
            return new IndexNode(json);
        case "DOCUMENT":
            return new Document(json);
        case "IMAGE_DOCUMENT":
            return new ImageDocument(json);
        default:
            throw new Error(`Invalid node type: ${nodeType}`);
    }
}
export class ImageNode extends TextNode {
    image;
    constructor(init){
        super(init);
        this.image = init.image;
    }
    getType() {
        return "IMAGE";
    }
    getUrl() {
        // id_ stores the relative path, convert it to the URL of the file
        const absPath = path.resolve(this.id_);
        return new URL(`file://${absPath}`);
    }
}
export class ImageDocument extends ImageNode {
    constructor(init){
        super(init);
        if (new.target === ImageDocument) {
            this.hash = init?.hash ?? this.generateHash();
        }
    }
    getType() {
        return "IMAGE_DOCUMENT";
    }
}
export function splitNodesByType(nodes) {
    const imageNodes = [];
    const textNodes = [];
    for (const node of nodes){
        if (node instanceof ImageNode) {
            imageNodes.push(node);
        } else if (node instanceof TextNode) {
            textNodes.push(node);
        }
    }
    return {
        imageNodes,
        textNodes
    };
}
