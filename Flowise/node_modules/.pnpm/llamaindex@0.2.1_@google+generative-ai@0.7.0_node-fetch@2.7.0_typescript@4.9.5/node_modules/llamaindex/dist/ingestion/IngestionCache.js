import { createSHA256 } from "@llamaindex/env";
import { MetadataMode } from "../Node.js";
import { docToJson, jsonToDoc } from "../storage/docStore/utils.js";
import { SimpleKVStore } from "../storage/kvStore/SimpleKVStore.js";
const transformToJSON = (obj)=>{
    const seen = [];
    const replacer = (key, value)=>{
        if (value != null && typeof value == "object") {
            if (seen.indexOf(value) >= 0) {
                return;
            }
            seen.push(value);
        }
        return value;
    };
    // this is a custom replacer function that will allow us to handle circular references
    const jsonStr = JSON.stringify(obj, replacer);
    return jsonStr;
};
export function getTransformationHash(nodes, transform) {
    const nodesStr = nodes.map((node)=>node.getContent(MetadataMode.ALL)).join("");
    const transformString = transformToJSON(transform);
    const hash = createSHA256();
    hash.update(nodesStr + transformString);
    return hash.digest();
}
export class IngestionCache {
    collection = "llama_cache";
    cache;
    nodesKey = "nodes";
    constructor(collection){
        if (collection) {
            this.collection = collection;
        }
        this.cache = new SimpleKVStore();
    }
    async put(hash, nodes) {
        const val = {
            [this.nodesKey]: nodes.map((node)=>docToJson(node))
        };
        await this.cache.put(hash, val, this.collection);
    }
    async get(hash) {
        const json = await this.cache.get(hash, this.collection);
        if (!json || !json[this.nodesKey] || !Array.isArray(json[this.nodesKey])) {
            return undefined;
        }
        return json[this.nodesKey].map((doc)=>jsonToDoc(doc));
    }
}
