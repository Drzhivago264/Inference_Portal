import { BaseEmbedding } from "./types.js";
export var HuggingFaceEmbeddingModelType;
(function(HuggingFaceEmbeddingModelType) {
    HuggingFaceEmbeddingModelType["XENOVA_ALL_MINILM_L6_V2"] = "Xenova/all-MiniLM-L6-v2";
    HuggingFaceEmbeddingModelType["XENOVA_ALL_MPNET_BASE_V2"] = "Xenova/all-mpnet-base-v2";
})(HuggingFaceEmbeddingModelType || (HuggingFaceEmbeddingModelType = {}));
/**
 * Uses feature extraction from '@xenova/transformers' to generate embeddings.
 * Per default the model [XENOVA_ALL_MINILM_L6_V2](https://huggingface.co/Xenova/all-MiniLM-L6-v2) is used.
 *
 * Can be changed by setting the `modelType` parameter in the constructor, e.g.:
 * ```
 * new HuggingFaceEmbedding({
 *     modelType: HuggingFaceEmbeddingModelType.XENOVA_ALL_MPNET_BASE_V2,
 * });
 * ```
 *
 * @extends BaseEmbedding
 */ export class HuggingFaceEmbedding extends BaseEmbedding {
    modelType = "Xenova/all-MiniLM-L6-v2";
    quantized = true;
    extractor;
    constructor(init){
        super();
        Object.assign(this, init);
    }
    async getExtractor() {
        if (!this.extractor) {
            const { pipeline } = await import("@xenova/transformers");
            this.extractor = await pipeline("feature-extraction", this.modelType, {
                quantized: this.quantized
            });
        }
        return this.extractor;
    }
    async getTextEmbedding(text) {
        const extractor = await this.getExtractor();
        const output = await extractor(text, {
            pooling: "mean",
            normalize: true
        });
        return Array.from(output.data);
    }
    async getQueryEmbedding(query) {
        return this.getTextEmbedding(query);
    }
}
