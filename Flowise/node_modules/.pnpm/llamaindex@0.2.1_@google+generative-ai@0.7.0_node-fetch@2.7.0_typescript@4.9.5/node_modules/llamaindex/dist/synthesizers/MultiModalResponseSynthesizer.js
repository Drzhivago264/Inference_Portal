import { MetadataMode, splitNodesByType } from "../Node.js";
import { Response } from "../Response.js";
import { serviceContextFromDefaults } from "../ServiceContext.js";
import { imageToDataUrl } from "../embeddings/index.js";
import { PromptMixin } from "../prompts/Mixin.js";
import { defaultTextQaPrompt } from "./../Prompt.js";
export class MultiModalResponseSynthesizer extends PromptMixin {
    serviceContext;
    metadataMode;
    textQATemplate;
    constructor({ serviceContext, textQATemplate, metadataMode } = {}){
        super();
        this.serviceContext = serviceContext ?? serviceContextFromDefaults();
        this.metadataMode = metadataMode ?? MetadataMode.NONE;
        this.textQATemplate = textQATemplate ?? defaultTextQaPrompt;
    }
    _getPrompts() {
        return {
            textQATemplate: this.textQATemplate
        };
    }
    _updatePrompts(promptsDict) {
        if (promptsDict.textQATemplate) {
            this.textQATemplate = promptsDict.textQATemplate;
        }
    }
    async synthesize({ query, nodesWithScore, parentEvent, stream }) {
        if (stream) {
            throw new Error("streaming not implemented");
        }
        const nodes = nodesWithScore.map(({ node })=>node);
        const { imageNodes, textNodes } = splitNodesByType(nodes);
        const textChunks = textNodes.map((node)=>node.getContent(this.metadataMode));
        // TODO: use builders to generate context
        const context = textChunks.join("\n\n");
        const textPrompt = this.textQATemplate({
            context,
            query
        });
        const images = await Promise.all(imageNodes.map(async (node)=>{
            return {
                type: "image_url",
                image_url: {
                    url: await imageToDataUrl(node.image)
                }
            };
        }));
        const prompt = [
            {
                type: "text",
                text: textPrompt
            },
            ...images
        ];
        const response = await this.serviceContext.llm.complete({
            prompt,
            parentEvent
        });
        return new Response(response.text, nodes);
    }
}
