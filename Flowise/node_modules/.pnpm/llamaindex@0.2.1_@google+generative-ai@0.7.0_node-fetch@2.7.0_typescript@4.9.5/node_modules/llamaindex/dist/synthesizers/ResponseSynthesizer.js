import { MetadataMode } from "../Node.js";
import { Response } from "../Response.js";
import { serviceContextFromDefaults } from "../ServiceContext.js";
import { streamConverter } from "../llm/utils.js";
import { PromptMixin } from "../prompts/Mixin.js";
import { getResponseBuilder } from "./builders.js";
/**
 * A ResponseSynthesizer is used to generate a response from a query and a list of nodes.
 */ export class ResponseSynthesizer extends PromptMixin {
    responseBuilder;
    serviceContext;
    metadataMode;
    constructor({ responseBuilder, serviceContext, metadataMode = MetadataMode.NONE } = {}){
        super();
        this.serviceContext = serviceContext ?? serviceContextFromDefaults();
        this.responseBuilder = responseBuilder ?? getResponseBuilder(this.serviceContext);
        this.metadataMode = metadataMode;
    }
    _getPromptModules() {
        return {};
    }
    _getPrompts() {
        const prompts = this.responseBuilder.getPrompts?.();
        return {
            ...prompts
        };
    }
    _updatePrompts(promptsDict) {
        this.responseBuilder.updatePrompts?.(promptsDict);
    }
    async synthesize({ query, nodesWithScore, parentEvent, stream }) {
        const textChunks = nodesWithScore.map(({ node })=>node.getContent(this.metadataMode));
        const nodes = nodesWithScore.map(({ node })=>node);
        if (stream) {
            const response = await this.responseBuilder.getResponse({
                query,
                textChunks,
                parentEvent,
                stream
            });
            return streamConverter(response, (chunk)=>new Response(chunk, nodes));
        }
        const response = await this.responseBuilder.getResponse({
            query,
            textChunks,
            parentEvent
        });
        return new Response(response, nodes);
    }
}
