import { RunTree, RunTreeConfig, RunnableConfigLike } from "./run_trees.js";
export type RunTreeLike = RunTree;
type WrapArgReturnPair<Pair> = Pair extends [
    infer Args extends any[],
    infer Return
] ? {
    (...args: Args): Promise<Return>;
    (...args: [runTree: RunTreeLike, ...rest: Args]): Promise<Return>;
    (...args: [config: RunnableConfigLike, ...rest: Args]): Promise<Return>;
} : never;
type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I : never;
export type TraceableFunction<Func extends (...args: any[]) => any> = Func extends {
    (...args: infer A1): infer R1;
    (...args: infer A2): infer R2;
    (...args: infer A3): infer R3;
    (...args: infer A4): infer R4;
    (...args: infer A5): infer R5;
} ? UnionToIntersection<WrapArgReturnPair<[A1, R1] | [A2, R2] | [A3, R3] | [A4, R4] | [A5, R5]>> : Func extends {
    (...args: infer A1): infer R1;
    (...args: infer A2): infer R2;
    (...args: infer A3): infer R3;
    (...args: infer A4): infer R4;
} ? UnionToIntersection<WrapArgReturnPair<[A1, R1] | [A2, R2] | [A3, R3] | [A4, R4]>> : Func extends {
    (...args: infer A1): infer R1;
    (...args: infer A2): infer R2;
    (...args: infer A3): infer R3;
} ? UnionToIntersection<WrapArgReturnPair<[A1, R1] | [A2, R2] | [A3, R3]>> : Func extends {
    (...args: infer A1): infer R1;
    (...args: infer A2): infer R2;
} ? UnionToIntersection<WrapArgReturnPair<[A1, R1] | [A2, R2]>> : Func extends {
    (...args: infer A1): infer R1;
} ? UnionToIntersection<WrapArgReturnPair<[A1, R1]>> : never;
/**
 * Higher-order function that takes function as input and returns a
 * "TraceableFunction" - a wrapped version of the input that
 * automatically handles tracing. If the returned traceable function calls any
 * traceable functions, those are automatically traced as well.
 *
 * The returned TraceableFunction can accept a run tree or run tree config as
 * its first argument. If omitted, it will default to the caller's run tree,
 * or will be treated as a root run.
 *
 * @param wrappedFunc Targeted function to be traced
 * @param config Additional metadata such as name, tags or providing
 *     a custom LangSmith client instance
 */
export declare function traceable<Func extends (...args: any[]) => any>(wrappedFunc: Func, config?: Partial<RunTreeConfig>): TraceableFunction<Func>;
export declare function isTraceableFunction(x: unknown): x is TraceableFunction<any>;
export {};
