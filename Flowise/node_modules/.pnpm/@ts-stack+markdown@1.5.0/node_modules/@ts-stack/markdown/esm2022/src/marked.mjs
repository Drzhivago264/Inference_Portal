/**
 * @license
 *
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 *
 * Copyright (c) 2018-2021, Костя Третяк. (MIT Licensed)
 * https://github.com/ts-stack/markdown
 */
import { BlockLexer } from './block-lexer';
import { MarkedOptions, TokenType } from './interfaces';
import { Parser } from './parser';
export class Marked {
    static options = new MarkedOptions();
    static simpleRenderers = [];
    /**
     * Merges the default options with options that will be set.
     *
     * @param options Hash of options.
     */
    static setOptions(options) {
        Object.assign(this.options, options);
        return this;
    }
    /**
     * Setting simple block rule.
     */
    static setBlockRule(regexp, renderer = () => '') {
        BlockLexer.simpleRules.push(regexp);
        this.simpleRenderers.push(renderer);
        return this;
    }
    /**
     * Accepts Markdown text and returns text in HTML format.
     *
     * @param src String of markdown source to be compiled.
     * @param options Hash of options. They replace, but do not merge with the default options.
     * If you want the merging, you can to do this via `Marked.setOptions()`.
     */
    static parse(src, options) {
        try {
            options = { ...this.options, ...options };
            const { tokens, links } = this.callBlockLexer(src, options);
            return this.callParser(tokens, links, options);
        }
        catch (e) {
            return this.callMe(e);
        }
    }
    /**
     * Accepts Markdown text and returns object with text in HTML format,
     * tokens and links from `BlockLexer.parser()`.
     *
     * @param src String of markdown source to be compiled.
     * @param options Hash of options. They replace, but do not merge with the default options.
     * If you want the merging, you can to do this via `Marked.setOptions()`.
     */
    static debug(src, options = this.options) {
        const { tokens, links } = this.callBlockLexer(src, options);
        let origin = tokens.slice();
        const parser = new Parser(options);
        parser.simpleRenderers = this.simpleRenderers;
        const result = parser.debug(links, tokens);
        /**
         * Translates a token type into a readable form,
         * and moves `line` field to a first place in a token object.
         */
        origin = origin.map((token) => {
            token.type = TokenType[token.type] || token.type;
            const line = token.line;
            delete token.line;
            if (line) {
                return { ...{ line }, ...token };
            }
            else {
                return token;
            }
        });
        return { tokens: origin, links, result };
    }
    static callBlockLexer(src = '', options) {
        if (typeof src != 'string') {
            throw new Error(`Expected that the 'src' parameter would have a 'string' type, got '${typeof src}'`);
        }
        // Preprocessing.
        src = src
            .replace(/\r\n|\r/g, '\n')
            .replace(/\t/g, '    ')
            .replace(/\u00a0/g, ' ')
            .replace(/\u2424/g, '\n')
            .replace(/^ +$/gm, '');
        return BlockLexer.lex(src, options, true);
    }
    static callParser(tokens, links, options) {
        if (this.simpleRenderers.length) {
            const parser = new Parser(options);
            parser.simpleRenderers = this.simpleRenderers;
            return parser.parse(links, tokens);
        }
        else {
            return Parser.parse(tokens, links, options);
        }
    }
    static callMe(err) {
        err.message += '\nPlease report this to https://github.com/ts-stack/markdown';
        if (this.options.silent) {
            return '<p>An error occured:</p><pre>' + this.options.escape(err.message + '', true) + '</pre>';
        }
        throw err;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFya2VkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vcGFja2FnZXMvbWFya2Rvd24vc3JjL21hcmtlZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVILE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFxQyxhQUFhLEVBQXlCLFNBQVMsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUNsSCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBRWxDLE1BQU0sT0FBTyxNQUFNO0lBQ2pCLE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxhQUFhLEVBQUUsQ0FBQztJQUMzQixNQUFNLENBQUMsZUFBZSxHQUFxQixFQUFFLENBQUM7SUFFeEQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBc0I7UUFDdEMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3JDLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFBTSxDQUFDLFlBQVksQ0FBQyxNQUFjLEVBQUUsV0FBMkIsR0FBRyxFQUFFLENBQUMsRUFBRTtRQUNyRSxVQUFVLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNwQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUVwQyxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQVcsRUFBRSxPQUF1QjtRQUMvQyxJQUFJO1lBQ0YsT0FBTyxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsT0FBTyxFQUFFLENBQUM7WUFDMUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxJQUFJ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O1FBQ2hDLEdBQUcsQ0FBQyxPQUFPLElBQUksOERBQThELENBQUM7UUFFOUUsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRTtZQUN2QixPQUFPLCtCQUErQixHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEdBQUcsRUFBRSxFQUFFLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQztTQUNqRztRQUVELE1BQU0sR0FBRyxDQUFDO0lBQ1osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNCwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL21hcmtlZFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxOC0yMDIxLCDQmtC+0YHRgtGPINCi0YDQtdGC0Y/Qui4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90cy1zdGFjay9tYXJrZG93blxuICovXG5cbmltcG9ydCB7IEJsb2NrTGV4ZXIgfSBmcm9tICcuL2Jsb2NrLWxleGVyJztcbmltcG9ydCB7IERlYnVnUmV0dXJucywgTGV4ZXJSZXR1cm5zLCBMaW5rcywgTWFya2VkT3B0aW9ucywgU2ltcGxlUmVuZGVyZXIsIFRva2VuLCBUb2tlblR5cGUgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSAnLi9wYXJzZXInO1xuXG5leHBvcnQgY2xhc3MgTWFya2VkIHtcbiAgc3RhdGljIG9wdGlvbnMgPSBuZXcgTWFya2VkT3B0aW9ucygpO1xuICBwcm90ZWN0ZWQgc3RhdGljIHNpbXBsZVJlbmRlcmVyczogU2ltcGxlUmVuZGVyZXJbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBNZXJnZXMgdGhlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIG9wdGlvbnMgdGhhdCB3aWxsIGJlIHNldC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgSGFzaCBvZiBvcHRpb25zLlxuICAgKi9cbiAgc3RhdGljIHNldE9wdGlvbnMob3B0aW9uczogTWFya2VkT3B0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR0aW5nIHNpbXBsZSBibG9jayBydWxlLlxuICAgKi9cbiAgc3RhdGljIHNldEJsb2NrUnVsZShyZWdleHA6IFJlZ0V4cCwgcmVuZGVyZXI6IFNpbXBsZVJlbmRlcmVyID0gKCkgPT4gJycpIHtcbiAgICBCbG9ja0xleGVyLnNpbXBsZVJ1bGVzLnB1c2gocmVnZXhwKTtcbiAgICB0aGlzLnNpbXBsZVJlbmRlcmVycy5wdXNoKHJlbmRlcmVyKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgTWFya2Rvd24gdGV4dCBhbmQgcmV0dXJucyB0ZXh0IGluIEhUTUwgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0gc3JjIFN0cmluZyBvZiBtYXJrZG93biBzb3VyY2UgdG8gYmUgY29tcGlsZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIEhhc2ggb2Ygb3B0aW9ucy4gVGhleSByZXBsYWNlLCBidXQgZG8gbm90IG1lcmdlIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAgICogSWYgeW91IHdhbnQgdGhlIG1lcmdpbmcsIHlvdSBjYW4gdG8gZG8gdGhpcyB2aWEgYE1hcmtlZC5zZXRPcHRpb25zKClgLlxuICAgKi9cbiAgc3RhdGljIHBhcnNlKHNyYzogc3RyaW5nLCBvcHRpb25zPzogTWFya2VkT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgY29uc3QgeyB0b2tlbnMsIGxpbmtzIH0gPSB0aGlzLmNhbGxCbG9ja0xleGVyKHNyYywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsUGFyc2VyKHRva2VucywgbGlua3MsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxNZShlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyBNYXJrZG93biB0ZXh0IGFuZCByZXR1cm5zIG9iamVjdCB3aXRoIHRleHQgaW4gSFRNTCBmb3JtYXQsXG4gICAqIHRva2VucyBhbmQgbGlua3MgZnJvbSBgQmxvY2tMZXhlci5wYXJzZXIoKWAuXG4gICAqXG4gICAqIEBwYXJhbSBzcmMgU3RyaW5nIG9mIG1hcmtkb3duIHNvdXJjZSB0byBiZSBjb21waWxlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgSGFzaCBvZiBvcHRpb25zLiBUaGV5IHJlcGxhY2UsIGJ1dCBkbyBub3QgbWVyZ2Ugd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICAgKiBJZiB5b3Ugd2FudCB0aGUgbWVyZ2luZywgeW91IGNhbiB0byBkbyB0aGlzIHZpYSBgTWFya2VkLnNldE9wdGlvbnMoKWAuXG4gICAqL1xuICBzdGF0aWMgZGVidWcoc3JjOiBzdHJpbmcsIG9wdGlvbnM6IE1hcmtlZE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMpOiBEZWJ1Z1JldHVybnMge1xuICAgIGNvbnN0IHsgdG9rZW5zLCBsaW5rcyB9ID0gdGhpcy5jYWxsQmxvY2tMZXhlcihzcmMsIG9wdGlvbnMpO1xuICAgIGxldCBvcmlnaW4gPSB0b2tlbnMuc2xpY2UoKTtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgIHBhcnNlci5zaW1wbGVSZW5kZXJlcnMgPSB0aGlzLnNpbXBsZVJlbmRlcmVycztcbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIuZGVidWcobGlua3MsIHRva2Vucyk7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGEgdG9rZW4gdHlwZSBpbnRvIGEgcmVhZGFibGUgZm9ybSxcbiAgICAgKiBhbmQgbW92ZXMgYGxpbmVgIGZpZWxkIHRvIGEgZmlyc3QgcGxhY2UgaW4gYSB0b2tlbiBvYmplY3QuXG4gICAgICovXG4gICAgb3JpZ2luID0gb3JpZ2luLm1hcCgodG9rZW4pID0+IHtcbiAgICAgIHRva2VuLnR5cGUgPSAoVG9rZW5UeXBlIGFzIGFueSlbdG9rZW4udHlwZV0gfHwgdG9rZW4udHlwZTtcblxuICAgICAgY29uc3QgbGluZSA9IHRva2VuLmxpbmU7XG4gICAgICBkZWxldGUgdG9rZW4ubGluZTtcbiAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgIHJldHVybiB7IC4uLnsgbGluZSB9LCAuLi50b2tlbiB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgdG9rZW5zOiBvcmlnaW4sIGxpbmtzLCByZXN1bHQgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzdGF0aWMgY2FsbEJsb2NrTGV4ZXIoc3JjOiBzdHJpbmcgPSAnJywgb3B0aW9ucz86IE1hcmtlZE9wdGlvbnMpOiBMZXhlclJldHVybnMge1xuICAgIGlmICh0eXBlb2Ygc3JjICE9ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHRoYXQgdGhlICdzcmMnIHBhcmFtZXRlciB3b3VsZCBoYXZlIGEgJ3N0cmluZycgdHlwZSwgZ290ICcke3R5cGVvZiBzcmN9J2ApO1xuICAgIH1cblxuICAgIC8vIFByZXByb2Nlc3NpbmcuXG4gICAgc3JjID0gc3JjXG4gICAgICAucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJylcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgJyAgICAnKVxuICAgICAgLnJlcGxhY2UoL1xcdTAwYTAvZywgJyAnKVxuICAgICAgLnJlcGxhY2UoL1xcdTI0MjQvZywgJ1xcbicpXG4gICAgICAucmVwbGFjZSgvXiArJC9nbSwgJycpO1xuXG4gICAgcmV0dXJuIEJsb2NrTGV4ZXIubGV4KHNyYywgb3B0aW9ucywgdHJ1ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RhdGljIGNhbGxQYXJzZXIodG9rZW5zOiBUb2tlbltdLCBsaW5rczogTGlua3MsIG9wdGlvbnM/OiBNYXJrZWRPcHRpb25zKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5zaW1wbGVSZW5kZXJlcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgcGFyc2VyLnNpbXBsZVJlbmRlcmVycyA9IHRoaXMuc2ltcGxlUmVuZGVyZXJzO1xuICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZShsaW5rcywgdG9rZW5zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFBhcnNlci5wYXJzZSh0b2tlbnMsIGxpbmtzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RhdGljIGNhbGxNZShlcnI6IEVycm9yKSB7XG4gICAgZXJyLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vdHMtc3RhY2svbWFya2Rvd24nO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgIHJldHVybiAnPHA+QW4gZXJyb3Igb2NjdXJlZDo8L3A+PHByZT4nICsgdGhpcy5vcHRpb25zLmVzY2FwZShlcnIubWVzc2FnZSArICcnLCB0cnVlKSArICc8L3ByZT4nO1xuICAgIH1cblxuICAgIHRocm93IGVycjtcbiAgfVxufVxuIl19