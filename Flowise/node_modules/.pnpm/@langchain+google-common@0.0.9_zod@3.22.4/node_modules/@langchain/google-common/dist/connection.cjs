"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractGoogleLLMConnection = exports.GoogleAIConnection = exports.GoogleHostConnection = exports.GoogleConnection = void 0;
const env_1 = require("@langchain/core/utils/env");
const zod_to_gemini_parameters_js_1 = require("./utils/zod_to_gemini_parameters.cjs");
class GoogleConnection {
    constructor(caller, client, streaming) {
        Object.defineProperty(this, "caller", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "streaming", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.caller = caller;
        this.client = client;
        this.streaming = streaming ?? false;
    }
    async _clientInfoHeaders() {
        const clientLibraryVersion = await this._clientLibraryVersion();
        return {
            "User-Agent": clientLibraryVersion,
        };
    }
    async _clientLibraryVersion() {
        const env = await (0, env_1.getRuntimeEnvironment)();
        const langchain = env?.library ?? "langchain-js";
        const langchainVersion = env?.libraryVersion ?? "0";
        const moduleName = await this._moduleName();
        let ret = `${langchain}/${langchainVersion}`;
        if (moduleName && moduleName.length) {
            ret = `${ret}-${moduleName}`;
        }
        return ret;
    }
    async _moduleName() {
        return this.constructor.name;
    }
    async _request(data, options) {
        const url = await this.buildUrl();
        const method = this.buildMethod();
        const infoHeaders = (await this._clientInfoHeaders()) ?? {};
        const headers = {
            ...infoHeaders,
        };
        const opts = {
            url,
            method,
            headers,
        };
        if (data && method === "POST") {
            opts.data = data;
        }
        if (this.streaming) {
            opts.responseType = "stream";
        }
        else {
            opts.responseType = "json";
        }
        const callResponse = await this.caller.callWithOptions({ signal: options?.signal }, async () => this.client.request(opts));
        const response = callResponse; // Done for typecast safety, I guess
        return response;
    }
}
exports.GoogleConnection = GoogleConnection;
class GoogleHostConnection extends GoogleConnection {
    constructor(fields, caller, client, streaming) {
        super(caller, client, streaming);
        // This does not default to a value intentionally.
        // Use the "platform" getter if you need this.
        Object.defineProperty(this, "platformType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "endpoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "us-central1-aiplatform.googleapis.com"
        });
        Object.defineProperty(this, "location", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "us-central1"
        });
        Object.defineProperty(this, "apiVersion", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "v1"
        });
        this.caller = caller;
        this.platformType = fields?.platformType;
        this.endpoint = fields?.endpoint ?? this.endpoint;
        this.location = fields?.location ?? this.location;
        this.apiVersion = fields?.apiVersion ?? this.apiVersion;
        this.client = client;
    }
    get platform() {
        return this.platformType ?? this.computedPlatformType;
    }
    get computedPlatformType() {
        return "gcp";
    }
    buildMethod() {
        return "POST";
    }
}
exports.GoogleHostConnection = GoogleHostConnection;
class GoogleAIConnection extends GoogleHostConnection {
    constructor(fields, caller, client, streaming) {
        super(fields, caller, client, streaming);
        Object.defineProperty(this, "model", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "modelName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.modelName = fields?.model ?? fields?.modelName ?? this.model;
        this.model = this.modelName;
    }
    get modelFamily() {
        if (this.model.startsWith("gemini")) {
            return "gemini";
        }
        else {
            return null;
        }
    }
    get computedPlatformType() {
        if (this.client.clientType === "apiKey") {
            return "gai";
        }
        else {
            return "gcp";
        }
    }
    async buildUrlGenerativeLanguage() {
        const method = await this.buildUrlMethod();
        const url = `https://generativelanguage.googleapis.com/${this.apiVersion}/models/${this.model}:${method}`;
        return url;
    }
    async buildUrlVertex() {
        const projectId = await this.client.getProjectId();
        const method = await this.buildUrlMethod();
        const url = `https://${this.endpoint}/${this.apiVersion}/projects/${projectId}/locations/${this.location}/publishers/google/models/${this.model}:${method}`;
        return url;
    }
    async buildUrl() {
        switch (this.platform) {
            case "gai":
                return this.buildUrlGenerativeLanguage();
            default:
                return this.buildUrlVertex();
        }
    }
    async request(input, parameters, options) {
        const data = this.formatData(input, parameters);
        const response = await this._request(data, options);
        return response;
    }
}
exports.GoogleAIConnection = GoogleAIConnection;
class AbstractGoogleLLMConnection extends GoogleAIConnection {
    async buildUrlMethodGemini() {
        // Vertex AI only handles streamedGenerateContent
        return "streamGenerateContent";
    }
    async buildUrlMethod() {
        switch (this.modelFamily) {
            case "gemini":
                return this.buildUrlMethodGemini();
            default:
                throw new Error(`Unknown model family: ${this.modelFamily}`);
        }
    }
    formatGenerationConfig(_input, parameters) {
        return {
            temperature: parameters.temperature,
            topK: parameters.topK,
            topP: parameters.topP,
            maxOutputTokens: parameters.maxOutputTokens,
            stopSequences: parameters.stopSequences,
        };
    }
    formatSafetySettings(_input, parameters) {
        return parameters.safetySettings ?? [];
    }
    // Borrowed from the OpenAI invocation params test
    isStructuredToolArray(tools) {
        return (tools !== undefined &&
            tools.every((tool) => Array.isArray(tool.lc_namespace)));
    }
    structuredToolToFunctionDeclaration(tool) {
        const jsonSchema = (0, zod_to_gemini_parameters_js_1.zodToGeminiParameters)(tool.schema);
        return {
            name: tool.name,
            description: tool.description,
            parameters: jsonSchema,
        };
    }
    structuredToolsToGeminiTools(tools) {
        return [
            {
                functionDeclarations: tools.map(this.structuredToolToFunctionDeclaration),
            },
        ];
    }
    formatTools(_input, parameters) {
        const tools = parameters?.tools;
        if (!tools || tools.length === 0) {
            return [];
        }
        if (this.isStructuredToolArray(tools)) {
            return this.structuredToolsToGeminiTools(tools);
        }
        else {
            return tools;
        }
    }
    formatData(input, parameters) {
        /*
        const parts = messageContentToParts(input);
        const contents: GeminiContent[] = [
          {
            role: "user",    // Required by Vertex AI
            parts,
          }
        ]
        */
        const contents = this.formatContents(input, parameters);
        const generationConfig = this.formatGenerationConfig(input, parameters);
        const tools = this.formatTools(input, parameters);
        const safetySettings = this.formatSafetySettings(input, parameters);
        const ret = {
            contents,
            generationConfig,
        };
        if (tools && tools.length) {
            ret.tools = tools;
        }
        if (safetySettings && safetySettings.length) {
            ret.safetySettings = safetySettings;
        }
        return ret;
    }
}
exports.AbstractGoogleLLMConnection = AbstractGoogleLLMConnection;
