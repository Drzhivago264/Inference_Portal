import { RealtimeTranscriberParams, RealtimeTranscript, PartialTranscript, FinalTranscript, SessionBeginsEventData, AudioData } from "../..";
export declare class RealtimeTranscriber {
    private realtimeUrl;
    private sampleRate;
    private wordBoost?;
    private encoding?;
    private apiKey?;
    private token?;
    private endUtteranceSilenceThreshold?;
    private socket?;
    private listeners;
    private sessionTerminatedResolve?;
    constructor(params: RealtimeTranscriberParams);
    private connectionUrl;
    on(event: "open", listener: (event: SessionBeginsEventData) => void): void;
    on(event: "transcript", listener: (transcript: RealtimeTranscript) => void): void;
    on(event: "transcript.partial", listener: (transcript: PartialTranscript) => void): void;
    on(event: "transcript.final", listener: (transcript: FinalTranscript) => void): void;
    on(event: "error", listener: (error: Error) => void): void;
    on(event: "close", listener: (code: number, reason: string) => void): void;
    connect(): Promise<SessionBeginsEventData>;
    sendAudio(audio: AudioData): void;
    stream(): WritableStream<AudioData>;
    /**
     * Manually end an utterance
     */
    forceEndUtterance(): void;
    /**
     * Configure the threshold for how long to wait before ending an utterance. Default is 700ms.
     * @param threshold - The duration of the end utterance silence threshold in milliseconds.
     * This value must be an integer between 0 and 20_000.
     */
    configureEndUtteranceSilenceThreshold(threshold: number): void;
    private send;
    close(waitForSessionTermination?: boolean): Promise<void>;
}
/**
 * @deprecated Use RealtimeTranscriber instead
 */
export declare class RealtimeService extends RealtimeTranscriber {
}
