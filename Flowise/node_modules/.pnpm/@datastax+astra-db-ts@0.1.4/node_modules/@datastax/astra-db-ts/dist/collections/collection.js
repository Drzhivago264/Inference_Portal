"use strict";
// Copyright DataStax, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AstraTsClientError = exports.Collection = void 0;
const cursor_1 = require("./cursor");
const client_1 = require("../client");
const utils_1 = require("./utils");
const options_1 = require("./options");
class Collection {
    constructor(httpClient, name) {
        if (!name) {
            throw new Error("Collection name is required");
        }
        // use a clone of the underlying http client to support multiple collections from a single db
        this.httpClient = new client_1.HTTPClient({
            baseUrl: httpClient.baseUrl + `/${name}`,
            username: httpClient.username,
            password: httpClient.password,
            authUrl: httpClient.authUrl,
            applicationToken: httpClient.applicationToken,
            authHeaderName: httpClient.authHeaderName,
            isAstra: httpClient.isAstra,
            logSkippedOptions: httpClient.logSkippedOptions,
        });
        this.name = name;
        this.collectionName = name;
    }
    async insertOne(document) {
        return (0, utils_1.executeOperation)(async () => {
            const command = {
                insertOne: {
                    document,
                },
            };
            const resp = await this.httpClient.executeCommand(command, null);
            return {
                acknowledged: true,
                insertedId: resp.status.insertedIds[0],
            };
        });
    }
    async insertMany(documents, options) {
        return (0, utils_1.executeOperation)(async () => {
            const command = {
                insertMany: {
                    documents,
                    options,
                },
            };
            const resp = await this.httpClient.executeCommand(command, options_1.insertManyInternalOptionsKeys);
            return {
                acknowledged: true,
                insertedCount: resp.status.insertedIds?.length || 0,
                insertedIds: resp.status.insertedIds,
            };
        });
    }
    async updateOne(filter, update, options) {
        return (0, utils_1.executeOperation)(async () => {
            const command = {
                updateOne: {
                    filter,
                    update,
                    options,
                },
            };
            if (options?.sort != null) {
                command.updateOne.sort = options?.sort;
            }
            (0, utils_1.setDefaultIdForUpsert)(command.updateOne);
            const updateOneResp = await this.httpClient.executeCommand(command, options_1.updateOneInternalOptionsKeys);
            const resp = {
                modifiedCount: updateOneResp.status.modifiedCount,
                matchedCount: updateOneResp.status.matchedCount,
                acknowledged: true,
            };
            if (updateOneResp.status.upsertedId) {
                resp.upsertedId = updateOneResp.status.upsertedId;
                resp.upsertedCount = 1;
            }
            return resp;
        });
    }
    async updateMany(filter, update, options) {
        return (0, utils_1.executeOperation)(async () => {
            const command = {
                updateMany: {
                    filter,
                    update,
                    options,
                },
            };
            (0, utils_1.setDefaultIdForUpsert)(command.updateMany);
            const updateManyResp = await this.httpClient.executeCommand(command, options_1.updateManyInternalOptionsKeys);
            if (updateManyResp.status.moreData) {
                throw new AstraTsClientError(`More than ${updateManyResp.status.modifiedCount} records found for update by the server`, command);
            }
            const resp = {
                modifiedCount: updateManyResp.status.modifiedCount,
                matchedCount: updateManyResp.status.matchedCount,
                acknowledged: true,
            };
            if (updateManyResp.status.upsertedId) {
                resp.upsertedId = updateManyResp.status.upsertedId;
                resp.upsertedCount = 1;
            }
            return resp;
        });
    }
    async deleteOne(filter, options) {
        return (0, utils_1.executeOperation)(async () => {
            const command = {
                deleteOne: {
                    filter,
                },
            };
            if (options?.sort) {
                command.deleteOne.sort = options.sort;
            }
            const deleteOneResp = await this.httpClient.executeCommand(command, null);
            return {
                acknowledged: true,
                deletedCount: deleteOneResp.status.deletedCount,
            };
        });
    }
    async deleteMany(filter) {
        return (0, utils_1.executeOperation)(async () => {
            const command = {
                deleteMany: {
                    filter,
                },
            };
            const deleteManyResp = await this.httpClient.executeCommand(command, null);
            if (deleteManyResp.status.moreData) {
                throw new AstraTsClientError(`More records found to be deleted even after deleting ${deleteManyResp.status.deletedCount} records`, command);
            }
            return {
                acknowledged: true,
                deletedCount: deleteManyResp.status.deletedCount,
            };
        });
    }
    find(filter, options) {
        return new cursor_1.FindCursor(this, filter, options);
    }
    async findOne(filter, options) {
        return (0, utils_1.executeOperation)(async () => {
            const command = {
                findOne: {
                    filter,
                    options,
                },
            };
            if (options?.sort) {
                command.findOne.sort = options.sort;
                delete options.sort;
            }
            if (options?.projection && Object.keys(options.projection).length > 0) {
                command.findOne.projection = options.projection;
            }
            const resp = await this.httpClient.executeCommand(command, options_1.findOneInternalOptionsKeys);
            return resp.data.document;
        });
    }
    async findOneAndReplace(filter, replacement, options) {
        return (0, utils_1.executeOperation)(async () => {
            const command = {
                findOneAndReplace: {
                    filter,
                    replacement,
                    options,
                },
            };
            (0, utils_1.setDefaultIdForUpsert)(command.findOneAndReplace, true);
            if (options?.sort) {
                command.findOneAndReplace.sort = options.sort;
                if (options.sort != null) {
                    delete options.sort;
                }
            }
            const resp = await this.httpClient.executeCommand(command, options_1.findOneAndReplaceInternalOptionsKeys);
            return {
                value: resp.data?.document,
                ok: 1,
            };
        });
    }
    async distinct(_key, _filter, _options) {
        throw new Error("Not Implemented");
    }
    async countDocuments(filter) {
        return (0, utils_1.executeOperation)(async () => {
            const command = {
                countDocuments: {
                    filter,
                },
            };
            const resp = await this.httpClient.executeCommand(command, null);
            return resp.status.count;
        });
    }
    async findOneAndDelete(filter, options) {
        const command = {
            findOneAndDelete: {
                filter,
            },
        };
        if (options?.sort) {
            command.findOneAndDelete.sort = options.sort;
        }
        const resp = await this.httpClient.executeCommand(command, null);
        return {
            value: resp.data?.document,
            ok: 1,
        };
    }
    /**
     * @deprecated
     */
    async count(filter) {
        return this.countDocuments(filter);
    }
    async findOneAndUpdate(filter, update, options) {
        return (0, utils_1.executeOperation)(async () => {
            const command = {
                findOneAndUpdate: {
                    filter,
                    update,
                    options,
                },
            };
            (0, utils_1.setDefaultIdForUpsert)(command.findOneAndUpdate);
            if (options?.sort) {
                command.findOneAndUpdate.sort = options.sort;
                delete options.sort;
            }
            const resp = await this.httpClient.executeCommand(command, options_1.findOneAndUpdateInternalOptionsKeys);
            return {
                value: resp.data?.document,
                ok: 1,
            };
        });
    }
}
exports.Collection = Collection;
class AstraTsClientError extends Error {
    constructor(message, command) {
        const commandName = Object.keys(command)[0] || "unknown";
        super(`Command "${commandName}" failed with the following error: ${message}`);
        this.command = command;
    }
}
exports.AstraTsClientError = AstraTsClientError;
//# sourceMappingURL=collection.js.map