"use strict";
// Copyright DataStax, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AstraDB = exports.Client = void 0;
const db_1 = require("./db");
const utils_1 = require("./utils");
const client_1 = require("../client");
const logger_1 = require("../logger");
const collection_1 = require("./collection");
class Client {
    constructor(baseUrl, keyspaceName, options) {
        this.keyspaceName = keyspaceName;
        this.createNamespaceOnConnect = options?.createNamespaceOnConnect ?? true;
        //If the client is connecting to Astra, we don't want to create the namespace
        if (options?.isAstra) {
            this.createNamespaceOnConnect = false;
        }
        this.httpClient = new client_1.HTTPClient({
            baseApiPath: options.baseApiPath,
            baseUrl: baseUrl,
            applicationToken: options.applicationToken,
            logLevel: options.logLevel,
            authHeaderName: options.authHeaderName,
            username: options.username,
            password: options.password,
            authUrl: options.authUrl,
            isAstra: options.isAstra,
            logSkippedOptions: options.logSkippedOptions,
        });
    }
    /**
     * Setup a connection to the Astra/Stargate JSON API
     * @param uri an Stargate JSON API uri (Eg. http://localhost:8181/v1/testks1) where testks1 is the name of the keyspace/Namespace which should always be the last part of the URL
     * @returns Client
     */
    static async connect(uri, options) {
        const parsedUri = (0, utils_1.parseUri)(uri);
        const client = new Client(parsedUri.baseUrl, parsedUri.keyspaceName, {
            applicationToken: options?.applicationToken
                ? options?.applicationToken
                : parsedUri.applicationToken,
            baseApiPath: options?.baseApiPath
                ? options?.baseApiPath
                : parsedUri.baseApiPath,
            logLevel: options?.logLevel,
            authHeaderName: options?.authHeaderName,
            createNamespaceOnConnect: options?.createNamespaceOnConnect,
            username: options?.username,
            password: options?.password,
            authUrl: options?.authUrl,
            isAstra: options?.isAstra,
            logSkippedOptions: options?.logSkippedOptions,
        });
        await client.connect();
        return client;
    }
    async collection(name) {
        return new collection_1.Collection(this.httpClient, name);
    }
    async createCollection(collectionName, options) {
        return await this.db().createCollection(collectionName, options);
    }
    async dropCollection(collectionName) {
        return await this.db().dropCollection(collectionName);
    }
    /**
     * Connect the Client instance to JSON API (create Namespace automatically when the 'createNamespaceOnConnect' flag is set to true)
     * @returns a Client instance
     */
    async connect() {
        if (this.createNamespaceOnConnect && this.keyspaceName) {
            logger_1.logger.debug("Creating Namespace " + this.keyspaceName);
            await (0, utils_1.createNamespace)(this.httpClient, this.keyspaceName);
        }
        else {
            logger_1.logger.debug("Not creating Namespace on connection!");
        }
        return this;
    }
    /**
     * Use a JSON API keyspace
     * @param dbName the JSON API keyspace to connect to
     * @returns Db
     */
    db(dbName) {
        if (dbName) {
            return new db_1.Db(this.httpClient, dbName);
        }
        if (this.keyspaceName) {
            return new db_1.Db(this.httpClient, this.keyspaceName);
        }
        throw new Error("Database name must be provided");
    }
    /**
     *
     * @param maxListeners
     * @returns number
     */
    setMaxListeners(maxListeners) {
        return maxListeners;
    }
    /**
     *
     * @returns Client
     */
    close() {
        return this;
    }
    startSession() {
        throw new Error("startSession() Not Implemented");
    }
}
exports.Client = Client;
const DEFAULT_KEYSPACE = "default_keyspace";
class AstraDB extends Client {
    constructor(...args) {
        // token: string, API EndPoint: string, keyspace?: string
        const keyspaceName = args[2] || DEFAULT_KEYSPACE;
        const endpoint = (0, utils_1.createAstraUri)(args[1], keyspaceName);
        super(endpoint, keyspaceName, { isAstra: true, applicationToken: args[0] });
    }
}
exports.AstraDB = AstraDB;
//# sourceMappingURL=client.js.map