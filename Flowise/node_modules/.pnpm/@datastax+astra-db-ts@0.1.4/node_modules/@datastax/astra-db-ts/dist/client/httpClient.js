"use strict";
// Copyright DataStax, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleIfErrorResponse = exports.StargateServerError = exports.HTTPClient = exports.AUTH_API_PATH = void 0;
const http_1 = __importDefault(require("http"));
const axios_1 = __importDefault(require("axios"));
const logger_1 = require("../logger");
const util_1 = require("util");
const version_1 = require("../version");
const utils_1 = require("../collections/utils");
const bson_1 = require("bson");
const REQUESTED_WITH = version_1.LIB_NAME + "/" + version_1.LIB_VERSION;
const DEFAULT_AUTH_HEADER = "Token";
const DEFAULT_METHOD = "get";
const DEFAULT_TIMEOUT = 30000;
exports.AUTH_API_PATH = "/v1/auth";
const HTTP_METHODS = {
    get: "GET",
    post: "POST",
    put: "PUT",
    patch: "PATCH",
    delete: "DELETE",
};
const axiosAgent = axios_1.default.create({
    headers: {
        Accepts: "application/json",
        "Content-Type": "application/json",
        "User-Agent": `${REQUESTED_WITH} ${axios_1.default.defaults.headers.common["User-Agent"]}`,
        "X-Requested-With": REQUESTED_WITH,
    },
    // keepAlive pools and reuses TCP connections
    httpAgent: new http_1.default.Agent({
        keepAlive: true,
    }),
    timeout: DEFAULT_TIMEOUT,
});
// InternalAxiosRequestConfig because of https://github.com/axios/axios/issues/5494#issuecomment-1402663237
const requestInterceptor = (config) => {
    const { method, url } = config;
    if (logger_1.logger.isLevelEnabled("http")) {
        logger_1.logger.http(`--- request ${method?.toUpperCase()} ${url} ${serializeCommand(config.data, true)}`);
    }
    config.data = serializeCommand(config.data);
    return config;
};
const responseInterceptor = (response) => {
    if (logger_1.logger.isLevelEnabled("http")) {
        logger_1.logger.http(`--- response ${response.status} ${response.config.method?.toUpperCase()} ${response.config.url} ${JSON.stringify(response.data, null, 2)}`);
    }
    return response;
};
axiosAgent.interceptors.request.use(requestInterceptor);
axiosAgent.interceptors.response.use(responseInterceptor);
class HTTPClient {
    constructor(options) {
        // do not support usage in browsers
        if (typeof window !== "undefined") {
            throw new Error("not for use in a web browser");
        }
        // set the baseURL to Astra, if the user provides a JSON API URL, use that instead.
        if (options.baseUrl) {
            this.baseUrl = options.baseUrl;
        }
        else {
            throw new Error("baseUrl required for initialization");
        }
        this.username = options.username || "";
        this.password = options.password || "";
        this.authUrl = options.authUrl || this.baseUrl + exports.AUTH_API_PATH;
        if (options.applicationToken) {
            this.applicationToken = options.applicationToken;
        }
        else {
            if (this.username === "" || this.password === "") {
                throw new Error("applicationToken/auth info required for initialization");
            }
            this.applicationToken = ""; //We will set this by accessing the auth url when the first request is received
        }
        if (options.logLevel) {
            (0, logger_1.setLevel)(options.logLevel);
        }
        if (options.baseApiPath) {
            this.baseUrl = this.baseUrl + "/" + options.baseApiPath;
        }
        this.authHeaderName = options.authHeaderName || DEFAULT_AUTH_HEADER;
        this.isAstra = options.isAstra || false;
        this.logSkippedOptions = options.logSkippedOptions || false;
    }
    async _request(requestInfo) {
        try {
            if (this.applicationToken === "") {
                logger_1.logger.debug("@datastax/astra-db-ts/rest: getting token");
                try {
                    this.applicationToken = await (0, utils_1.getStargateAccessToken)(this.authUrl, this.username, this.password);
                }
                catch (authError) {
                    return {
                        errors: [
                            {
                                message: authError.message
                                    ? authError.message
                                    : "Authentication failed, please retry!",
                            },
                        ],
                    };
                }
            }
            if (!this.applicationToken) {
                return {
                    errors: [
                        {
                            message: "Unable to get token for the credentials provided",
                        },
                    ],
                };
            }
            const response = await axiosAgent({
                url: requestInfo.url,
                data: requestInfo.data,
                params: requestInfo.params,
                method: requestInfo.method || DEFAULT_METHOD,
                timeout: requestInfo.timeout || DEFAULT_TIMEOUT,
                headers: {
                    [this.authHeaderName]: this.applicationToken,
                },
            });
            if (response.status === 401 ||
                (response.data?.errors?.length > 0 &&
                    response.data.errors[0]?.message === "UNAUTHENTICATED: Invalid token")) {
                logger_1.logger.debug("@datastax/astra-db-ts/rest: reconnecting");
                try {
                    this.applicationToken = await (0, utils_1.getStargateAccessToken)(this.authUrl, this.username, this.password);
                }
                catch (authError) {
                    return {
                        errors: [
                            {
                                message: authError.message
                                    ? authError.message
                                    : "Authentication failed, please retry!",
                            },
                        ],
                    };
                }
                return this._request(requestInfo);
            }
            if (response.status === 200) {
                return {
                    status: response.data.status,
                    data: deserialize(response.data.data),
                    errors: response.data.errors,
                };
            }
            else {
                logger_1.logger.error(requestInfo.url + ": " + response.status);
                logger_1.logger.error("Data: " + (0, util_1.inspect)(requestInfo.data));
                return {
                    errors: [
                        {
                            message: "Server response received : " + response.status + "!",
                        },
                    ],
                };
            }
        }
        catch (e) {
            logger_1.logger.error(requestInfo.url + ": " + e.message);
            logger_1.logger.error("Data: " + (0, util_1.inspect)(requestInfo.data));
            if (e?.response?.data) {
                logger_1.logger.error("Response Data: " + (0, util_1.inspect)(e.response.data));
            }
            return {
                errors: [
                    {
                        message: e.message
                            ? e.message
                            : "Server call failed, please retry!",
                    },
                ],
            };
        }
    }
    async executeCommand(data, optionsToRetain) {
        const commandName = Object.keys(data)[0];
        cleanupOptions(commandName, data[commandName], optionsToRetain, this.logSkippedOptions);
        const response = await this._request({
            url: this.baseUrl,
            method: HTTP_METHODS.post,
            data,
        });
        (0, exports.handleIfErrorResponse)(response, data);
        return response;
    }
}
exports.HTTPClient = HTTPClient;
class StargateServerError extends Error {
    constructor(response, command) {
        const commandName = Object.keys(command)[0] || "unknown";
        const status = response.status
            ? `, Status : ${JSON.stringify(response.status)}`
            : "";
        super(`Command "${commandName}" failed with the following errors: ${JSON.stringify(response.errors)}${status}`);
        this.errors = response.errors;
        this.command = command;
        this.status = response.status;
    }
}
exports.StargateServerError = StargateServerError;
const handleIfErrorResponse = (response, data) => {
    if (response.errors && response.errors.length > 0) {
        throw new StargateServerError(response, data);
    }
};
exports.handleIfErrorResponse = handleIfErrorResponse;
function serializeCommand(data, pretty) {
    return bson_1.EJSON.stringify(data, (key, value) => handleValues(key, value), pretty ? "  " : "");
}
function deserialize(data) {
    return data != null ? bson_1.EJSON.deserialize(data) : data;
}
function handleValues(key, value) {
    if (value != null && typeof value === "bigint") {
        //BigInt handling
        return Number(value);
    }
    else if (value != null && typeof value === "object") {
        // ObjectId to strings
        if (value.$oid) {
            return value.$oid;
        }
        else if (value.$numberDecimal) {
            //Decimal128 handling
            return Number(value.$numberDecimal);
        }
        else if (value.$binary &&
            (value.$binary.subType === "03" || value.$binary.subType === "04")) {
            //UUID handling. Subtype 03 or 04 is UUID. Refer spec : https://bsonspec.org/spec.html
            return Buffer.from(value.$binary.base64, "base64")
                .toString("hex")
                .replace(/(.{8})(.{4})(.{4})(.{4})(.{12})/, "$1-$2-$3-$4-$5");
        }
        //Date handling
        else if (value.$date) {
            // Use numbers instead of strings for dates
            value.$date = new Date(value.$date).valueOf();
        }
    }
    //all other values
    return value;
}
function cleanupOptions(commandName, command, optionsToRetain, logSkippedOptions) {
    if (command.options) {
        Object.keys(command.options).forEach((key) => {
            if (optionsToRetain === null || !optionsToRetain.has(key)) {
                if (logSkippedOptions) {
                    logger_1.logger.warn(`'${commandName}' does not support option '${key}'`);
                }
                delete command.options[key];
            }
        });
    }
}
//# sourceMappingURL=httpClient.js.map