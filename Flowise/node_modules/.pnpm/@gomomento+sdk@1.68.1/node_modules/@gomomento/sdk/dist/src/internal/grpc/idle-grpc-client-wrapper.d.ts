import { CloseableGrpcClient, GrpcClientWrapper } from './grpc-client-wrapper';
import { MomentoLoggerFactory } from '@gomomento/sdk-core';
export interface IdleGrpcClientWrapperProps<T extends CloseableGrpcClient> {
    clientFactoryFn: () => T;
    loggerFactory: MomentoLoggerFactory;
    maxIdleMillis: number;
    maxClientAgeMillis?: number;
}
/**
 * This wrapper allows us to ensure that a grpc client is not re-used if it has been idle
 * for longer than a specified period of time.  This is important in some environments,
 * such as AWS Lambda, where the runtime may be paused indefinitely between invocations.
 * In such cases we have observed that while the runtime is suspended, the connection
 * may have been closed by the server. (e.g., AWS NLB has an idle timeout of 350s:
 * https://docs.aws.amazon.com/elasticloadbalancing/latest/network/network-load-balancers.html#connection-idle-timeout )
 * When the runtime resumes, it does not recognize that the connection has been closed,
 * and it may continue to attempt to send bytes to it, resulting in client-side timeouts
 * (DEADLINE_EXCEEDED).  Forcefully refreshing the client if it has been idle for too
 * long will prevent this.
 *
 * NOTE: We can't rely on keepalive pings in this scenario, because the lambda runtime
 * may be suspended in such a way that background tasks such as the keepalive pings
 * will not be able to execute.
 */
export declare class IdleGrpcClientWrapper<T extends CloseableGrpcClient> implements GrpcClientWrapper<T> {
    private readonly logger;
    private client;
    private readonly clientFactoryFn;
    private readonly maxIdleMillis;
    private lastAccessTime;
    private clientCreatedTime;
    private readonly maxClientAgeMillis?;
    constructor(props: IdleGrpcClientWrapperProps<T>);
    getClient(): T;
}
