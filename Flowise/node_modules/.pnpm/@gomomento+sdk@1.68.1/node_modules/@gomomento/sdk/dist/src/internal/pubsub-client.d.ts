import { CacheServiceErrorMapper } from '../errors/cache-service-error-mapper';
import { ServiceError } from '@grpc/grpc-js';
import { CredentialProvider, MomentoLogger, TopicPublish, TopicSubscribe } from '../';
import { AbstractPubsubClient, SendSubscribeOptions } from '@gomomento/sdk-core/dist/src/internal/clients/pubsub/AbstractPubsubClient';
import { TopicClientPropsWithConfiguration } from './topic-client-props-with-config';
export declare class PubsubClient extends AbstractPubsubClient<ServiceError> {
    private readonly client;
    private readonly configuration;
    protected readonly credentialProvider: CredentialProvider;
    private readonly unaryRequestTimeoutMs;
    private static readonly DEFAULT_REQUEST_TIMEOUT_MS;
    private static readonly DEFAULT_MAX_SESSION_MEMORY_MB;
    protected readonly logger: MomentoLogger;
    protected readonly cacheServiceErrorMapper: CacheServiceErrorMapper;
    private readonly unaryInterceptors;
    private readonly streamingInterceptors;
    private static readonly RST_STREAM_NO_ERROR_MESSAGE;
    /**
     * @param {TopicClientProps} props
     */
    constructor(props: TopicClientPropsWithConfiguration);
    getEndpoint(): string;
    protected sendPublish(cacheName: string, topicName: string, value: string | Uint8Array): Promise<TopicPublish.Response>;
    /**
     * @remark This method is responsible for restarting the stream if it ends unexpectedly.
     * Since we return a single subscription object to the user, we need to update it with the
     * unsubscribe function should we restart the stream. This is why we pass the subscription
     * state and subscription object to this method.
     *
     * Handling a cache not exists requires special care as well. In the most likely case,
     * when the subscription starts and the cache does not exist, we receive an error immediately.
     * We return an error from the subscribe method and do immediately unsubscribe. In a distinct,
     * unlikely but possible case, the user deletes the cache while the stream is running. In this
     * case we already returned a subscription object to the user, so we instead cancel the stream and
     * propagate an error to the user via the error handler.
     */
    protected sendSubscribe(options: SendSubscribeOptions): Promise<TopicSubscribe.Response>;
    private prepareDataCallback;
    private prepareErrorCallback;
    private static initializeUnaryInterceptors;
    private static initializeStreamingInterceptors;
}
