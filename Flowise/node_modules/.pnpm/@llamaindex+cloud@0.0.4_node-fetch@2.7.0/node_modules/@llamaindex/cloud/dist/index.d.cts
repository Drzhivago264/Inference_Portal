import { A as ApiKey$1, a as ApiKeyCreate, b as ApiKeyUpdate, D as DataSinkCreate, c as DataSink$1, d as DataSinkUpdate, e as DataSourceCreate, f as DataSource$1, B as BodyUpsertDataSourceFromFilesApiDataSourceFileUploadPut, g as DataSourceUpdate, L as LoadedFile, h as LoadedFilePayload, i as DataSourceLoadJobRecord, j as ListProjectsApiProjectGetRequest, P as Project$1, k as ProjectCreate, l as ProjectUpdate, m as PipelineCreate, n as Pipeline$1, E as EvalDataset, o as EvalDatasetCreate, S as SearchPipelinesApiPipelineGetRequest, G as GetPipelineForProjectApiPipelinePipelineIdGetRequest, p as PipelineUpdate, q as DeployPlaygroundPipelineApiPipelinePipelineIdDeployPostRequest, C as CreatePlaygroundPipelineApiPipelinePipelineIdPlaygroundPostRequest, r as PlaygroundJobRecord, s as CreatePlaygroundJobApiPipelinePipelineIdPlaygroundJobPostRequest, t as GetPlaygroundJobResultApiPipelinePipelineIdPlaygroundJobResultGetRequest, u as PlatformTextNode, v as EvalDatasetJobRecord, w as EvalExecutionCreate, x as EvalQuestionResult, y as BodyRunManagedRawFilesIngestionApiPipelinePipelineIdManagedIngestRawFilesPut, z as DataSourceManagedIngestionJobRecord, F as PipelineManagedIngestionJobRecord, R as RetrievalParams, H as RetrieveResults, I as EvalDatasetUpdate, J as EvalQuestion, K as EvalQuestionCreate, M as SupportedEvalLlmModel, N as ParsingJob, O as ParsingUsage, Q as ParsingJobMarkdownResult, T as ConfigurableTransformationDefinition, U as DataSourceDefinition, V as DataSinkDefinition } from './index-DSqeK0Bu.cjs';
export { W as PlatformApi, X as PlatformApiError } from './index-DSqeK0Bu.cjs';
import * as fs from 'fs';

/**
 * This file was auto-generated by Fern from our API Definition.
 */
declare class PlatformApiTimeoutError extends Error {
    constructor();
}

type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);
declare const Supplier: {
    get: <T>(supplier: Supplier<T>) => Promise<T>;
};

type BearerToken = string;
declare const BearerToken: {
    toAuthorizationHeader: (token: BearerToken | undefined) => string | undefined;
    fromAuthorizationHeader: (header: string) => BearerToken;
};

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Health {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class Health {
    protected readonly _options: Health.Options;
    constructor(_options: Health.Options);
    /**
     * Health check endpoint.
     *
     * @example
     *     await platformApi.health.health()
     */
    health(requestOptions?: Health.RequestOptions): Promise<Record<string, string>>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace ApiKey {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class ApiKey {
    protected readonly _options: ApiKey.Options;
    constructor(_options: ApiKey.Options);
    /**
     * Get all API Keys for a user.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.apiKey.getKeys()
     */
    getKeys(requestOptions?: ApiKey.RequestOptions): Promise<ApiKey$1[]>;
    /**
     * Generate a new API Key.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    generateKey(request?: ApiKeyCreate, requestOptions?: ApiKey.RequestOptions): Promise<ApiKey$1>;
    /**
     * Update name of an existing API Key.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    updateExistingApiKey(apiKeyId: string, request?: ApiKeyUpdate, requestOptions?: ApiKey.RequestOptions): Promise<ApiKey$1>;
    /**
     * Delete an API Key by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.apiKey.deleteApiKey("api-key-id")
     */
    deleteApiKey(apiKeyId: string, requestOptions?: ApiKey.RequestOptions): Promise<void>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace DataSink {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class DataSink {
    protected readonly _options: DataSink.Options;
    constructor(_options: DataSink.Options);
    /**
     * Create a new data sink.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    createDataSink(request: DataSinkCreate, requestOptions?: DataSink.RequestOptions): Promise<DataSink$1>;
    /**
     * Upserts a data sink.
     * Updates if a data sink with the same name and user_id already exists. Otherwise, creates a new data sink.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    upsertDataSink(request: DataSinkCreate, requestOptions?: DataSink.RequestOptions): Promise<DataSink$1>;
    /**
     * Get a data sink by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    getDataSink(dataSinkId: string, requestOptions?: DataSink.RequestOptions): Promise<DataSink$1>;
    /**
     * Update a data sink by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    updateDataSink(dataSinkId: string, request: DataSinkUpdate, requestOptions?: DataSink.RequestOptions): Promise<DataSink$1>;
    /**
     * Delete a data sink by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSink.deleteDataSink("data-sink-id")
     */
    deleteDataSink(dataSinkId: string, requestOptions?: DataSink.RequestOptions): Promise<void>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace DataSource {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class DataSource {
    protected readonly _options: DataSource.Options;
    constructor(_options: DataSource.Options);
    /**
     * Create a new data source.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    createDataSource(request: DataSourceCreate, requestOptions?: DataSource.RequestOptions): Promise<DataSource$1>;
    /**
     * Upserts a data source.
     * Updates if a data source with the same name and user_id already exists.Otherwise, creates a new data source.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    upsertDataSource(request: DataSourceCreate, requestOptions?: DataSource.RequestOptions): Promise<DataSource$1>;
    /**
     * Upserts a data source.
     * Updates if a data source with the same name and user_id already exists.Otherwise, creates a new data source.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    upsertDataSourceFromFiles(request: BodyUpsertDataSourceFromFilesApiDataSourceFileUploadPut, requestOptions?: DataSource.RequestOptions): Promise<DataSource$1[]>;
    /**
     * Get a data source by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    getDataSource(dataSourceId: string, requestOptions?: DataSource.RequestOptions): Promise<DataSource$1>;
    /**
     * Update a data source by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    updateDataSource(dataSourceId: string, request: DataSourceUpdate, requestOptions?: DataSource.RequestOptions): Promise<DataSource$1>;
    /**
     * Delete a data source by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSource.deleteDataSource("data-source-id")
     */
    deleteDataSource(dataSourceId: string, requestOptions?: DataSource.RequestOptions): Promise<void>;
    /**
     * Get loaded files for a data source by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSource.getDataSourceFiles("data-source-id")
     */
    getDataSourceFiles(dataSourceId: string, requestOptions?: DataSource.RequestOptions): Promise<LoadedFile[]>;
    /**
     * Get loaded files for a data source by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    getDataSourceFileContent(dataSourceId: string, loadedFileId: string, requestOptions?: DataSource.RequestOptions): Promise<LoadedFilePayload>;
    /**
     * Get all data source executions for a given data source.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSource.getDataSourceExecutions("data-source-id")
     */
    getDataSourceExecutions(dataSourceId: string, requestOptions?: DataSource.RequestOptions): Promise<DataSourceLoadJobRecord[]>;
    /**
     * Create a new data source execution.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSource.createDataSourceExecution("data-source-id")
     */
    createDataSourceExecution(dataSourceId: string, requestOptions?: DataSource.RequestOptions): Promise<DataSourceLoadJobRecord>;
    /**
     * Get a data source execution by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.dataSource.getDataSourceExecution("data-source-id", "data-source-load-execution-id")
     */
    getDataSourceExecution(dataSourceId: string, dataSourceLoadExecutionId: string, requestOptions?: DataSource.RequestOptions): Promise<DataSourceLoadJobRecord>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Project {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class Project {
    protected readonly _options: Project.Options;
    constructor(_options: Project.Options);
    /**
     * List projects or get one by name
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.listProjects({})
     */
    listProjects(request?: ListProjectsApiProjectGetRequest, requestOptions?: Project.RequestOptions): Promise<Project$1[]>;
    /**
     * Create a new project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    createProject(request: ProjectCreate, requestOptions?: Project.RequestOptions): Promise<Project$1>;
    /**
     * Upsert a project.
     * Updates if a project with the same name already exists. Otherwise, creates a new project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    upsertProject(request: ProjectCreate, requestOptions?: Project.RequestOptions): Promise<Project$1>;
    /**
     * Get a project by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    getProject(projectId: string, requestOptions?: Project.RequestOptions): Promise<Project$1>;
    /**
     * Update an existing project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    updateExistingProject(projectId: string, request: ProjectUpdate, requestOptions?: Project.RequestOptions): Promise<Project$1>;
    /**
     * Create a new pipeline for a project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    createPipelineForProject(projectId: string, request: PipelineCreate, requestOptions?: Project.RequestOptions): Promise<Pipeline$1>;
    /**
     * Upsert a pipeline for a project.
     * Updates if a pipeline with the same name and project_id already exists. Otherwise, creates a new pipeline.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    upsertPipelineForProject(projectId: string, request: PipelineCreate, requestOptions?: Project.RequestOptions): Promise<Pipeline$1>;
    /**
     * Get all eval datasets for a project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.project.getDatasetsForProject("project-id")
     */
    getDatasetsForProject(projectId: string, requestOptions?: Project.RequestOptions): Promise<EvalDataset[]>;
    /**
     * Create a new eval dataset for a project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    createEvalDatasetForProject(projectId: string, request: EvalDatasetCreate, requestOptions?: Project.RequestOptions): Promise<EvalDataset>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Pipeline {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class Pipeline {
    protected readonly _options: Pipeline.Options;
    constructor(_options: Pipeline.Options);
    /**
     * Search for pipelines by various parameters.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.searchPipelines({
     *         projectName: "project-name",
     *         pipelineType: PlatformApi.PipelineType.Playground
     *     })
     */
    searchPipelines(request: SearchPipelinesApiPipelineGetRequest, requestOptions?: Pipeline.RequestOptions): Promise<Pipeline$1[]>;
    /**
     * Get a pipeline by ID for a given project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    getPipelineForProject(pipelineId: string, request?: GetPipelineForProjectApiPipelinePipelineIdGetRequest, requestOptions?: Pipeline.RequestOptions): Promise<Pipeline$1>;
    /**
     * Update an existing pipeline for a project.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    updateExistingPipeline(pipelineId: string, request?: PipelineUpdate, requestOptions?: Pipeline.RequestOptions): Promise<Pipeline$1>;
    /**
     * Delete a pipeline by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.deletePipeline("pipeline-id")
     */
    deletePipeline(pipelineId: string, requestOptions?: Pipeline.RequestOptions): Promise<void>;
    /**
     * Get loaded files for a pipeline by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getLoadedFilesForPipeline("pipeline-id")
     */
    getLoadedFilesForPipeline(pipelineId: string, requestOptions?: Pipeline.RequestOptions): Promise<LoadedFile[]>;
    /**
     * Deploy a playground pipeline to a managed pipeline.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    deployPlaygroundPipeline(pipelineId: string, request?: DeployPlaygroundPipelineApiPipelinePipelineIdDeployPostRequest, requestOptions?: Pipeline.RequestOptions): Promise<Pipeline$1>;
    /**
     * Deploy a playground pipeline to the managed pipeline it is already associated with.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    deployPlaygroundPipelineWithExistingManagedPipeline(pipelineId: string, requestOptions?: Pipeline.RequestOptions): Promise<Pipeline$1>;
    /**
     * Create a playground pipeline from a managed pipeline.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    createPlaygroundPipeline(pipelineId: string, request?: CreatePlaygroundPipelineApiPipelinePipelineIdPlaygroundPostRequest, requestOptions?: Pipeline.RequestOptions): Promise<Pipeline$1>;
    /**
     * Get all PlaygroundJobRecords for a given pipeline.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getAllPlaygroundJobs("pipeline-id")
     */
    getAllPlaygroundJobs(pipelineId: string, requestOptions?: Pipeline.RequestOptions): Promise<PlaygroundJobRecord[]>;
    /**
     * Kick off a new Playground execution.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.createPlaygroundJob("pipeline-id", {})
     */
    createPlaygroundJob(pipelineId: string, request?: CreatePlaygroundJobApiPipelinePipelineIdPlaygroundJobPostRequest, requestOptions?: Pipeline.RequestOptions): Promise<PlaygroundJobRecord>;
    /**
     * Get the result of the latest Playground job.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getPlaygroundJobResult("pipeline-id", {})
     */
    getPlaygroundJobResult(pipelineId: string, request?: GetPlaygroundJobResultApiPipelinePipelineIdPlaygroundJobResultGetRequest, requestOptions?: Pipeline.RequestOptions): Promise<PlatformTextNode[]>;
    /**
     * Get status of a single pipeline PlaygroundJob for a given pipeline.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getPlaygroundJob("pipeline-id", "playground-job-id")
     */
    getPlaygroundJob(pipelineId: string, playgroundJobId: string, requestOptions?: Pipeline.RequestOptions): Promise<PlaygroundJobRecord>;
    /**
     * Get the status of an EvalDatasetExecution.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getEvalDatasetExecutions("pipeline-id", "eval-dataset-id")
     */
    getEvalDatasetExecutions(pipelineId: string, evalDatasetId: string, requestOptions?: Pipeline.RequestOptions): Promise<EvalDatasetJobRecord[]>;
    /**
     * Execute a dataset.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.executeEvalDataset("pipeline-id", "eval-dataset-id", {
     *         evalQuestionIds: [],
     *         params: {
     *             llmModel: PlatformApi.SupportedEvalLlmModelNames.Gpt35Turbo
     *         }
     *     })
     */
    executeEvalDataset(pipelineId: string, evalDatasetId: string, request: EvalExecutionCreate, requestOptions?: Pipeline.RequestOptions): Promise<EvalDatasetJobRecord>;
    /**
     * Get the result of an EvalDatasetExecution.
     * If eval_question_ids is specified, only the results for the specified
     * questions will be returned.
     * If any of the specified questions do not have a result, they will be ignored.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getEvalDatasetExecutionResult("pipeline-id", "eval-dataset-id")
     */
    getEvalDatasetExecutionResult(pipelineId: string, evalDatasetId: string, requestOptions?: Pipeline.RequestOptions): Promise<EvalQuestionResult[]>;
    /**
     * Get the status of an EvalDatasetExecution.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getEvalDatasetExecution("pipeline-id", "eval-dataset-id", "eval-dataset-execution-id")
     */
    getEvalDatasetExecution(pipelineId: string, evalDatasetId: string, evalDatasetExecutionId: string, requestOptions?: Pipeline.RequestOptions): Promise<EvalDatasetJobRecord>;
    /**
     * Execute a ManagedFileIngestion for raw files for a given pipeline.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    runManagedRawFilesIngestion(pipelineId: string, request: BodyRunManagedRawFilesIngestionApiPipelinePipelineIdManagedIngestRawFilesPut, requestOptions?: Pipeline.RequestOptions): Promise<DataSourceManagedIngestionJobRecord[]>;
    /**
     * Get all ManagedDataSourceIngestionExecution for a given pipeline and data source.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getManagedDataSourceIngestionExecutions("pipeline-id", "data-source-id")
     */
    getManagedDataSourceIngestionExecutions(pipelineId: string, dataSourceId: string, requestOptions?: Pipeline.RequestOptions): Promise<DataSourceManagedIngestionJobRecord[]>;
    /**
     * Execute a ManagedDataSourceIngestion.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.runManagedDataSourceIngestion("pipeline-id", "data-source-id")
     */
    runManagedDataSourceIngestion(pipelineId: string, dataSourceId: string, requestOptions?: Pipeline.RequestOptions): Promise<DataSourceManagedIngestionJobRecord>;
    /**
     * Get a single ManagedDataSourceIngestionExecution for a given pipeline and data source.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getManagedDataSourceIngestionExecution("pipeline-id", "data-source-id", "managed-data-source-ingestion-id")
     */
    getManagedDataSourceIngestionExecution(pipelineId: string, dataSourceId: string, managedDataSourceIngestionId: string, requestOptions?: Pipeline.RequestOptions): Promise<DataSourceManagedIngestionJobRecord>;
    /**
     * Get all ManagedPipelineIngestionExecution for a given pipeline.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getManagedPipelineIngestionExecutions("pipeline-id")
     */
    getManagedPipelineIngestionExecutions(pipelineId: string, requestOptions?: Pipeline.RequestOptions): Promise<PipelineManagedIngestionJobRecord[]>;
    /**
     * Execute a ManagedPipelineIngestion.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.runManagedPipelineIngestion("pipeline-id")
     */
    runManagedPipelineIngestion(pipelineId: string, requestOptions?: Pipeline.RequestOptions): Promise<PipelineManagedIngestionJobRecord>;
    /**
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.pipeline.getManagedIngestionExecution("pipeline-id", "managed-pipeline-ingestion-id")
     */
    getManagedIngestionExecution(pipelineId: string, managedPipelineIngestionId: string, requestOptions?: Pipeline.RequestOptions): Promise<PipelineManagedIngestionJobRecord>;
    /**
     * Get retrieval results for a managed pipeline and a query
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    runSearch(pipelineId: string, request: RetrievalParams, requestOptions?: Pipeline.RequestOptions): Promise<RetrieveResults>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Eval {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class Eval {
    protected readonly _options: Eval.Options;
    constructor(_options: Eval.Options);
    /**
     * Get a dataset by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    getDataset(datasetId: string, requestOptions?: Eval.RequestOptions): Promise<EvalDataset>;
    /**
     * Update a dataset.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    updateDataset(datasetId: string, request: EvalDatasetUpdate, requestOptions?: Eval.RequestOptions): Promise<EvalDataset>;
    /**
     * Delete a dataset.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.eval.deleteDataset("dataset-id")
     */
    deleteDataset(datasetId: string, requestOptions?: Eval.RequestOptions): Promise<void>;
    /**
     * Get all questions for a dataset.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.eval.getQuestions("dataset-id")
     */
    getQuestions(datasetId: string, requestOptions?: Eval.RequestOptions): Promise<EvalQuestion[]>;
    /**
     * Create a new question.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    createQuestion(datasetId: string, request: EvalQuestionCreate, requestOptions?: Eval.RequestOptions): Promise<EvalQuestion>;
    /**
     * Create a new question.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.eval.createQuestions("dataset-id", [])
     */
    createQuestions(datasetId: string, request: EvalQuestionCreate[], requestOptions?: Eval.RequestOptions): Promise<EvalQuestion[]>;
    /**
     * Get a question by ID.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    getQuestion(questionId: string, requestOptions?: Eval.RequestOptions): Promise<EvalQuestion>;
    /**
     * Replace a question.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    replaceQuestion(questionId: string, request: EvalQuestionCreate, requestOptions?: Eval.RequestOptions): Promise<EvalQuestion>;
    /**
     * Delete a question.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.eval.deleteQuestion("question-id")
     */
    deleteQuestion(questionId: string, requestOptions?: Eval.RequestOptions): Promise<void>;
    /**
     * Get all supported models.
     * @throws {@link PlatformApi.UnprocessableEntityError}
     *
     * @example
     *     await platformApi.eval.getSupportedModels()
     */
    getSupportedModels(requestOptions?: Eval.RequestOptions): Promise<SupportedEvalLlmModel[]>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace Parsing {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class Parsing {
    protected readonly _options: Parsing.Options;
    constructor(_options: Parsing.Options);
    /**
     * Upload a file to s3 and create a job. return a job id
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    uploadFile(file: File | fs.ReadStream, requestOptions?: Parsing.RequestOptions): Promise<ParsingJob>;
    /**
     * Get parsing usage for user
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    usage(requestOptions?: Parsing.RequestOptions): Promise<ParsingUsage>;
    /**
     * Get a job by id
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    getJob(jobId: string, requestOptions?: Parsing.RequestOptions): Promise<ParsingJob>;
    /**
     * Get a job by id
     * @throws {@link PlatformApi.UnprocessableEntityError}
     */
    getJobResult(jobId: string, requestOptions?: Parsing.RequestOptions): Promise<ParsingJobMarkdownResult>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace ComponentDefinition {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class ComponentDefinition {
    protected readonly _options: ComponentDefinition.Options;
    constructor(_options: ComponentDefinition.Options);
    /**
     * Get all configurable transformation component definitions.
     *
     * @example
     *     await platformApi.componentDefinition.getAllTransformationDefinitions()
     */
    getAllTransformationDefinitions(requestOptions?: ComponentDefinition.RequestOptions): Promise<ConfigurableTransformationDefinition[]>;
    /**
     * Get all data source component definitions.
     *
     * @example
     *     await platformApi.componentDefinition.getAllDataSourceDefinitions()
     */
    getAllDataSourceDefinitions(requestOptions?: ComponentDefinition.RequestOptions): Promise<DataSourceDefinition[]>;
    /**
     * Get all data sink component definitions.
     *
     * @example
     *     await platformApi.componentDefinition.getAllDataSinkDefinitions()
     */
    getAllDataSinkDefinitions(requestOptions?: ComponentDefinition.RequestOptions): Promise<DataSinkDefinition[]>;
    protected _getAuthorizationHeader(): Promise<string | undefined>;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */

declare namespace PlatformApiClient {
    interface Options {
        environment: Supplier<string>;
        token?: Supplier<BearerToken | undefined>;
    }
    interface RequestOptions {
        timeoutInSeconds?: number;
        maxRetries?: number;
    }
}
declare class PlatformApiClient {
    protected readonly _options: PlatformApiClient.Options;
    constructor(_options: PlatformApiClient.Options);
    protected _health: Health | undefined;
    get health(): Health;
    protected _apiKey: ApiKey | undefined;
    get apiKey(): ApiKey;
    protected _dataSink: DataSink | undefined;
    get dataSink(): DataSink;
    protected _dataSource: DataSource | undefined;
    get dataSource(): DataSource;
    protected _project: Project | undefined;
    get project(): Project;
    protected _pipeline: Pipeline | undefined;
    get pipeline(): Pipeline;
    protected _eval: Eval | undefined;
    get eval(): Eval;
    protected _parsing: Parsing | undefined;
    get parsing(): Parsing;
    protected _componentDefinition: ComponentDefinition | undefined;
    get componentDefinition(): ComponentDefinition;
}

export { PlatformApiClient, PlatformApiTimeoutError };
