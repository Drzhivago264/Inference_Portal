import { Telemetry } from "./types.js";
type CacheSetting = "default" | "force-cache" | "no-cache" | "no-store" | "only-if-cached" | "reload";
export type UpstashRequest = {
    path?: string[];
    /**
     * Request body will be serialized to json
     */
    body?: unknown;
};
export type UpstashResponse<TResult> = {
    result?: TResult;
    error?: string;
};
export interface Requester {
    request: <TResult = unknown>(req: UpstashRequest) => Promise<UpstashResponse<TResult>>;
}
export type RetryConfig = false | {
    /**
     * The number of retries to attempt before giving up.
     *
     * @default 5
     */
    retries?: number;
    /**
     * A backoff function receives the current retry cound and returns a number in milliseconds to wait before retrying.
     *
     * @default
     * ```ts
     * Math.exp(retryCount) * 50
     * ```
     */
    backoff?: (retryCount: number) => number;
};
export type Options = {
    backend?: string;
};
export type RequesterConfig = {
    /**
     * Configure the retry behaviour in case of network errors
     */
    retry?: RetryConfig;
    /**
     * Due to the nature of dynamic and custom data, it is possible to write data to redis that is not
     * valid json and will therefore cause errors when deserializing. This used to happen very
     * frequently with non-utf8 data, such as emojis.
     *
     * By default we will therefore encode the data as base64 on the server, before sending it to the
     * client. The client will then decode the base64 data and parse it as utf8.
     *
     * For very large entries, this can add a few milliseconds, so if you are sure that your data is
     * valid utf8, you can disable this behaviour by setting this option to false.
     *
     * Here's what the response body looks like:
     *
     * ```json
     * {
     *  result?: "base64-encoded",
     *  error?: string
     * }
     * ```
     *
     * @default "base64"
     */
    responseEncoding?: false | "base64";
    /**
     * Configure the cache behaviour
     * @default "no-store"
     */
    cache?: CacheSetting;
};
export type HttpClientConfig = {
    headers?: Record<string, string>;
    baseUrl: string;
    options?: Options;
    retry?: RetryConfig;
    agent?: any;
} & RequesterConfig;
export declare class HttpClient implements Requester {
    baseUrl: string;
    headers: Record<string, string>;
    readonly options: {
        backend?: string;
        agent: any;
        responseEncoding?: false | "base64";
        cache?: CacheSetting;
    };
    readonly retry: {
        attempts: number;
        backoff: (retryCount: number) => number;
    };
    constructor(config: HttpClientConfig);
    mergeTelemetry(telemetry: Telemetry): void;
    request<TResult>(req: UpstashRequest): Promise<UpstashResponse<TResult>>;
}
export {};
