"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Error = exports.Miss = exports.Hit = exports.Response = void 0;
const errors_1 = require("../../errors");
const response_base_1 = require("./response-base");
const CacheSortedSetGetScoreResponse = require("./cache-sorted-set-get-score");
const grpc_response_types_1 = require("./grpc-response-types");
/**
 * Parent response type for a sorted set get scores request.  The
 * response object is resolved to a type-safe object of one of
 * the following subtypes:
 *
 * - {Hit}
 * - {Miss}
 * - {Error}
 *
 * `instanceof` type guards can be used to operate on the appropriate subtype.
 * @example
 * For example:
 * ```
 * if (response instanceof CacheSortedSetGetScores.Error) {
 *   // Handle error as appropriate.  The compiler will smart-cast `response` to type
 *   // `CacheSortedSetGetScores.Error` in this block, so you will have access to the properties
 *   // of the Error class; e.g. `response.errorCode()`.
 * }
 * ```
 */
class Response extends response_base_1.ResponseBase {
    value() {
        if (this instanceof Hit) {
            return this.value();
        }
        return undefined;
    }
}
exports.Response = Response;
class _Hit extends Response {
    constructor(scores, values) {
        super();
        this._responses = [];
        scores.forEach((score, index) => {
            if (score.result === grpc_response_types_1._ECacheResult.Hit) {
                this._responses.push(new CacheSortedSetGetScoreResponse.Hit(score.score, values[index]));
            }
            else if (score.result === grpc_response_types_1._ECacheResult.Miss) {
                this._responses.push(new CacheSortedSetGetScoreResponse.Miss(values[index]));
            }
            else {
                this._responses.push(new CacheSortedSetGetScoreResponse.Error(new errors_1.UnknownError(score.result.toString()), values[index]));
            }
        });
    }
    responses() {
        return this._responses;
    }
    /**
     * Returns the data as a Map whose keys are byte arrays and values numbers.
     * @returns {Map<Uint8Array, number>}
     */
    valueMapUint8Array() {
        return this._responses.reduce((acc, response) => {
            if (response instanceof CacheSortedSetGetScoreResponse.Hit) {
                acc.set(response.valueUint8Array(), response.score());
            }
            return acc;
        }, new Map());
    }
    /**
     * Returns the data as a Map whose keys are utf-8 strings, decoded from the underlying byte arrays and values are numbers.
     * @returns {Map<string, number>}
     */
    valueMapString() {
        return this._responses.reduce((acc, response) => {
            if (response instanceof CacheSortedSetGetScoreResponse.Hit) {
                acc.set(response.valueString(), response.score());
            }
            return acc;
        }, new Map());
    }
    /**
     * Returns the data as a Map whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This is a convenience alias for {valueMapStringString}.
     * @returns {Map<string, number>}
     */
    valueMap() {
        return this.valueMapString();
    }
    /**
     * Returns the data as a Record whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This can be used in most places where an Object is desired.
     * @returns {Record<string, number>}
     */
    valueRecordString() {
        return this._responses.reduce((acc, response) => {
            if (response instanceof CacheSortedSetGetScoreResponse.Hit) {
                acc[response.valueString()] = response.score();
            }
            return acc;
        }, {});
    }
    /**
     * Returns the data as a Record whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This can be used in most places where an Object is desired.  This is a convenience alias for
     * {valueRecordStringString}.
     * @returns {Record<string, number>}
     */
    valueRecord() {
        return this.valueRecordString();
    }
    /**
     * Returns the data as a Record whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This can be used in most places where an Object is desired.  This is a convenience alias for
     * {valueRecordStringString}.
     * @returns {Record<string, number>}
     */
    value() {
        return this.valueRecord();
    }
    toString() {
        let stringRepresentation = '';
        this.valueMapString().forEach((value, key) => {
            const keyValue = `${key}: ${value}, `;
            stringRepresentation = stringRepresentation + keyValue;
        });
        return `${super.toString()}: valueMapString: ${stringRepresentation.slice(0, -2)}`;
    }
}
/**
 * Indicates that the requested data was successfully retrieved from the cache.  Provides
 * `value*` accessors to retrieve the data in the appropriate format.
 */
class Hit extends (0, response_base_1.ResponseHit)(_Hit) {
}
exports.Hit = Hit;
class _Miss extends Response {
}
/**
 * Indicates that the requested data was not available in the cache.
 */
class Miss extends (0, response_base_1.ResponseMiss)(_Miss) {
}
exports.Miss = Miss;
class _Error extends Response {
    constructor(_innerException) {
        super();
        this._innerException = _innerException;
    }
}
/**
 * Indicates that an error occurred during the dictionary get fields request.
 *
 * This response object includes the following fields that you can use to determine
 * how you would like to handle the error:
 *
 * - `errorCode()` - a unique Momento error code indicating the type of error that occurred.
 * - `message()` - a human-readable description of the error
 * - `innerException()` - the original error that caused the failure; can be re-thrown.
 */
class Error extends (0, response_base_1.ResponseError)(_Error) {
}
exports.Error = Error;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGUtc29ydGVkLXNldC1nZXQtc2NvcmVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL21lc3NhZ2VzL3Jlc3BvbnNlcy9jYWNoZS1zb3J0ZWQtc2V0LWdldC1zY29yZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseUNBQW9EO0FBQ3BELG1EQUt5QjtBQUN6QiwrRUFBK0U7QUFDL0UsK0RBRytCO0FBTy9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUJHO0FBQ0gsTUFBc0IsUUFBUyxTQUFRLDRCQUFZO0lBQzFDLEtBQUs7UUFDVixJQUFJLElBQUksWUFBWSxHQUFHLEVBQUU7WUFDdkIsT0FBUSxJQUFZLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDOUI7UUFDRCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0NBQ0Y7QUFQRCw0QkFPQztBQUVELE1BQU0sSUFBSyxTQUFRLFFBQVE7SUFHekIsWUFBWSxNQUF3QyxFQUFFLE1BQW9CO1FBQ3hFLEtBQUssRUFBRSxDQUFDO1FBSEgsZUFBVSxHQUF5QyxFQUFFLENBQUM7UUFJM0QsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRTtZQUM5QixJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssbUNBQWEsQ0FBQyxHQUFHLEVBQUU7Z0JBQ3RDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUNsQixJQUFJLDhCQUE4QixDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUNuRSxDQUFDO2FBQ0g7aUJBQU0sSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLG1DQUFhLENBQUMsSUFBSSxFQUFFO2dCQUM5QyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FDbEIsSUFBSSw4QkFBOEIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQ3ZELENBQUM7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Q0gsTUFBYSxJQUFLLFNBQVEsSUFBQSw0QkFBWSxFQUFDLEtBQUssQ0FBQztDQUFHO0FBQWhELG9CQUFnRDtBQUVoRCxNQUFNLE1BQU8sU0FBUSxRQUFRO0lBQzNCLFlBQW1CLGVBQXlCO1FBQzFDLEtBQUssRUFBRSxDQUFDO1FBRFMsb0JBQWUsR0FBZixlQUFlLENBQVU7SUFFNUMsQ0FBQztDQUNGO0FBRUQ7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBYSxLQUFNLFNBQVEsSUFBQSw2QkFBYSxFQUFDLE1BQU0sQ0FBQztDQUFHO0FBQW5ELHNCQUFtRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7U2RrRXJyb3IsIFVua25vd25FcnJvcn0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7XG4gIFJlc3BvbnNlQmFzZSxcbiAgUmVzcG9uc2VIaXQsXG4gIFJlc3BvbnNlTWlzcyxcbiAgUmVzcG9uc2VFcnJvcixcbn0gZnJvbSAnLi9yZXNwb25zZS1iYXNlJztcbmltcG9ydCAqIGFzIENhY2hlU29ydGVkU2V0R2V0U2NvcmVSZXNwb25zZSBmcm9tICcuL2NhY2hlLXNvcnRlZC1zZXQtZ2V0LXNjb3JlJztcbmltcG9ydCB7XG4gIF9FQ2FjaGVSZXN1bHQsXG4gIF9Tb3J0ZWRTZXRHZXRTY29yZVJlc3BvbnNlUGFydCxcbn0gZnJvbSAnLi9ncnBjLXJlc3BvbnNlLXR5cGVzJztcblxudHlwZSBDYWNoZVNvcnRlZFNldEdldFNjb3JlUmVzcG9uc2VUeXBlID1cbiAgfCBDYWNoZVNvcnRlZFNldEdldFNjb3JlUmVzcG9uc2UuSGl0XG4gIHwgQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZVJlc3BvbnNlLk1pc3NcbiAgfCBDYWNoZVNvcnRlZFNldEdldFNjb3JlUmVzcG9uc2UuRXJyb3I7XG5cbi8qKlxuICogUGFyZW50IHJlc3BvbnNlIHR5cGUgZm9yIGEgc29ydGVkIHNldCBnZXQgc2NvcmVzIHJlcXVlc3QuICBUaGVcbiAqIHJlc3BvbnNlIG9iamVjdCBpcyByZXNvbHZlZCB0byBhIHR5cGUtc2FmZSBvYmplY3Qgb2Ygb25lIG9mXG4gKiB0aGUgZm9sbG93aW5nIHN1YnR5cGVzOlxuICpcbiAqIC0ge0hpdH1cbiAqIC0ge01pc3N9XG4gKiAtIHtFcnJvcn1cbiAqXG4gKiBgaW5zdGFuY2VvZmAgdHlwZSBndWFyZHMgY2FuIGJlIHVzZWQgdG8gb3BlcmF0ZSBvbiB0aGUgYXBwcm9wcmlhdGUgc3VidHlwZS5cbiAqIEBleGFtcGxlXG4gKiBGb3IgZXhhbXBsZTpcbiAqIGBgYFxuICogaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZXMuRXJyb3IpIHtcbiAqICAgLy8gSGFuZGxlIGVycm9yIGFzIGFwcHJvcHJpYXRlLiAgVGhlIGNvbXBpbGVyIHdpbGwgc21hcnQtY2FzdCBgcmVzcG9uc2VgIHRvIHR5cGVcbiAqICAgLy8gYENhY2hlU29ydGVkU2V0R2V0U2NvcmVzLkVycm9yYCBpbiB0aGlzIGJsb2NrLCBzbyB5b3Ugd2lsbCBoYXZlIGFjY2VzcyB0byB0aGUgcHJvcGVydGllc1xuICogICAvLyBvZiB0aGUgRXJyb3IgY2xhc3M7IGUuZy4gYHJlc3BvbnNlLmVycm9yQ29kZSgpYC5cbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVzcG9uc2UgZXh0ZW5kcyBSZXNwb25zZUJhc2Uge1xuICBwdWJsaWMgdmFsdWUoKTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBIaXQpIHtcbiAgICAgIHJldHVybiAodGhpcyBhcyBIaXQpLnZhbHVlKCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuY2xhc3MgX0hpdCBleHRlbmRzIFJlc3BvbnNlIHtcbiAgcHVibGljIF9yZXNwb25zZXM6IENhY2hlU29ydGVkU2V0R2V0U2NvcmVSZXNwb25zZVR5cGVbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHNjb3JlczogX1NvcnRlZFNldEdldFNjb3JlUmVzcG9uc2VQYXJ0W10sIHZhbHVlczogVWludDhBcnJheVtdKSB7XG4gICAgc3VwZXIoKTtcbiAgICBzY29yZXMuZm9yRWFjaCgoc2NvcmUsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoc2NvcmUucmVzdWx0ID09PSBfRUNhY2hlUmVzdWx0LkhpdCkge1xuICAgICAgICB0aGlzLl9yZXNwb25zZXMucHVzaChcbiAgICAgICAgICBuZXcgQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZVJlc3BvbnNlLkhpdChzY29yZS5zY29yZSwgdmFsdWVzW2luZGV4XSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoc2NvcmUucmVzdWx0ID09PSBfRUNhY2hlUmVzdWx0Lk1pc3MpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VzLnB1c2goXG4gICAgICAgICAgbmV3IENhY2hlU29ydGVkU2V0R2V0U2NvcmVSZXNwb25zZS5NaXNzKHZhbHVlc1tpbmRleF0pXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXNwb25zZXMucHVzaChcbiAgICAgICAgICBuZXcgQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZVJlc3BvbnNlLkVycm9yKFxuICAgICAgICAgICAgbmV3IFVua25vd25FcnJvcihzY29yZS5yZXN1bHQudG9TdHJpbmcoKSksXG4gICAgICAgICAgICB2YWx1ZXNbaW5kZXhdXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlc3BvbnNlcygpOiBDYWNoZVNvcnRlZFNldEdldFNjb3JlUmVzcG9uc2VUeXBlW10ge1xuICAgIHJldHVybiB0aGlzLl9yZXNwb25zZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0YSBhcyBhIE1hcCB3aG9zZSBrZXlzIGFyZSBieXRlIGFycmF5cyBhbmQgdmFsdWVzIG51bWJlcnMuXG4gICAqIEByZXR1cm5zIHtNYXA8VWludDhBcnJheSwgbnVtYmVyPn1cbiAgICovXG4gIHB1YmxpYyB2YWx1ZU1hcFVpbnQ4QXJyYXkoKTogTWFwPFVpbnQ4QXJyYXksIG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLl9yZXNwb25zZXMucmVkdWNlKChhY2MsIHJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBDYWNoZVNvcnRlZFNldEdldFNjb3JlUmVzcG9uc2UuSGl0KSB7XG4gICAgICAgIGFjYy5zZXQocmVzcG9uc2UudmFsdWVVaW50OEFycmF5KCksIHJlc3BvbnNlLnNjb3JlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBuZXcgTWFwPFVpbnQ4QXJyYXksIG51bWJlcj4oKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0YSBhcyBhIE1hcCB3aG9zZSBrZXlzIGFyZSB1dGYtOCBzdHJpbmdzLCBkZWNvZGVkIGZyb20gdGhlIHVuZGVybHlpbmcgYnl0ZSBhcnJheXMgYW5kIHZhbHVlcyBhcmUgbnVtYmVycy5cbiAgICogQHJldHVybnMge01hcDxzdHJpbmcsIG51bWJlcj59XG4gICAqL1xuICBwdWJsaWMgdmFsdWVNYXBTdHJpbmcoKTogTWFwPHN0cmluZywgbnVtYmVyPiB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlcy5yZWR1Y2UoKGFjYywgcmVzcG9uc2UpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIENhY2hlU29ydGVkU2V0R2V0U2NvcmVSZXNwb25zZS5IaXQpIHtcbiAgICAgICAgYWNjLnNldChyZXNwb25zZS52YWx1ZVN0cmluZygpLCByZXNwb25zZS5zY29yZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0YSBhcyBhIE1hcCB3aG9zZSBrZXlzIGFuZCB2YWx1ZXMgYXJlIHV0Zi04IHN0cmluZ3MsIGRlY29kZWQgZnJvbSB0aGUgdW5kZXJseWluZyBieXRlIGFycmF5cy5cbiAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIGFsaWFzIGZvciB7dmFsdWVNYXBTdHJpbmdTdHJpbmd9LlxuICAgKiBAcmV0dXJucyB7TWFwPHN0cmluZywgbnVtYmVyPn1cbiAgICovXG4gIHB1YmxpYyB2YWx1ZU1hcCgpOiBNYXA8c3RyaW5nLCBudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZU1hcFN0cmluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGEgYXMgYSBSZWNvcmQgd2hvc2Uga2V5cyBhbmQgdmFsdWVzIGFyZSB1dGYtOCBzdHJpbmdzLCBkZWNvZGVkIGZyb20gdGhlIHVuZGVybHlpbmcgYnl0ZSBhcnJheXMuXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgaW4gbW9zdCBwbGFjZXMgd2hlcmUgYW4gT2JqZWN0IGlzIGRlc2lyZWQuXG4gICAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fVxuICAgKi9cbiAgcHVibGljIHZhbHVlUmVjb3JkU3RyaW5nKCk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLl9yZXNwb25zZXMucmVkdWNlPFJlY29yZDxzdHJpbmcsIG51bWJlcj4+KChhY2MsIHJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBDYWNoZVNvcnRlZFNldEdldFNjb3JlUmVzcG9uc2UuSGl0KSB7XG4gICAgICAgIGFjY1tyZXNwb25zZS52YWx1ZVN0cmluZygpXSA9IHJlc3BvbnNlLnNjb3JlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRhIGFzIGEgUmVjb3JkIHdob3NlIGtleXMgYW5kIHZhbHVlcyBhcmUgdXRmLTggc3RyaW5ncywgZGVjb2RlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ5dGUgYXJyYXlzLlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIGluIG1vc3QgcGxhY2VzIHdoZXJlIGFuIE9iamVjdCBpcyBkZXNpcmVkLiAgVGhpcyBpcyBhIGNvbnZlbmllbmNlIGFsaWFzIGZvclxuICAgKiB7dmFsdWVSZWNvcmRTdHJpbmdTdHJpbmd9LlxuICAgKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgbnVtYmVyPn1cbiAgICovXG4gIHB1YmxpYyB2YWx1ZVJlY29yZCgpOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVJlY29yZFN0cmluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGEgYXMgYSBSZWNvcmQgd2hvc2Uga2V5cyBhbmQgdmFsdWVzIGFyZSB1dGYtOCBzdHJpbmdzLCBkZWNvZGVkIGZyb20gdGhlIHVuZGVybHlpbmcgYnl0ZSBhcnJheXMuXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgaW4gbW9zdCBwbGFjZXMgd2hlcmUgYW4gT2JqZWN0IGlzIGRlc2lyZWQuICBUaGlzIGlzIGEgY29udmVuaWVuY2UgYWxpYXMgZm9yXG4gICAqIHt2YWx1ZVJlY29yZFN0cmluZ1N0cmluZ30uXG4gICAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBudW1iZXI+fVxuICAgKi9cbiAgcHVibGljIHZhbHVlKCk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLnZhbHVlUmVjb3JkKCk7XG4gIH1cblxuICBwdWJsaWMgb3ZlcnJpZGUgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICBsZXQgc3RyaW5nUmVwcmVzZW50YXRpb24gPSAnJztcbiAgICB0aGlzLnZhbHVlTWFwU3RyaW5nKCkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgY29uc3Qga2V5VmFsdWUgPSBgJHtrZXl9OiAke3ZhbHVlfSwgYDtcbiAgICAgIHN0cmluZ1JlcHJlc2VudGF0aW9uID0gc3RyaW5nUmVwcmVzZW50YXRpb24gKyBrZXlWYWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYCR7c3VwZXIudG9TdHJpbmcoKX06IHZhbHVlTWFwU3RyaW5nOiAke3N0cmluZ1JlcHJlc2VudGF0aW9uLnNsaWNlKFxuICAgICAgMCxcbiAgICAgIC0yXG4gICAgKX1gO1xuICB9XG59XG5cbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgdGhlIHJlcXVlc3RlZCBkYXRhIHdhcyBzdWNjZXNzZnVsbHkgcmV0cmlldmVkIGZyb20gdGhlIGNhY2hlLiAgUHJvdmlkZXNcbiAqIGB2YWx1ZSpgIGFjY2Vzc29ycyB0byByZXRyaWV2ZSB0aGUgZGF0YSBpbiB0aGUgYXBwcm9wcmlhdGUgZm9ybWF0LlxuICovXG5leHBvcnQgY2xhc3MgSGl0IGV4dGVuZHMgUmVzcG9uc2VIaXQoX0hpdCkge31cblxuY2xhc3MgX01pc3MgZXh0ZW5kcyBSZXNwb25zZSB7fVxuXG4vKipcbiAqIEluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0ZWQgZGF0YSB3YXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgY2FjaGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBNaXNzIGV4dGVuZHMgUmVzcG9uc2VNaXNzKF9NaXNzKSB7fVxuXG5jbGFzcyBfRXJyb3IgZXh0ZW5kcyBSZXNwb25zZSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBfaW5uZXJFeGNlcHRpb246IFNka0Vycm9yKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxufVxuXG4vKipcbiAqIEluZGljYXRlcyB0aGF0IGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyB0aGUgZGljdGlvbmFyeSBnZXQgZmllbGRzIHJlcXVlc3QuXG4gKlxuICogVGhpcyByZXNwb25zZSBvYmplY3QgaW5jbHVkZXMgdGhlIGZvbGxvd2luZyBmaWVsZHMgdGhhdCB5b3UgY2FuIHVzZSB0byBkZXRlcm1pbmVcbiAqIGhvdyB5b3Ugd291bGQgbGlrZSB0byBoYW5kbGUgdGhlIGVycm9yOlxuICpcbiAqIC0gYGVycm9yQ29kZSgpYCAtIGEgdW5pcXVlIE1vbWVudG8gZXJyb3IgY29kZSBpbmRpY2F0aW5nIHRoZSB0eXBlIG9mIGVycm9yIHRoYXQgb2NjdXJyZWQuXG4gKiAtIGBtZXNzYWdlKClgIC0gYSBodW1hbi1yZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3JcbiAqIC0gYGlubmVyRXhjZXB0aW9uKClgIC0gdGhlIG9yaWdpbmFsIGVycm9yIHRoYXQgY2F1c2VkIHRoZSBmYWlsdXJlOyBjYW4gYmUgcmUtdGhyb3duLlxuICovXG5leHBvcnQgY2xhc3MgRXJyb3IgZXh0ZW5kcyBSZXNwb25zZUVycm9yKF9FcnJvcikge31cbiJdfQ==