"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractCacheClient = void 0;
const index_1 = require("../../../index");
const momento_cache_1 = require("./momento-cache");
class AbstractCacheClient {
    constructor(controlClient, dataClients, pingClient) {
        this.controlClient = controlClient;
        this.dataClients = dataClients;
        this.pingClient = pingClient;
        // We round-robin the requests through all of our clients.  Since javascript
        // is single-threaded, we don't have to worry about thread safety on this
        // index variable.
        this.nextDataClientIndex = 0;
    }
    cache(cacheName) {
        return new momento_cache_1.MomentoCache(this, cacheName);
    }
    /**
     * Ping the service to verify it is up and running
     */
    async ping() {
        var _a;
        return await ((_a = this.pingClient) === null || _a === void 0 ? void 0 : _a.ping());
    }
    /**
     * Creates a cache if it does not exist.
     *
     * @param {string} cacheName - The cache to be created.
     * @returns {Promise<CreateCache.Response>} -
     * {@link CreateCache.Success} on success.
     * {@link CreateCache.AlreadyExists} if the cache already exists.
     * {@link CreateCache.Error} on failure.
     */
    async createCache(cacheName) {
        return await this.controlClient.createCache(cacheName);
    }
    /**
     * Deletes a cache and all items stored in it.
     *
     * @param {string} cacheName - The cache to delete.
     * @returns {Promise<DeleteCache.Response>} -
     * {@link DeleteCache.Success} on success.
     * {@link DeleteCache.Error} on failure.
     */
    async deleteCache(cacheName) {
        return await this.controlClient.deleteCache(cacheName);
    }
    /**
     * Lists all caches.
     *
     * @returns {Promise<ListCaches.Response>} -
     * {@link ListCaches.Success} containing the list on success.
     * {@link ListCaches.Error} on failure.
     */
    async listCaches() {
        return await this.controlClient.listCaches();
    }
    /**
     * Gets the value stored for the given key.
     *
     * @param {string} cacheName - The cache to perform the lookup in.
     * @param {string | Uint8Array} key - The key to look up.
     * @returns {Promise<CacheGet.Response>} -
     * {@link CacheGet.Hit} containing the value if one is found.
     * {@link CacheGet.Miss} if the key does not exist.
     * {@link CacheGet.Error} on failure.
     */
    async get(cacheName, key) {
        return await this.getNextDataClient().get(cacheName, key);
    }
    /**
     * Associates the given key with the given value. If a value for the key is
     * already present it is replaced with the new value.
     *
     * @param {string} cacheName - The cache to store the value in.
     * @param {string | Uint8Array} key - The key to set.
     * @param {string | Uint8Array} value - The value to be stored.
     * @param {SetOptions} [options]
     * @param {number} [options.ttl] - The time to live for the item in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @returns {Promise<CacheSet.Response>} -
     * {@link CacheSet.Success} on success.
     * {@link CacheSet.Error} on failure.
     */
    async set(cacheName, key, value, options) {
        if (typeof options === 'number') {
            throw new index_1.InvalidArgumentError('Options must be an object with a ttl property.');
        }
        const client = this.getNextDataClient();
        return await client.set(cacheName, key, value, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Removes the given key from the cache. The key can represent a single value
     * or a collection.
     *
     * @param {string} cacheName - The cache to delete from.
     * @param {string | Uint8Array} key - The key to delete.
     * @returns {Promise<CacheDelete.Response>} -
     * {@link CacheDelete.Success} on success.
     * {@link CacheDelete.Error} on failure.
     */
    async delete(cacheName, key) {
        const client = this.getNextDataClient();
        return await client.delete(cacheName, key);
    }
    /**
     * Gets the value stored for the given keys.
     *
     * @param {string} cacheName - The cache to perform the lookup in.
     * @param {string[] | Uint8Array[]} keys - The list of keys to look up.
     * @returns {Promise<GetBatch.Response>} -
     * {@link GetBatch.Success} containing the values if they were found.
     * {@link GetBatch.Error} on failure.
     */
    async getBatch(cacheName, keys) {
        return await this.getNextDataClient().getBatch(cacheName, keys);
    }
    /**
     * Associates the given keys with the given values. If a value for the key is
     * already present it is replaced with the new value.
     *
     * @param {string} cacheName - The cache to store the values in.
     * @param {Record<string, string | Uint8Array> | Map<string | Uint8Array, string | Uint8Array>} items - The key-value pairs to be stored.
     * @param {SetOptions} [options]
     * @param {number} [options.ttl] - The time to live for the items in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @returns {Promise<CacheSet.Response>} -
     * {@link SetBatch.Success} on success.
     * {@link SetBatch.Error} on failure.
     */
    async setBatch(cacheName, items, options) {
        const client = this.getNextDataClient();
        return await client.setBatch(cacheName, items, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds multiple elements to the back of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to add to.
     * @param {string[] | Uint8Array[]} values - The elements to add to the list.
     * @param {ListConcatenateBackOptions} [options]
     * @param {number} [options.truncateFrontToSize] - If the list exceeds this
     * length, remove excess from the front of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListConcatenateBack.Response>} -
     * {@link CacheListConcatenateBack.Success} on success.
     * {@link CacheListConcatenateBack.Error} on failure.
     */
    async listConcatenateBack(cacheName, listName, values, options) {
        const client = this.getNextDataClient();
        return await client.listConcatenateBack(cacheName, listName, values, options === null || options === void 0 ? void 0 : options.truncateFrontToSize, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds multiple elements to the front of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to add to.
     * @param {string[] | Uint8Array[]} values - The elements to add to the list.
     * @param {ListConcatenateFrontOptions} [options]
     * @param {number} [options.truncateBackToSize] - If the list exceeds this
     * length, remove excess from the back of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListConcatenateFront.Response>} -
     * {@link CacheListConcatenateFront.Success} on success.
     * {@link CacheListConcatenateFront.Error} on failure.
     */
    async listConcatenateFront(cacheName, listName, values, options) {
        const client = this.getNextDataClient();
        return await client.listConcatenateFront(cacheName, listName, values, options === null || options === void 0 ? void 0 : options.truncateBackToSize, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Fetches all elements of the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to fetch.
     * @param {ListFetchCallOptions} [options]
     * @param {number} [options.startIndex] - Start inclusive index for fetch operation.
     * @param {number} [options.endIndex] - End exclusive index for fetch operation.
     * @returns {Promise<CacheListFetch.Response>} -
     * {@link CacheListFetch.Hit} containing the list elements if the list exists.
     * {@link CacheListFetch.Miss} if the list does not exist.
     * {@link CacheListFetch.Error} on failure.
     */
    async listFetch(cacheName, listName, options) {
        const client = this.getNextDataClient();
        return await client.listFetch(cacheName, listName, options === null || options === void 0 ? void 0 : options.startIndex, options === null || options === void 0 ? void 0 : options.endIndex);
    }
    /**
     * Gets the number of elements in the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to get the length of.
     * @returns {Promise<CacheListLength.Response>} -
     * {@link CacheListLength.Hit} containing the length if the list exists.
     * {@link CacheListLength.Miss} if the list does not exist.
     * {@link CacheListLength.Error} on failure.
     */
    async listLength(cacheName, listName) {
        const client = this.getNextDataClient();
        return await client.listLength(cacheName, listName);
    }
    /**
     * Gets and removes the last value from the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to pop.
     * @returns {Promise<CacheListPopBack.Response>} -
     * {@link CacheListPopBack.Hit} containing the element if the list exists.
     * {@link CacheListPopBack.Miss} if the list does not exist.
     * {@link CacheListPopBack.Error} on failure.
     */
    async listPopBack(cacheName, listName) {
        const client = this.getNextDataClient();
        return await client.listPopBack(cacheName, listName);
    }
    /**
     * Gets and removes the first value from the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to pop.
     * @returns {Promise<CacheListPopFront.Response>} -
     * {@link CacheListPopFront.Hit} containing the element if the list exists.
     * {@link CacheListPopFront.Miss} if the list does not exist.
     * {@link CacheListPopFront.Error} on failure.
     */
    async listPopFront(cacheName, listName) {
        const client = this.getNextDataClient();
        return await client.listPopFront(cacheName, listName);
    }
    /**
     * Adds an element to the back of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to push to.
     * @param {string | Uint8Array} value - The value to push.
     * @param {ListPushBackOptions} [options]
     * @param {number} [options.truncateFrontToSize] - If the list exceeds this
     * length, remove excess from the front of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListPushBack.Response>} -
     * {@link CacheListPushBack.Success} containing the list's new length on
     * success.
     * {@link CacheListPushBack.Error} on failure.
     */
    async listPushBack(cacheName, listName, value, options) {
        const client = this.getNextDataClient();
        return await client.listPushBack(cacheName, listName, value, options === null || options === void 0 ? void 0 : options.truncateFrontToSize, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds an element to the front of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to push to.
     * @param {string | Uint8Array} value - The value to push.
     * @param {ListPushFrontOptions} [options]
     * @param {number} [options.truncateBackToSize] - If the list exceeds this
     * length, remove excess from the end of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListPushFront.Response>} -
     * {@link CacheListPushFront.Success} containing the list's new length on
     * success.
     * {@link CacheListPushFront.Error} on failure.
     */
    async listPushFront(cacheName, listName, value, options) {
        const client = this.getNextDataClient();
        return await client.listPushFront(cacheName, listName, value, options === null || options === void 0 ? void 0 : options.truncateBackToSize, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Removes all elements from the given list equal to the given value.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to remove from.
     * @param {string | Uint8Array} value - The value to remove.
     * @returns {Promise<CacheListRemoveValue.Response>} -
     * {@link CacheListRemoveValue.Success} on success. Removing an element that
     * does not occur in the list or removing from a non-existent list counts as a
     * success.
     * {@link CacheListRemoveValue.Error} on failure.
     */
    async listRemoveValue(cacheName, listName, value) {
        const client = this.getNextDataClient();
        return await client.listRemoveValue(cacheName, listName, value);
    }
    /**
     * Retains slice of elements of a given list, deletes the rest of the list
     * that isn't being retained. Returns a Success or Error.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to retain a slice of.
     * @param {ListRetainCallOptions} [options]
     * @param {number} [options.startIndex] - Start inclusive index for fetch
     * operation. Defaults to start of array if not given, 0.
     * @param {number} [options.endIndex] - End exclusive index for fetch
     * operation. Defaults to end of array if not given.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListRetain.Response>} -
     * {@link CacheListRetain.Success} on success.
     * {@link CacheListRetain.Error} on failure.
     */
    async listRetain(cacheName, listName, options) {
        const client = this.getNextDataClient();
        return await client.listRetain(cacheName, listName, options === null || options === void 0 ? void 0 : options.startIndex, options === null || options === void 0 ? void 0 : options.endIndex, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Fetches all elements of the given set
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to fetch.
     * @returns {Promise<CacheSetFetch.Response>} -
     * {@link CacheSetFetch.Hit} containing the set elements if the set exists.
     * {@link CacheSetFetch.Miss} if the set does not exist.
     * {@link CacheSetFetch.Error} on failure.
     */
    async setFetch(cacheName, setName) {
        const client = this.getNextDataClient();
        return await client.setFetch(cacheName, setName);
    }
    /**
     * Adds an element to the given set. Creates the set if it does not already
     * exist.
     *
     * @remarks
     * After this operation the set will contain the union of the element passed
     * in and the original elements of the set.
     *
     * @param {string} cacheName - The cache to store the set in.
     * @param {string} setName - The set to add to.
     * @param {string | Uint8Array} element - The element to add.
     * @param {SetAddElementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the set's TTL using the client's default if this is not supplied.
     * @returns {Promise<CacheSetAddElement.Response>} -
     * {@link CacheSetAddElement.Success} on success.
     * {@link CacheSetAddElement.Error} on failure.
     */
    async setAddElement(cacheName, setName, element, options) {
        return (await this.setAddElements(cacheName, setName, [element], options)).toSingularResponse();
    }
    /**
     * Adds multiple elements to the given set. Creates the set if it does not
     * already exist.
     *
     * @remarks
     * After this operation, the set will contain the union of the elements passed
     * in and the original elements of the set.
     *
     * @param {string} cacheName - The cache to store the set in.
     * @param {string} setName - The set to add to.
     * @param {string[] | Uint8Array[]} elements - The elements to add.
     * @param {SetAddElementsOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the set's TTL using the client's default if this is not supplied.
     * @returns {Promise<CacheSetAddElements.Response>} -
     * {@link CacheSetAddElements.Success} on success.
     * {@link CacheSetAddElements.Error} on failure.
     */
    async setAddElements(cacheName, setName, elements, options) {
        const client = this.getNextDataClient();
        return await client.setAddElements(cacheName, setName, elements, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Removes an element from the given set.
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to remove from.
     * @param {string | Uint8Array} element - The element to remove.
     * @returns {Promise<CacheSetRemoveElement.Response>} -
     * {@link CacheSetRemoveElement.Success} on success. Removing an element that
     * does not occur in the set or removing from a non-existent set counts as a
     * success.
     * {@link CacheSetRemoveElement.Error} on failure.
     */
    async setRemoveElement(cacheName, setName, element) {
        return (await this.setRemoveElements(cacheName, setName, [element])).toSingularResponse();
    }
    /**
     * Removes multiple elements from the given set.
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to remove from.
     * @param {string[] | Uint8Array[]} elements - The elements to remove.
     * @returns {Promise<CacheSetRemoveElements.Response>} -
     * {@link CacheSetRemoveElements.Success} on success. Removing elements that
     * do not occur in the set or removing from a non-existent set counts as a
     * success.
     * {@link CacheSetRemoveElements.Error} on failure.
     */
    async setRemoveElements(cacheName, setName, elements) {
        const client = this.getNextDataClient();
        return await client.setRemoveElements(cacheName, setName, elements);
    }
    /**
     * Associates the given key with the given value. If a value for the key is
     * already present it is not replaced with the new value.
     *
     * @param {string} cacheName - The cache to store the value in.
     * @param {string | Uint8Array} key - The key to set.
     * @param {string | Uint8Array} field - The value to be stored.
     * @param {SetIfNotExistsOptions} [options]
     * @param {number} [options.ttl] - The time to live for the item in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @returns {Promise<CacheSetIfNotExists.Response>} -
     * {@link CacheSetIfNotExists.Stored} on storing the new value.
     * {@link CacheSetIfNotExists.NotStored} on not storing the new value.
     * {@link CacheSetIfNotExists.Error} on failure.
     */
    async setIfNotExists(cacheName, key, field, options) {
        const client = this.getNextDataClient();
        return await client.setIfNotExists(cacheName, key, field, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Flushes / clears all the items of the given cache
     *
     * @param {string} cacheName - The cache to be flushed.
     * @returns {Promise<CacheFlush.Response>} -
     * {@link CacheFlush.Success} on success.
     * {@link CacheFlush.Error} on failure.
     */
    async flushCache(cacheName) {
        return await this.controlClient.flushCache(cacheName);
    }
    /**
     * Fetches all elements of the given dictionary.
     *
     * @param {string} cacheName - The cache to perform the lookup in.
     * @param {string} dictionaryName - The dictionary to fetch.
     * @returns {Promise<CacheDictionaryFetch.Response>} -
     * {@link CacheDictionaryFetch.Hit} containing the dictionary elements if the
     * dictionary exists.
     * {@link CacheDictionaryFetch.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryFetch.Error} on failure.
     */
    async dictionaryFetch(cacheName, dictionaryName) {
        const client = this.getNextDataClient();
        return await client.dictionaryFetch(cacheName, dictionaryName);
    }
    /**
     * Adds an integer quantity to a field value.
     *
     * @remarks
     * Incrementing the value of a missing field sets the value to amount.
     *
     * @param {string} cacheName - The cache containing the field.
     * @param {string | Uint8Array} field - The field to increment.
     * @param {number} amount - The quantity to add to the value. May be positive,
     * negative, or zero. Defaults to 1.
     * @param {IncrementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * @returns {Promise<CacheIncrement>} -
     * {@link CacheIncrement.Success} containing the incremented value
     * on success.
     * {@link CacheIncrement.Error} on failure. Incrementing a value
     * that was not set using this method or is not the string representation of
     * an integer results in a failure with a FailedPreconditionException error.
     */
    async increment(cacheName, field, amount = 1, options) {
        const client = this.getNextDataClient();
        return await client.increment(cacheName, field, amount, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds an element to the given dictionary. Creates the dictionary if it does
     * not already exist.
     *
     * @param {string} cacheName - The cache to store the dictionary in.
     * @param {string} dictionaryName - The dictionary to add to.
     * @param {string | Uint8Array} field - The field to set.
     * @param {string | Uint8Array} value - The value to store.
     * @param {DictionarySetFieldOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the dictionary's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheDictionarySetField.Response>} -
     * {@link CacheDictionarySetField.Success} on success.
     * {@link CacheDictionarySetField.Error} on failure.
     */
    async dictionarySetField(cacheName, dictionaryName, field, value, options) {
        const client = this.getNextDataClient();
        return await client.dictionarySetField(cacheName, dictionaryName, field, value, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds multiple elements to the given dictionary. Creates the dictionary if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the dictionary in.
     * @param {string} dictionaryName - The dictionary to add to.
     * @param {Map<string | Uint8Array, string | Uint8Array>} elements - The
     * elements to set.
     * @param {DictionarySetFieldsOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the dictionary's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheDictionarySetFields.Response>} -
     * {@link CacheDictionarySetFields.Success} on success.
     * {@link CacheDictionarySetFields.Error} on failure.
     */
    async dictionarySetFields(cacheName, dictionaryName, elements, options) {
        const client = this.getNextDataClient();
        return await client.dictionarySetFields(cacheName, dictionaryName, elements, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Gets the value stored for the given dictionary and field.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to look up.
     * @param {string | Uint8Array} field - The field to look up.
     * @returns {Promise<CacheDictionaryGetField.Response>} -
     * {@link CacheDictionaryGetField.Hit} containing the dictionary element if
     * one is found.
     * {@link CacheDictionaryGetField.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryGetField.Error} on failure.
     */
    async dictionaryGetField(cacheName, dictionaryName, field) {
        const client = this.getNextDataClient();
        return await client.dictionaryGetField(cacheName, dictionaryName, field);
    }
    /**
     * Gets multiple values from the given dictionary.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to look up.
     * @param {string[] | Uint8Array[]} fields - The fields to look up.
     * @returns {Promise<CacheDictionaryGetFields.Response>} -
     * {@link CacheDictionaryGetFields.Hit} containing the dictionary elements if
     * the dictionary exists.
     * {@link CacheDictionaryGetFields.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryGetFields.Error} on failure.
     */
    async dictionaryGetFields(cacheName, dictionaryName, fields) {
        const client = this.getNextDataClient();
        return await client.dictionaryGetFields(cacheName, dictionaryName, fields);
    }
    /**
     * Removes an element from the given dictionary.
     *
     * @remarks
     * Performs a no-op if the dictionary or field does not exist.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to remove from.
     * @param {string | Uint8Array} field - The field to remove.
     * @returns {Promise<CacheDictionaryRemoveField.Response>} -
     * {@link CacheDictionaryRemoveField.Success} on success.
     * {@link CacheDictionaryRemoveField.Error} on failure.
     */
    async dictionaryRemoveField(cacheName, dictionaryName, field) {
        const client = this.getNextDataClient();
        return await client.dictionaryRemoveField(cacheName, dictionaryName, field);
    }
    /**
     * Removes multiple fields from the given dictionary.
     *
     * @remarks
     * Performs a no-op if the dictionary or fields do not exist.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to remove from.
     * @param {string[] | Uint8Array[]} fields - The fields to remove.
     * @returns {Promise<CacheDictionaryRemoveFields.Response>} -
     * {@link CacheDictionaryRemoveFields.Success} on success.
     * {@link CacheDictionaryRemoveFields.Error} on failure.
     */
    async dictionaryRemoveFields(cacheName, dictionaryName, fields) {
        const client = this.getNextDataClient();
        return await client.dictionaryRemoveFields(cacheName, dictionaryName, fields);
    }
    /**
     * Adds an integer quantity to a dictionary value.
     *
     * @remarks
     * Incrementing the value of a missing field sets the value to amount.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to set.
     * @param {string | Uint8Array} field - The field to increment.
     * @param {number} amount - The quantity to add to the value. May be positive,
     * negative, or zero. Defaults to 1.
     * @param {DictionaryIncrementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the dictionary's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheDictionaryIncrement.Response>} -
     * {@link CacheDictionaryIncrement.Success} containing the incremented value
     * on success.
     * {@link CacheDictionaryIncrement.Error} on failure. Incrementing a value
     * that was not set using this method or is not the string representation of
     * an integer results in a failure with a FailedPreconditionException error.
     */
    async dictionaryIncrement(cacheName, dictionaryName, field, amount = 1, options) {
        const client = this.getNextDataClient();
        return await client.dictionaryIncrement(cacheName, dictionaryName, field, amount, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Gets the number of elements in the given dictionary.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to get the length of.
     * @returns {Promise<CacheDictionaryLength.Response>} -
     * {@link CacheDictionaryLength.Hit} containing the length if the dictionary exists.
     * {@link CacheDictionaryLength.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryLength.Error} on failure.
     */
    async dictionaryLength(cacheName, dictionaryName) {
        const client = this.getNextDataClient();
        return await client.dictionaryLength(cacheName, dictionaryName);
    }
    /**
     * Adds an element to the given sorted set. If the element already exists, its
     * score is updated. Creates the sorted set if it does not exist.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to add to.
     * @param {string | Uint8Array} value - The value to add.
     * @param {number} score - The score to assign to the value.
     * @param {SortedSetPutElementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the sorted set's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheSortedSetPutElement.Response>} -
     * {@link CacheSortedSetPutElement.Success} on success.
     * {@link CacheSortedSetPutElement.Error} on failure.
     * @returns
     */
    async sortedSetPutElement(cacheName, sortedSetName, value, score, options) {
        const client = this.getNextDataClient();
        return await client.sortedSetPutElement(cacheName, sortedSetName, value, score, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Adds elements to the given sorted set. For any values that already exist, it
     * the score is updated. Creates the sorted set if it does not exist.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to add to.
     * @param {Map<string | Uint8Array, number>| Record<string, number>} elements - The value->score pairs to add to the sorted set.
     * @param {SortedSetPutElementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the sorted set's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheSortedSetPutElements.Response>} -
     * {@link CacheSortedSetPutElements.Success} on success.
     * {@link CacheSortedSetPutElements.Error} on failure.
     * @returns
     */
    async sortedSetPutElements(cacheName, sortedSetName, elements, options) {
        const client = this.getNextDataClient();
        return await client.sortedSetPutElements(cacheName, sortedSetName, elements, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Fetch the elements in the given sorted set by index (rank).
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {SortedSetFetchByRankOptions} options
     * @param {number} [options.startRank] - The rank of the first element to
     * fetch. Defaults to 0. This rank is inclusive, ie the element at this rank
     * will be fetched.
     * @param {number} [options.endRank] - The rank of the last element to fetch.
     * This rank is exclusive, ie the element at this rank will not be fetched.
     * Defaults to null, which fetches up until and including the last element.
     * @param {SortedSetOrder} [options.order] - The order to fetch the elements in.
     * Defaults to ascending.
     * @returns {Promise<CacheSortedSetFetch.Response>}
     * {@link CacheSortedSetFetch.Hit} containing the requested elements when found.
     * {@link CacheSortedSetFetch.Miss} when the sorted set does not exist.
     * {@link CacheSortedSetFetch.Error} on failure.
     */
    async sortedSetFetchByRank(cacheName, sortedSetName, options) {
        var _a, _b;
        const client = this.getNextDataClient();
        return await client.sortedSetFetchByRank(cacheName, sortedSetName, (_a = options === null || options === void 0 ? void 0 : options.order) !== null && _a !== void 0 ? _a : index_1.SortedSetOrder.Ascending, (_b = options === null || options === void 0 ? void 0 : options.startRank) !== null && _b !== void 0 ? _b : 0, options === null || options === void 0 ? void 0 : options.endRank);
    }
    /**
     * Fetch the elements in the given sorted set by score.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {SortedSetFetchByScoreOptions} options
     * @param {number} [options.minScore] - The minimum score (inclusive) of the
     * elements to fetch. Defaults to negative infinity.
     * @param {number} [options.maxScore] - The maximum score (inclusive) of the
     * elements to fetch. Defaults to positive infinity.
     * @param {SortedSetOrder} [options.order] - The order to fetch the elements in.
     * Defaults to ascending.
     * @param {number} [options.offset] - The number of elements to skip before
     * returning the first element. Defaults to 0. Note: this is not the rank of
     * the first element to return, but the number of elements of the result set
     * to skip before returning the first element.
     * @param {number} [options.count] - The maximum number of elements to return.
     * Defaults to undefined, which returns all elements.
     * @returns {Promise<CacheSortedSetFetch.Response>} -
     * {@link CacheSortedSetFetch.Hit} containing the requested elements when found.
     * {@link CacheSortedSetFetch.Miss} when the sorted set does not exist.
     * {@link CacheSortedSetFetch.Error} on failure.
     */
    async sortedSetFetchByScore(cacheName, sortedSetName, options) {
        var _a;
        const client = this.getNextDataClient();
        return await client.sortedSetFetchByScore(cacheName, sortedSetName, (_a = options === null || options === void 0 ? void 0 : options.order) !== null && _a !== void 0 ? _a : index_1.SortedSetOrder.Ascending, options === null || options === void 0 ? void 0 : options.minScore, options === null || options === void 0 ? void 0 : options.maxScore, options === null || options === void 0 ? void 0 : options.offset, options === null || options === void 0 ? void 0 : options.count);
    }
    /**
     * Look up the rank of an element in the sorted set, by the value of the element.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string | Uint8Array} value - The value of the element whose rank we are retrieving.
     * @returns {Promise<CacheSortedSetGetRank.Response>}
     * {@link CacheSortedSetGetRank.Hit} containing the rank of the requested elements when found.
     * {@link CacheSortedSetGetRank.Miss} when the element does not exist.
     * {@link CacheSortedSetGetRank.Error} on failure.
     */
    async sortedSetGetRank(cacheName, sortedSetName, value) {
        const client = this.getNextDataClient();
        return await client.sortedSetGetRank(cacheName, sortedSetName, value);
    }
    /**
     * Look up the score of an element in the sorted set, by the value of the element.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string | Uint8Array} value - The value of the element whose score we are retrieving.
     * @returns {Promise<CacheSortedSetGetScore.Response>}
     * {@link CacheSortedSetGetScore.Hit} containing the score of the requested element when found.
     * {@link CacheSortedSetGetScore.Miss} when the element or collection does not exist.
     * {@link CacheSortedSetGetScore.Error} on failure.
     */
    async sortedSetGetScore(cacheName, sortedSetName, value) {
        const client = this.getNextDataClient();
        return await client.sortedSetGetScore(cacheName, sortedSetName, value);
    }
    /**
     * Look up the scores of multiple elements in the sorted set, by the value of the elements.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string[] | Uint8Array[]} values - The values of the elements whose scores we are retrieving.
     * @returns {Promise<CacheSortedSetGetScores.Response>}
     * {@link CacheSortedSetGetScores.Hit} containing the scores of the requested elements when found.
     * {@link CacheSortedSetGetScores.Miss} when the element or collection does not exist.
     * {@link CacheSortedSetGetScores.Error} on failure.
     */
    async sortedSetGetScores(cacheName, sortedSetName, values) {
        const client = this.getNextDataClient();
        return await client.sortedSetGetScores(cacheName, sortedSetName, values);
    }
    /**
     * Increment the score of an element in the sorted set.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string | Uint8Array} value - The value of the element whose score we are incrementing.
     * @param {number} amount - The quantity to add to the score. May be positive,
     * negative, or zero. Defaults to 1.
     * @param {SortedSetIncrementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the sorted set's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheSortedSetIncrementScore.Response>} -
     * {@link CacheSortedSetIncrementScore.Success} containing the incremented score
     * on success.
     * {@link CacheSortedSetIncrementScore.Error} on failure. Incrementing a score
     * that was not set using this method or is not the string representation of
     * an integer results in a failure with a FailedPreconditionException error.
     */
    async sortedSetIncrementScore(cacheName, sortedSetName, value, amount, options) {
        const client = this.getNextDataClient();
        return await client.sortedSetIncrementScore(cacheName, sortedSetName, value, amount || 1, options === null || options === void 0 ? void 0 : options.ttl);
    }
    /**
     * Remove an element from the sorted set
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to remove from.
     * @param {string | Uint8Array} value - The value of the element to remove from the set.
     * @returns {Promise<CacheSortedSetRemoveElement.Response>}
     * {@link CacheSortedSetRemoveElement.Success} if the element was successfully removed
     * {@link CacheSortedSetIncrementScore.Error} on failure
     */
    async sortedSetRemoveElement(cacheName, sortedSetName, value) {
        const client = this.getNextDataClient();
        return await client.sortedSetRemoveElement(cacheName, sortedSetName, value);
    }
    /**
     * Remove multiple elements from the sorted set
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to remove from.
     * @param {string | Uint8Array} values - The values of the elements to remove from the set.
     * @returns {Promise<CacheSortedSetRemoveElement.Response>}
     * {@link CacheSortedSetRemoveElement.Success} if the elements were successfully removed
     * {@link CacheSortedSetIncrementScore.Error} on failure
     */
    async sortedSetRemoveElements(cacheName, sortedSetName, values) {
        const client = this.getNextDataClient();
        return await client.sortedSetRemoveElements(cacheName, sortedSetName, values);
    }
    /**
     * Fetch length (number of items) of sorted set
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set name.
     * @returns {Promise<CacheSortedSetLength.Response>}
     * {@link CacheSortedSetLength.Hit} containing the length if the sorted set exists.
     * {@link CacheSortedSetLength.Miss} if the sorted set does not exist.
     * {@link CacheSortedSetLength.Error} on failure.
     */
    async sortedSetLength(cacheName, sortedSetName) {
        const client = this.getNextDataClient();
        return await client.sortedSetLength(cacheName, sortedSetName);
    }
    /**
     * Fetch length (number of items) of sorted set within the provided score range
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set name.
     * @param {SortedSetLengthByScoreOptions} options - Optional parameter for specifying the score range to search in.
     * @param {number} [options.minScore] - The lower bound on the score range to search in.
     * @param {number} [options.maxScore] - The upper bound on the score range to search in.
     * @returns {Promise<CacheSortedSetLengthByScore.Response>}
     * {@link CacheSortedSetLengthByScore.Hit} containing the length if the sorted set exists.
     * {@link CacheSortedSetLengthByScore.Miss} if the sorted set does not exist.
     * {@link CacheSortedSetLengthByScore.Error} on failure.
     */
    async sortedSetLengthByScore(cacheName, sortedSetName, options) {
        const client = this.getNextDataClient();
        return await client.sortedSetLengthByScore(cacheName, sortedSetName, options === null || options === void 0 ? void 0 : options.minScore, options === null || options === void 0 ? void 0 : options.maxScore);
    }
    /**
     * Return the type of the key in the cache
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which type is requested.
     * @returns {Promise<CacheItemGetType.Response>}
     * {@link CacheItemGetType.Hit} containing type of key when found.
     * {@link CacheItemGetType.Miss} when the key does not exist.
     * {@link CacheItemGetType.Error} on failure.
     */
    async itemGetType(cacheName, key) {
        const client = this.getNextDataClient();
        return await client.itemGetType(cacheName, key);
    }
    /**
     * Return the remaining ttl of the key in the cache in milliseconds.
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which the ttl remaining is requested.
     * @returns {Promise<CacheItemGetTtl.Response>}
     * {@link CacheItemGetTtl.Hit} containing ttl remaining of key when found.
     * {@link CacheItemGetTtl.Miss} when the key does not exist.
     * {@link CacheItemGetTtl.Error} on failure.
     */
    async itemGetTtl(cacheName, key) {
        const client = this.getNextDataClient();
        return await client.itemGetTtl(cacheName, key);
    }
    /**
     * Check if the provided key exists in the cache
     * @param {string} cacheName - The cache to look in.
     * @param {string | Uint8Array} key - The key to look up.
     * @returns {Promise<CacheKeyExists.Response>}
     * {@link CacheKeyExists.Success} if key is found? or if key is checked?
     * {@link CacheKeyExists.Error} on failure.
     */
    async keyExists(cacheName, key) {
        const client = this.getNextDataClient();
        return await client.keyExists(cacheName, key);
    }
    /**
     * Check if the provided keys exist in the cache
     * @param {string} cacheName - The cache to look in.
     * @param {string[] | Uint8Array[]} keys - The keys to look up.
     * @returns {Promise<CacheKeysExist.Response>}
     * {@link CacheKeysExist.Success} if at least one key is found? if all keys checked?
     * {@link CacheKeysExist.Error} on failure.
     */
    async keysExist(cacheName, keys) {
        const client = this.getNextDataClient();
        return await client.keysExist(cacheName, keys);
    }
    /**
     * Update the ttl of the key in the cache in milliseconds.
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which the ttl remaining is requested.
     * @param {number} ttlMilliseconds - The ttl in milliseconds that should overwrite the current ttl.
     * @returns {Promise<CacheUpdateTtl.Response>}
     * {@link CacheUpdateTtl.Set} when the ttl was successfully overwritten.
     * {@link CacheUpdateTtl.Miss} when the key does not exist.
     * {@link CacheUpdateTtl.Error} on failure.
     */
    async updateTtl(cacheName, key, ttlMilliseconds) {
        const client = this.getNextDataClient();
        return await client.updateTtl(cacheName, key, ttlMilliseconds);
    }
    /**
     * Increase the ttl of the key in the cache in milliseconds.
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which the ttl remaining is requested.
     * @param {number} ttlMilliseconds - The ttl in milliseconds that should
     * overwrite the current ttl. Should be greater than the current ttl.
     * @returns {Promise<CacheIncreaseTtl.Response>}
     * {@link CacheIncreaseTtl.Set} when the ttl was successfully increased.
     * {@link CacheIncreaseTtl.Miss} when the key does not exist.
     * {@link CacheIncreaseTtl.Error} on failure.
     */
    async increaseTtl(cacheName, key, ttlMilliseconds) {
        const client = this.getNextDataClient();
        return await client.increaseTtl(cacheName, key, ttlMilliseconds);
    }
    /**
     * Decrease the ttl of the key in the cache in milliseconds.
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which the ttl remaining is requested.
     * @param {number} ttlMilliseconds - The ttl in milliseconds that should
     * overwrite the current ttl. Should be less than the current ttl.
     * @returns {Promise<CacheDecreaseTtl.Response>}
     * {@link CacheDecreaseTtl.Set} when the ttl was successfully decreased.
     * {@link CacheDecreaseTtl.Miss} when the key does not exist.
     * {@link CacheDecreaseTtl.Error} on failure.
     */
    async decreaseTtl(cacheName, key, ttlMilliseconds) {
        const client = this.getNextDataClient();
        return await client.decreaseTtl(cacheName, key, ttlMilliseconds);
    }
    getNextDataClient() {
        const client = this.dataClients[this.nextDataClientIndex];
        this.nextDataClientIndex =
            (this.nextDataClientIndex + 1) % this.dataClients.length;
        return client;
    }
}
exports.AbstractCacheClient = AbstractCacheClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWJzdHJhY3RDYWNoZUNsaWVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9pbnRlcm5hbC9jbGllbnRzL2NhY2hlL0Fic3RyYWN0Q2FjaGVDbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsMENBMER3QjtBQXlCeEIsbURBQTZDO0FBRTdDLE1BQXNCLG1CQUFtQjtJQVN2QyxZQUNFLGFBQTZCLEVBQzdCLFdBQTBCLEVBQzFCLFVBQXdCO1FBRXhCLElBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDO1FBQ25DLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO1FBQy9CLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1FBRTdCLDRFQUE0RTtRQUM1RSx5RUFBeUU7UUFDekUsa0JBQWtCO1FBQ2xCLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVNLEtBQUssQ0FBQyxTQUFpQjtRQUM1QixPQUFPLElBQUksNEJBQVksQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVEOztPQUVHO0lBQ0ksS0FBSyxDQUFDLElBQUk7O1FBQ2YsT0FBTyxNQUFNLENBQUEsTUFBQSxJQUFJLENBQUMsVUFBVSwwQ0FBRSxJQUFJLEVBQUUsQ0FBQSxDQUFDO0lBQ3ZDLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLEtBQUssQ0FBQyxXQUFXLENBQUMsU0FBaUI7UUFDeEMsT0FBTyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksS0FBSyxDQUFDLFdBQVcsQ0FBQyxTQUFpQjtRQUN4QyxPQUFPLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJ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QUFDLFdBQVcsQ0FDdEIsU0FBaUIsRUFDakIsR0FBd0IsRUFDeEIsZUFBdUI7UUFFdkIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEMsT0FBTyxNQUFNLE1BQU0sQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRSxlQUFlLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLEtBQUssQ0FBQyxXQUFXLENBQ3RCLFNBQWlCLEVBQ2pCLEdBQXdCLEVBQ3hCLGVBQXVCO1FBRXZCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hDLE9BQU8sTUFBTSxNQUFNLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxHQUFHLEVBQUUsZUFBZSxDQUFDLENBQUM7SUFDbkUsQ0FBQztJQUVTLGlCQUFpQjtRQUN6QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQzFELElBQUksQ0FBQyxtQkFBbUI7WUFDdEIsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUM7UUFDM0QsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztDQUdGO0FBL3lDRCxrREEreUNDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ3JlYXRlQ2FjaGUsXG4gIERlbGV0ZUNhY2hlLFxuICBMaXN0Q2FjaGVzLFxuICBDYWNoZUZsdXNoLFxuICBDYWNoZUdldCxcbiAgQ2FjaGVTZXQsXG4gIENhY2hlRGVsZXRlLFxuICBDYWNoZUluY3JlbWVudCxcbiAgSW5jcmVtZW50T3B0aW9ucyxcbiAgQ2FjaGVTZXRJZk5vdEV4aXN0cyxcbiAgU2V0SWZOb3RFeGlzdHNPcHRpb25zLFxuICBDYWNoZVNldEZldGNoLFxuICBDYWNoZVNldEFkZEVsZW1lbnQsXG4gIENhY2hlU2V0QWRkRWxlbWVudHMsXG4gIENhY2hlU2V0UmVtb3ZlRWxlbWVudCxcbiAgQ2FjaGVTZXRSZW1vdmVFbGVtZW50cyxcbiAgQ2FjaGVMaXN0RmV0Y2gsXG4gIENhY2hlTGlzdExlbmd0aCxcbiAgQ2FjaGVMaXN0UHVzaEZyb250LFxuICBDYWNoZUxpc3RQdXNoQmFjayxcbiAgQ2FjaGVMaXN0Q29uY2F0ZW5hdGVCYWNrLFxuICBDYWNoZUxpc3RDb25jYXRlbmF0ZUZyb250LFxuICBDYWNoZUxpc3RQb3BCYWNrLFxuICBDYWNoZUxpc3RQb3BGcm9udCxcbiAgQ2FjaGVMaXN0UmVtb3ZlVmFsdWUsXG4gIENhY2hlTGlzdFJldGFpbixcbiAgQ2FjaGVEaWN0aW9uYXJ5U2V0RmllbGQsXG4gIENhY2hlRGljdGlvbmFyeVNldEZpZWxkcyxcbiAgQ2FjaGVEaWN0aW9uYXJ5R2V0RmllbGQsXG4gIENhY2hlRGljdGlvbmFyeUdldEZpZWxkcyxcbiAgQ2FjaGVEaWN0aW9uYXJ5SW5jcmVtZW50LFxuICBDYWNoZURpY3Rpb25hcnlGZXRjaCxcbiAgQ2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGQsXG4gIENhY2hlRGljdGlvbmFyeVJlbW92ZUZpZWxkcyxcbiAgQ2FjaGVEaWN0aW9uYXJ5TGVuZ3RoLFxuICBDYWNoZVNvcnRlZFNldEZldGNoLFxuICBDYWNoZVNvcnRlZFNldFB1dEVsZW1lbnQsXG4gIENhY2hlU29ydGVkU2V0UHV0RWxlbWVudHMsXG4gIENhY2hlU29ydGVkU2V0R2V0UmFuayxcbiAgQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZSxcbiAgQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZXMsXG4gIENhY2hlU29ydGVkU2V0SW5jcmVtZW50U2NvcmUsXG4gIENhY2hlU29ydGVkU2V0UmVtb3ZlRWxlbWVudCxcbiAgQ2FjaGVTb3J0ZWRTZXRSZW1vdmVFbGVtZW50cyxcbiAgQ2FjaGVTb3J0ZWRTZXRMZW5ndGgsXG4gIENhY2hlU29ydGVkU2V0TGVuZ3RoQnlTY29yZSxcbiAgU29ydGVkU2V0T3JkZXIsXG4gIENhY2hlSXRlbUdldFR0bCxcbiAgQ2FjaGVJdGVtR2V0VHlwZSxcbiAgQ2FjaGVLZXlFeGlzdHMsXG4gIENhY2hlS2V5c0V4aXN0LFxuICBDYWNoZVVwZGF0ZVR0bCxcbiAgQ2FjaGVJbmNyZWFzZVR0bCxcbiAgQ2FjaGVEZWNyZWFzZVR0bCxcbiAgR2V0QmF0Y2gsXG4gIFNldEJhdGNoLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbn0gZnJvbSAnLi4vLi4vLi4vaW5kZXgnO1xuaW1wb3J0IHtMaXN0RmV0Y2hDYWxsT3B0aW9ucywgTGlzdFJldGFpbkNhbGxPcHRpb25zfSBmcm9tICcuLi8uLi8uLi91dGlscyc7XG5pbXBvcnQge1xuICBJQ2FjaGVDbGllbnQsXG4gIFNldE9wdGlvbnMsXG4gIFNldEFkZEVsZW1lbnRPcHRpb25zLFxuICBTZXRBZGRFbGVtZW50c09wdGlvbnMsXG4gIExpc3RQdXNoRnJvbnRPcHRpb25zLFxuICBMaXN0UHVzaEJhY2tPcHRpb25zLFxuICBMaXN0Q29uY2F0ZW5hdGVCYWNrT3B0aW9ucyxcbiAgTGlzdENvbmNhdGVuYXRlRnJvbnRPcHRpb25zLFxuICBEaWN0aW9uYXJ5U2V0RmllbGRPcHRpb25zLFxuICBEaWN0aW9uYXJ5SW5jcmVtZW50T3B0aW9ucyxcbiAgU29ydGVkU2V0RmV0Y2hCeVJhbmtPcHRpb25zLFxuICBTb3J0ZWRTZXRQdXRFbGVtZW50T3B0aW9ucyxcbiAgU29ydGVkU2V0UHV0RWxlbWVudHNPcHRpb25zLFxuICBTb3J0ZWRTZXRGZXRjaEJ5U2NvcmVPcHRpb25zLFxuICBTb3J0ZWRTZXRJbmNyZW1lbnRPcHRpb25zLFxuICBTb3J0ZWRTZXRMZW5ndGhCeVNjb3JlT3B0aW9ucyxcbiAgU2V0QmF0Y2hPcHRpb25zLFxufSBmcm9tICcuLi8uLi8uLi9jbGllbnRzL0lDYWNoZUNsaWVudCc7XG5pbXBvcnQge0lDb250cm9sQ2xpZW50fSBmcm9tICcuL0lDb250cm9sQ2xpZW50JztcbmltcG9ydCB7SURhdGFDbGllbnR9IGZyb20gJy4vSURhdGFDbGllbnQnO1xuaW1wb3J0IHtJUGluZ0NsaWVudH0gZnJvbSAnLi9JUGluZ0NsaWVudCc7XG5pbXBvcnQge0lNb21lbnRvQ2FjaGV9IGZyb20gJy4uLy4uLy4uL2NsaWVudHMvSU1vbWVudG9DYWNoZSc7XG5pbXBvcnQge01vbWVudG9DYWNoZX0gZnJvbSAnLi9tb21lbnRvLWNhY2hlJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0Q2FjaGVDbGllbnQgaW1wbGVtZW50cyBJQ2FjaGVDbGllbnQge1xuICAvLyBtYWtpbmcgdGhlc2UgcHJvdGVjdGVkIHVudGlsIHdlIGZ1bGx5IGFic3RyYWN0IGF3YXkgdGhlIG5vZGVqcyBjbGllbnRcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGNvbnRyb2xDbGllbnQ6IElDb250cm9sQ2xpZW50O1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGF0YUNsaWVudHM6IElEYXRhQ2xpZW50W107XG4gIC8vIFRPRE86IE1ha2UgcGluZ0NsaWVudCByZXF1aXJlZCBpZiBhbmQgd2hlbiB0aGUgbm9kZWpzIHNpZGUgc3RhcnRzIGFkZGluZ1xuICAvLyAgb25lIGFzIHdlbGxcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHBpbmdDbGllbnQ/OiBJUGluZ0NsaWVudDtcbiAgcHJvdGVjdGVkIG5leHREYXRhQ2xpZW50SW5kZXg6IG51bWJlcjtcblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoXG4gICAgY29udHJvbENsaWVudDogSUNvbnRyb2xDbGllbnQsXG4gICAgZGF0YUNsaWVudHM6IElEYXRhQ2xpZW50W10sXG4gICAgcGluZ0NsaWVudD86IElQaW5nQ2xpZW50XG4gICkge1xuICAgIHRoaXMuY29udHJvbENsaWVudCA9IGNvbnRyb2xDbGllbnQ7XG4gICAgdGhpcy5kYXRhQ2xpZW50cyA9IGRhdGFDbGllbnRzO1xuICAgIHRoaXMucGluZ0NsaWVudCA9IHBpbmdDbGllbnQ7XG5cbiAgICAvLyBXZSByb3VuZC1yb2JpbiB0aGUgcmVxdWVzdHMgdGhyb3VnaCBhbGwgb2Ygb3VyIGNsaWVudHMuICBTaW5jZSBqYXZhc2NyaXB0XG4gICAgLy8gaXMgc2luZ2xlLXRocmVhZGVkLCB3ZSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IHRocmVhZCBzYWZldHkgb24gdGhpc1xuICAgIC8vIGluZGV4IHZhcmlhYmxlLlxuICAgIHRoaXMubmV4dERhdGFDbGllbnRJbmRleCA9IDA7XG4gIH1cblxuICBwdWJsaWMgY2FjaGUoY2FjaGVOYW1lOiBzdHJpbmcpOiBJTW9tZW50b0NhY2hlIHtcbiAgICByZXR1cm4gbmV3IE1vbWVudG9DYWNoZSh0aGlzLCBjYWNoZU5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBpbmcgdGhlIHNlcnZpY2UgdG8gdmVyaWZ5IGl0IGlzIHVwIGFuZCBydW5uaW5nXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcGluZygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5waW5nQ2xpZW50Py5waW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNhY2hlIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIGJlIGNyZWF0ZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENyZWF0ZUNhY2hlLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ3JlYXRlQ2FjaGUuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENyZWF0ZUNhY2hlLkFscmVhZHlFeGlzdHN9IGlmIHRoZSBjYWNoZSBhbHJlYWR5IGV4aXN0cy5cbiAgICoge0BsaW5rIENyZWF0ZUNhY2hlLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNyZWF0ZUNhY2hlKGNhY2hlTmFtZTogc3RyaW5nKTogUHJvbWlzZTxDcmVhdGVDYWNoZS5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyb2xDbGllbnQuY3JlYXRlQ2FjaGUoY2FjaGVOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgY2FjaGUgYW5kIGFsbCBpdGVtcyBzdG9yZWQgaW4gaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gZGVsZXRlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxEZWxldGVDYWNoZS5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIERlbGV0ZUNhY2hlLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBEZWxldGVDYWNoZS5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkZWxldGVDYWNoZShjYWNoZU5hbWU6IHN0cmluZyk6IFByb21pc2U8RGVsZXRlQ2FjaGUuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cm9sQ2xpZW50LmRlbGV0ZUNhY2hlKGNhY2hlTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdHMgYWxsIGNhY2hlcy5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TGlzdENhY2hlcy5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIExpc3RDYWNoZXMuU3VjY2Vzc30gY29udGFpbmluZyB0aGUgbGlzdCBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgTGlzdENhY2hlcy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0Q2FjaGVzKCk6IFByb21pc2U8TGlzdENhY2hlcy5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyb2xDbGllbnQubGlzdENhY2hlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIHN0b3JlZCBmb3IgdGhlIGdpdmVuIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBwZXJmb3JtIHRoZSBsb29rdXAgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0ga2V5IC0gVGhlIGtleSB0byBsb29rIHVwLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUdldC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlR2V0LkhpdH0gY29udGFpbmluZyB0aGUgdmFsdWUgaWYgb25lIGlzIGZvdW5kLlxuICAgKiB7QGxpbmsgQ2FjaGVHZXQuTWlzc30gaWYgdGhlIGtleSBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlR2V0LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXlcbiAgKTogUHJvbWlzZTxDYWNoZUdldC5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldE5leHREYXRhQ2xpZW50KCkuZ2V0KGNhY2hlTmFtZSwga2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NvY2lhdGVzIHRoZSBnaXZlbiBrZXkgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuIElmIGEgdmFsdWUgZm9yIHRoZSBrZXkgaXNcbiAgICogYWxyZWFkeSBwcmVzZW50IGl0IGlzIHJlcGxhY2VkIHdpdGggdGhlIG5ldyB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBzdG9yZSB0aGUgdmFsdWUgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0ga2V5IC0gVGhlIGtleSB0byBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgc3RvcmVkLlxuICAgKiBAcGFyYW0ge1NldE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudHRsXSAtIFRoZSB0aW1lIHRvIGxpdmUgZm9yIHRoZSBpdGVtIGluIHRoZSBjYWNoZS5cbiAgICogVXNlcyB0aGUgY2xpZW50J3MgZGVmYXVsdCBUVEwgaWYgdGhpcyBpcyBub3Qgc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU2V0LlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTZXQuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlU2V0LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNldChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgdmFsdWU6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgb3B0aW9ucz86IFNldE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZVNldC5SZXNwb25zZT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgJ09wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCBhIHR0bCBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zZXQoY2FjaGVOYW1lLCBrZXksIHZhbHVlLCBvcHRpb25zPy50dGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIGtleSBmcm9tIHRoZSBjYWNoZS4gVGhlIGtleSBjYW4gcmVwcmVzZW50IGEgc2luZ2xlIHZhbHVlXG4gICAqIG9yIGEgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBkZWxldGUgZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBrZXkgLSBUaGUga2V5IHRvIGRlbGV0ZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVEZWxldGUuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZURlbGV0ZS5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVEZWxldGUuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVsZXRlKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGtleTogc3RyaW5nIHwgVWludDhBcnJheVxuICApOiBQcm9taXNlPENhY2hlRGVsZXRlLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuZGVsZXRlKGNhY2hlTmFtZSwga2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBzdG9yZWQgZm9yIHRoZSBnaXZlbiBrZXlzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHBlcmZvcm0gdGhlIGxvb2t1cCBpbi5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXX0ga2V5cyAtIFRoZSBsaXN0IG9mIGtleXMgdG8gbG9vayB1cC5cbiAgICogQHJldHVybnMge1Byb21pc2U8R2V0QmF0Y2guUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBHZXRCYXRjaC5TdWNjZXNzfSBjb250YWluaW5nIHRoZSB2YWx1ZXMgaWYgdGhleSB3ZXJlIGZvdW5kLlxuICAgKiB7QGxpbmsgR2V0QmF0Y2guRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0QmF0Y2goXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5czogQXJyYXk8c3RyaW5nIHwgVWludDhBcnJheT5cbiAgKTogUHJvbWlzZTxHZXRCYXRjaC5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldE5leHREYXRhQ2xpZW50KCkuZ2V0QmF0Y2goY2FjaGVOYW1lLCBrZXlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NvY2lhdGVzIHRoZSBnaXZlbiBrZXlzIHdpdGggdGhlIGdpdmVuIHZhbHVlcy4gSWYgYSB2YWx1ZSBmb3IgdGhlIGtleSBpc1xuICAgKiBhbHJlYWR5IHByZXNlbnQgaXQgaXMgcmVwbGFjZWQgd2l0aCB0aGUgbmV3IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSB2YWx1ZXMgaW4uXG4gICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgVWludDhBcnJheT4gfCBNYXA8c3RyaW5nIHwgVWludDhBcnJheSwgc3RyaW5nIHwgVWludDhBcnJheT59IGl0ZW1zIC0gVGhlIGtleS12YWx1ZSBwYWlycyB0byBiZSBzdG9yZWQuXG4gICAqIEBwYXJhbSB7U2V0T3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50dGxdIC0gVGhlIHRpbWUgdG8gbGl2ZSBmb3IgdGhlIGl0ZW1zIGluIHRoZSBjYWNoZS5cbiAgICogVXNlcyB0aGUgY2xpZW50J3MgZGVmYXVsdCBUVEwgaWYgdGhpcyBpcyBub3Qgc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU2V0LlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgU2V0QmF0Y2guU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIFNldEJhdGNoLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNldEJhdGNoKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGl0ZW1zOlxuICAgICAgfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBVaW50OEFycmF5PlxuICAgICAgfCBNYXA8c3RyaW5nIHwgVWludDhBcnJheSwgc3RyaW5nIHwgVWludDhBcnJheT4sXG4gICAgb3B0aW9ucz86IFNldEJhdGNoT3B0aW9uc1xuICApOiBQcm9taXNlPFNldEJhdGNoLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc2V0QmF0Y2goY2FjaGVOYW1lLCBpdGVtcywgb3B0aW9ucz8udHRsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG11bHRpcGxlIGVsZW1lbnRzIHRvIHRoZSBiYWNrIG9mIHRoZSBnaXZlbiBsaXN0LiBDcmVhdGVzIHRoZSBsaXN0IGlmXG4gICAqIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gc3RvcmUgdGhlIGxpc3QgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0TmFtZSAtIFRoZSBsaXN0IHRvIGFkZCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXX0gdmFsdWVzIC0gVGhlIGVsZW1lbnRzIHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtMaXN0Q29uY2F0ZW5hdGVCYWNrT3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50cnVuY2F0ZUZyb250VG9TaXplXSAtIElmIHRoZSBsaXN0IGV4Y2VlZHMgdGhpc1xuICAgKiBsZW5ndGgsIHJlbW92ZSBleGNlc3MgZnJvbSB0aGUgZnJvbnQgb2YgdGhlIGxpc3QuIE11c3QgYmUgcG9zaXRpdmUuXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIGxpc3QncyBUVEwgdXNpbmcgdGhlIGNsaWVudCdzIGRlZmF1bHQgaWYgdGhpcyBpcyBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlTGlzdENvbmNhdGVuYXRlQmFjay5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlTGlzdENvbmNhdGVuYXRlQmFjay5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0Q29uY2F0ZW5hdGVCYWNrLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RDb25jYXRlbmF0ZUJhY2soXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZXM6IHN0cmluZ1tdIHwgVWludDhBcnJheVtdLFxuICAgIG9wdGlvbnM/OiBMaXN0Q29uY2F0ZW5hdGVCYWNrT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlTGlzdENvbmNhdGVuYXRlQmFjay5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50Lmxpc3RDb25jYXRlbmF0ZUJhY2soXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBsaXN0TmFtZSxcbiAgICAgIHZhbHVlcyxcbiAgICAgIG9wdGlvbnM/LnRydW5jYXRlRnJvbnRUb1NpemUsXG4gICAgICBvcHRpb25zPy50dGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgbXVsdGlwbGUgZWxlbWVudHMgdG8gdGhlIGZyb250IG9mIHRoZSBnaXZlbiBsaXN0LiBDcmVhdGVzIHRoZSBsaXN0IGlmXG4gICAqIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gc3RvcmUgdGhlIGxpc3QgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0TmFtZSAtIFRoZSBsaXN0IHRvIGFkZCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXX0gdmFsdWVzIC0gVGhlIGVsZW1lbnRzIHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtMaXN0Q29uY2F0ZW5hdGVGcm9udE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudHJ1bmNhdGVCYWNrVG9TaXplXSAtIElmIHRoZSBsaXN0IGV4Y2VlZHMgdGhpc1xuICAgKiBsZW5ndGgsIHJlbW92ZSBleGNlc3MgZnJvbSB0aGUgYmFjayBvZiB0aGUgbGlzdC4gTXVzdCBiZSBwb3NpdGl2ZS5cbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uVHRsfSBbb3B0aW9ucy50dGxdIC0gSG93IHRoZSBUVEwgc2hvdWxkIGJlIG1hbmFnZWQuXG4gICAqIFJlZnJlc2hlcyB0aGUgbGlzdCdzIFRUTCB1c2luZyB0aGUgY2xpZW50J3MgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdFxuICAgKiBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVMaXN0Q29uY2F0ZW5hdGVGcm9udC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlTGlzdENvbmNhdGVuYXRlRnJvbnQuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlTGlzdENvbmNhdGVuYXRlRnJvbnQuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdENvbmNhdGVuYXRlRnJvbnQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZXM6IHN0cmluZ1tdIHwgVWludDhBcnJheVtdLFxuICAgIG9wdGlvbnM/OiBMaXN0Q29uY2F0ZW5hdGVGcm9udE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZUxpc3RDb25jYXRlbmF0ZUZyb250LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdENvbmNhdGVuYXRlRnJvbnQoXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBsaXN0TmFtZSxcbiAgICAgIHZhbHVlcyxcbiAgICAgIG9wdGlvbnM/LnRydW5jYXRlQmFja1RvU2l6ZSxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhbGwgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpc3ROYW1lIC0gVGhlIGxpc3QgdG8gZmV0Y2guXG4gICAqIEBwYXJhbSB7TGlzdEZldGNoQ2FsbE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RhcnRJbmRleF0gLSBTdGFydCBpbmNsdXNpdmUgaW5kZXggZm9yIGZldGNoIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmVuZEluZGV4XSAtIEVuZCBleGNsdXNpdmUgaW5kZXggZm9yIGZldGNoIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVMaXN0RmV0Y2guUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RGZXRjaC5IaXR9IGNvbnRhaW5pbmcgdGhlIGxpc3QgZWxlbWVudHMgaWYgdGhlIGxpc3QgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0RmV0Y2guTWlzc30gaWYgdGhlIGxpc3QgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZUxpc3RGZXRjaC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0RmV0Y2goXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZyxcbiAgICBvcHRpb25zPzogTGlzdEZldGNoQ2FsbE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZUxpc3RGZXRjaC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50Lmxpc3RGZXRjaChcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGxpc3ROYW1lLFxuICAgICAgb3B0aW9ucz8uc3RhcnRJbmRleCxcbiAgICAgIG9wdGlvbnM/LmVuZEluZGV4XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpc3ROYW1lIC0gVGhlIGxpc3QgdG8gZ2V0IHRoZSBsZW5ndGggb2YuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlTGlzdExlbmd0aC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlTGlzdExlbmd0aC5IaXR9IGNvbnRhaW5pbmcgdGhlIGxlbmd0aCBpZiB0aGUgbGlzdCBleGlzdHMuXG4gICAqIHtAbGluayBDYWNoZUxpc3RMZW5ndGguTWlzc30gaWYgdGhlIGxpc3QgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZUxpc3RMZW5ndGguRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdExlbmd0aChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBsaXN0TmFtZTogc3RyaW5nXG4gICk6IFByb21pc2U8Q2FjaGVMaXN0TGVuZ3RoLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdExlbmd0aChjYWNoZU5hbWUsIGxpc3ROYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCByZW1vdmVzIHRoZSBsYXN0IHZhbHVlIGZyb20gdGhlIGdpdmVuIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxpc3ROYW1lIC0gVGhlIGxpc3QgdG8gcG9wLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUxpc3RQb3BCYWNrLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0UG9wQmFjay5IaXR9IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnQgaWYgdGhlIGxpc3QgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0UG9wQmFjay5NaXNzfSBpZiB0aGUgbGlzdCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlTGlzdFBvcEJhY2suRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdFBvcEJhY2soXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZ1xuICApOiBQcm9taXNlPENhY2hlTGlzdFBvcEJhY2suUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5saXN0UG9wQmFjayhjYWNoZU5hbWUsIGxpc3ROYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCByZW1vdmVzIHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGxpc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0TmFtZSAtIFRoZSBsaXN0IHRvIHBvcC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVMaXN0UG9wRnJvbnQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RQb3BGcm9udC5IaXR9IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnQgaWYgdGhlIGxpc3QgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0UG9wRnJvbnQuTWlzc30gaWYgdGhlIGxpc3QgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZUxpc3RQb3BGcm9udC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0UG9wRnJvbnQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZ1xuICApOiBQcm9taXNlPENhY2hlTGlzdFBvcEZyb250LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdFBvcEZyb250KGNhY2hlTmFtZSwgbGlzdE5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgYmFjayBvZiB0aGUgZ2l2ZW4gbGlzdC4gQ3JlYXRlcyB0aGUgbGlzdCBpZlxuICAgKiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSBsaXN0IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGlzdE5hbWUgLSBUaGUgbGlzdCB0byBwdXNoIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHB1c2guXG4gICAqIEBwYXJhbSB7TGlzdFB1c2hCYWNrT3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50cnVuY2F0ZUZyb250VG9TaXplXSAtIElmIHRoZSBsaXN0IGV4Y2VlZHMgdGhpc1xuICAgKiBsZW5ndGgsIHJlbW92ZSBleGNlc3MgZnJvbSB0aGUgZnJvbnQgb2YgdGhlIGxpc3QuIE11c3QgYmUgcG9zaXRpdmUuXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIGxpc3QncyBUVEwgdXNpbmcgdGhlIGNsaWVudCdzIGRlZmF1bHQgaWYgdGhpcyBpcyBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlTGlzdFB1c2hCYWNrLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVMaXN0UHVzaEJhY2suU3VjY2Vzc30gY29udGFpbmluZyB0aGUgbGlzdCdzIG5ldyBsZW5ndGggb25cbiAgICogc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlTGlzdFB1c2hCYWNrLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGxpc3RQdXNoQmFjayhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBsaXN0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBMaXN0UHVzaEJhY2tPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVMaXN0UHVzaEJhY2suUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5saXN0UHVzaEJhY2soXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBsaXN0TmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgb3B0aW9ucz8udHJ1bmNhdGVGcm9udFRvU2l6ZSxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBmcm9udCBvZiB0aGUgZ2l2ZW4gbGlzdC4gQ3JlYXRlcyB0aGUgbGlzdCBpZlxuICAgKiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSBsaXN0IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGlzdE5hbWUgLSBUaGUgbGlzdCB0byBwdXNoIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHB1c2guXG4gICAqIEBwYXJhbSB7TGlzdFB1c2hGcm9udE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudHJ1bmNhdGVCYWNrVG9TaXplXSAtIElmIHRoZSBsaXN0IGV4Y2VlZHMgdGhpc1xuICAgKiBsZW5ndGgsIHJlbW92ZSBleGNlc3MgZnJvbSB0aGUgZW5kIG9mIHRoZSBsaXN0LiBNdXN0IGJlIHBvc2l0aXZlLlxuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBsaXN0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUxpc3RQdXNoRnJvbnQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RQdXNoRnJvbnQuU3VjY2Vzc30gY29udGFpbmluZyB0aGUgbGlzdCdzIG5ldyBsZW5ndGggb25cbiAgICogc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlTGlzdFB1c2hGcm9udC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0UHVzaEZyb250KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGxpc3ROYW1lOiBzdHJpbmcsXG4gICAgdmFsdWU6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgb3B0aW9ucz86IExpc3RQdXNoRnJvbnRPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVMaXN0UHVzaEZyb250LlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdFB1c2hGcm9udChcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGxpc3ROYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICBvcHRpb25zPy50cnVuY2F0ZUJhY2tUb1NpemUsXG4gICAgICBvcHRpb25zPy50dGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhlIGdpdmVuIGxpc3QgZXF1YWwgdG8gdGhlIGdpdmVuIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGxpc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0TmFtZSAtIFRoZSBsaXN0IHRvIHJlbW92ZSBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVMaXN0UmVtb3ZlVmFsdWUuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RSZW1vdmVWYWx1ZS5TdWNjZXNzfSBvbiBzdWNjZXNzLiBSZW1vdmluZyBhbiBlbGVtZW50IHRoYXRcbiAgICogZG9lcyBub3Qgb2NjdXIgaW4gdGhlIGxpc3Qgb3IgcmVtb3ZpbmcgZnJvbSBhIG5vbi1leGlzdGVudCBsaXN0IGNvdW50cyBhcyBhXG4gICAqIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZUxpc3RSZW1vdmVWYWx1ZS5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0UmVtb3ZlVmFsdWUoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGlzdE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nIHwgVWludDhBcnJheVxuICApOiBQcm9taXNlPENhY2hlTGlzdFJlbW92ZVZhbHVlLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQubGlzdFJlbW92ZVZhbHVlKGNhY2hlTmFtZSwgbGlzdE5hbWUsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRhaW5zIHNsaWNlIG9mIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gbGlzdCwgZGVsZXRlcyB0aGUgcmVzdCBvZiB0aGUgbGlzdFxuICAgKiB0aGF0IGlzbid0IGJlaW5nIHJldGFpbmVkLiBSZXR1cm5zIGEgU3VjY2VzcyBvciBFcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGlzdE5hbWUgLSBUaGUgbGlzdCB0byByZXRhaW4gYSBzbGljZSBvZi5cbiAgICogQHBhcmFtIHtMaXN0UmV0YWluQ2FsbE9wdGlvbnN9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RhcnRJbmRleF0gLSBTdGFydCBpbmNsdXNpdmUgaW5kZXggZm9yIGZldGNoXG4gICAqIG9wZXJhdGlvbi4gRGVmYXVsdHMgdG8gc3RhcnQgb2YgYXJyYXkgaWYgbm90IGdpdmVuLCAwLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZW5kSW5kZXhdIC0gRW5kIGV4Y2x1c2l2ZSBpbmRleCBmb3IgZmV0Y2hcbiAgICogb3BlcmF0aW9uLiBEZWZhdWx0cyB0byBlbmQgb2YgYXJyYXkgaWYgbm90IGdpdmVuLlxuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBsaXN0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUxpc3RSZXRhaW4uUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZUxpc3RSZXRhaW4uU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlTGlzdFJldGFpbi5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsaXN0UmV0YWluKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGxpc3ROYW1lOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IExpc3RSZXRhaW5DYWxsT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlTGlzdFJldGFpbi5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50Lmxpc3RSZXRhaW4oXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBsaXN0TmFtZSxcbiAgICAgIG9wdGlvbnM/LnN0YXJ0SW5kZXgsXG4gICAgICBvcHRpb25zPy5lbmRJbmRleCxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhbGwgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHNldFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNldE5hbWUgLSBUaGUgc2V0IHRvIGZldGNoLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldEZldGNoLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTZXRGZXRjaC5IaXR9IGNvbnRhaW5pbmcgdGhlIHNldCBlbGVtZW50cyBpZiB0aGUgc2V0IGV4aXN0cy5cbiAgICoge0BsaW5rIENhY2hlU2V0RmV0Y2guTWlzc30gaWYgdGhlIHNldCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlU2V0RmV0Y2guRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2V0RmV0Y2goXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc2V0TmFtZTogc3RyaW5nXG4gICk6IFByb21pc2U8Q2FjaGVTZXRGZXRjaC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNldEZldGNoKGNhY2hlTmFtZSwgc2V0TmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBnaXZlbiBzZXQuIENyZWF0ZXMgdGhlIHNldCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5XG4gICAqIGV4aXN0LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBBZnRlciB0aGlzIG9wZXJhdGlvbiB0aGUgc2V0IHdpbGwgY29udGFpbiB0aGUgdW5pb24gb2YgdGhlIGVsZW1lbnQgcGFzc2VkXG4gICAqIGluIGFuZCB0aGUgb3JpZ2luYWwgZWxlbWVudHMgb2YgdGhlIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBzdG9yZSB0aGUgc2V0IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2V0TmFtZSAtIFRoZSBzZXQgdG8gYWRkIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBhZGQuXG4gICAqIEBwYXJhbSB7U2V0QWRkRWxlbWVudE9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uVHRsfSBbb3B0aW9ucy50dGxdIC0gSG93IHRoZSBUVEwgc2hvdWxkIGJlIG1hbmFnZWQuXG4gICAqIFJlZnJlc2hlcyB0aGUgc2V0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90IHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNldEFkZEVsZW1lbnQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZVNldEFkZEVsZW1lbnQuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlU2V0QWRkRWxlbWVudC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzZXRBZGRFbGVtZW50KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNldE5hbWU6IHN0cmluZyxcbiAgICBlbGVtZW50OiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBTZXRBZGRFbGVtZW50T3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU2V0QWRkRWxlbWVudC5SZXNwb25zZT4ge1xuICAgIHJldHVybiAoXG4gICAgICBhd2FpdCB0aGlzLnNldEFkZEVsZW1lbnRzKFxuICAgICAgICBjYWNoZU5hbWUsXG4gICAgICAgIHNldE5hbWUsXG4gICAgICAgIFtlbGVtZW50XSBhcyBzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKVxuICAgICkudG9TaW5ndWxhclJlc3BvbnNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBtdWx0aXBsZSBlbGVtZW50cyB0byB0aGUgZ2l2ZW4gc2V0LiBDcmVhdGVzIHRoZSBzZXQgaWYgaXQgZG9lcyBub3RcbiAgICogYWxyZWFkeSBleGlzdC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogQWZ0ZXIgdGhpcyBvcGVyYXRpb24sIHRoZSBzZXQgd2lsbCBjb250YWluIHRoZSB1bmlvbiBvZiB0aGUgZWxlbWVudHMgcGFzc2VkXG4gICAqIGluIGFuZCB0aGUgb3JpZ2luYWwgZWxlbWVudHMgb2YgdGhlIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBzdG9yZSB0aGUgc2V0IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2V0TmFtZSAtIFRoZSBzZXQgdG8gYWRkIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgVWludDhBcnJheVtdfSBlbGVtZW50cyAtIFRoZSBlbGVtZW50cyB0byBhZGQuXG4gICAqIEBwYXJhbSB7U2V0QWRkRWxlbWVudHNPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIHNldCdzIFRUTCB1c2luZyB0aGUgY2xpZW50J3MgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdCBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTZXRBZGRFbGVtZW50cy5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU2V0QWRkRWxlbWVudHMuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlU2V0QWRkRWxlbWVudHMuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2V0QWRkRWxlbWVudHMoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc2V0TmFtZTogc3RyaW5nLFxuICAgIGVsZW1lbnRzOiBzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXSxcbiAgICBvcHRpb25zPzogU2V0QWRkRWxlbWVudHNPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVTZXRBZGRFbGVtZW50cy5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNldEFkZEVsZW1lbnRzKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgc2V0TmFtZSxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgb3B0aW9ucz8udHRsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNldE5hbWUgLSBUaGUgc2V0IHRvIHJlbW92ZSBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU2V0UmVtb3ZlRWxlbWVudC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU2V0UmVtb3ZlRWxlbWVudC5TdWNjZXNzfSBvbiBzdWNjZXNzLiBSZW1vdmluZyBhbiBlbGVtZW50IHRoYXRcbiAgICogZG9lcyBub3Qgb2NjdXIgaW4gdGhlIHNldCBvciByZW1vdmluZyBmcm9tIGEgbm9uLWV4aXN0ZW50IHNldCBjb3VudHMgYXMgYVxuICAgKiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRSZW1vdmVFbGVtZW50LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNldFJlbW92ZUVsZW1lbnQoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc2V0TmFtZTogc3RyaW5nLFxuICAgIGVsZW1lbnQ6IHN0cmluZyB8IFVpbnQ4QXJyYXlcbiAgKTogUHJvbWlzZTxDYWNoZVNldFJlbW92ZUVsZW1lbnQuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gKFxuICAgICAgYXdhaXQgdGhpcy5zZXRSZW1vdmVFbGVtZW50cyhjYWNoZU5hbWUsIHNldE5hbWUsIFtlbGVtZW50XSBhc1xuICAgICAgICB8IHN0cmluZ1tdXG4gICAgICAgIHwgVWludDhBcnJheVtdKVxuICAgICkudG9TaW5ndWxhclJlc3BvbnNlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBtdWx0aXBsZSBlbGVtZW50cyBmcm9tIHRoZSBnaXZlbiBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2V0TmFtZSAtIFRoZSBzZXQgdG8gcmVtb3ZlIGZyb20uXG4gICAqIEBwYXJhbSB7c3RyaW5nW10gfCBVaW50OEFycmF5W119IGVsZW1lbnRzIC0gVGhlIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTZXRSZW1vdmVFbGVtZW50cy5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU2V0UmVtb3ZlRWxlbWVudHMuU3VjY2Vzc30gb24gc3VjY2Vzcy4gUmVtb3ZpbmcgZWxlbWVudHMgdGhhdFxuICAgKiBkbyBub3Qgb2NjdXIgaW4gdGhlIHNldCBvciByZW1vdmluZyBmcm9tIGEgbm9uLWV4aXN0ZW50IHNldCBjb3VudHMgYXMgYVxuICAgKiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVTZXRSZW1vdmVFbGVtZW50cy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzZXRSZW1vdmVFbGVtZW50cyhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzZXROYW1lOiBzdHJpbmcsXG4gICAgZWxlbWVudHM6IHN0cmluZ1tdIHwgVWludDhBcnJheVtdXG4gICk6IFByb21pc2U8Q2FjaGVTZXRSZW1vdmVFbGVtZW50cy5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNldFJlbW92ZUVsZW1lbnRzKGNhY2hlTmFtZSwgc2V0TmFtZSwgZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc29jaWF0ZXMgdGhlIGdpdmVuIGtleSB3aXRoIHRoZSBnaXZlbiB2YWx1ZS4gSWYgYSB2YWx1ZSBmb3IgdGhlIGtleSBpc1xuICAgKiBhbHJlYWR5IHByZXNlbnQgaXQgaXMgbm90IHJlcGxhY2VkIHdpdGggdGhlIG5ldyB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBzdG9yZSB0aGUgdmFsdWUgaW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0ga2V5IC0gVGhlIGtleSB0byBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gZmllbGQgLSBUaGUgdmFsdWUgdG8gYmUgc3RvcmVkLlxuICAgKiBAcGFyYW0ge1NldElmTm90RXhpc3RzT3B0aW9uc30gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50dGxdIC0gVGhlIHRpbWUgdG8gbGl2ZSBmb3IgdGhlIGl0ZW0gaW4gdGhlIGNhY2hlLlxuICAgKiBVc2VzIHRoZSBjbGllbnQncyBkZWZhdWx0IFRUTCBpZiB0aGlzIGlzIG5vdCBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTZXRJZk5vdEV4aXN0cy5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU2V0SWZOb3RFeGlzdHMuU3RvcmVkfSBvbiBzdG9yaW5nIHRoZSBuZXcgdmFsdWUuXG4gICAqIHtAbGluayBDYWNoZVNldElmTm90RXhpc3RzLk5vdFN0b3JlZH0gb24gbm90IHN0b3JpbmcgdGhlIG5ldyB2YWx1ZS5cbiAgICoge0BsaW5rIENhY2hlU2V0SWZOb3RFeGlzdHMuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2V0SWZOb3RFeGlzdHMoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIGZpZWxkOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBTZXRJZk5vdEV4aXN0c09wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZVNldElmTm90RXhpc3RzLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc2V0SWZOb3RFeGlzdHMoY2FjaGVOYW1lLCBrZXksIGZpZWxkLCBvcHRpb25zPy50dGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoZXMgLyBjbGVhcnMgYWxsIHRoZSBpdGVtcyBvZiB0aGUgZ2l2ZW4gY2FjaGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBiZSBmbHVzaGVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUZsdXNoLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVGbHVzaC5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVGbHVzaC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBmbHVzaENhY2hlKGNhY2hlTmFtZTogc3RyaW5nKTogUHJvbWlzZTxDYWNoZUZsdXNoLlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY29udHJvbENsaWVudC5mbHVzaENhY2hlKGNhY2hlTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhbGwgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGRpY3Rpb25hcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gcGVyZm9ybSB0aGUgbG9va3VwIGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGljdGlvbmFyeU5hbWUgLSBUaGUgZGljdGlvbmFyeSB0byBmZXRjaC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVEaWN0aW9uYXJ5RmV0Y2guUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlGZXRjaC5IaXR9IGNvbnRhaW5pbmcgdGhlIGRpY3Rpb25hcnkgZWxlbWVudHMgaWYgdGhlXG4gICAqIGRpY3Rpb25hcnkgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5RmV0Y2guTWlzc30gaWYgdGhlIGRpY3Rpb25hcnkgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlGZXRjaC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkaWN0aW9uYXJ5RmV0Y2goXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgZGljdGlvbmFyeU5hbWU6IHN0cmluZ1xuICApOiBQcm9taXNlPENhY2hlRGljdGlvbmFyeUZldGNoLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuZGljdGlvbmFyeUZldGNoKGNhY2hlTmFtZSwgZGljdGlvbmFyeU5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gaW50ZWdlciBxdWFudGl0eSB0byBhIGZpZWxkIHZhbHVlLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBJbmNyZW1lbnRpbmcgdGhlIHZhbHVlIG9mIGEgbWlzc2luZyBmaWVsZCBzZXRzIHRoZSB2YWx1ZSB0byBhbW91bnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgZmllbGQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gZmllbGQgLSBUaGUgZmllbGQgdG8gaW5jcmVtZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gVGhlIHF1YW50aXR5IHRvIGFkZCB0byB0aGUgdmFsdWUuIE1heSBiZSBwb3NpdGl2ZSxcbiAgICogbmVnYXRpdmUsIG9yIHplcm8uIERlZmF1bHRzIHRvIDEuXG4gICAqIEBwYXJhbSB7SW5jcmVtZW50T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVJbmNyZW1lbnQ+fSAtXG4gICAqIHtAbGluayBDYWNoZUluY3JlbWVudC5TdWNjZXNzfSBjb250YWluaW5nIHRoZSBpbmNyZW1lbnRlZCB2YWx1ZVxuICAgKiBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVJbmNyZW1lbnQuRXJyb3J9IG9uIGZhaWx1cmUuIEluY3JlbWVudGluZyBhIHZhbHVlXG4gICAqIHRoYXQgd2FzIG5vdCBzZXQgdXNpbmcgdGhpcyBtZXRob2Qgb3IgaXMgbm90IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2ZcbiAgICogYW4gaW50ZWdlciByZXN1bHRzIGluIGEgZmFpbHVyZSB3aXRoIGEgRmFpbGVkUHJlY29uZGl0aW9uRXhjZXB0aW9uIGVycm9yLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGluY3JlbWVudChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBmaWVsZDogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBhbW91bnQgPSAxLFxuICAgIG9wdGlvbnM/OiBJbmNyZW1lbnRPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVJbmNyZW1lbnQuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5pbmNyZW1lbnQoY2FjaGVOYW1lLCBmaWVsZCwgYW1vdW50LCBvcHRpb25zPy50dGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZWxlbWVudCB0byB0aGUgZ2l2ZW4gZGljdGlvbmFyeS4gQ3JlYXRlcyB0aGUgZGljdGlvbmFyeSBpZiBpdCBkb2VzXG4gICAqIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSBkaWN0aW9uYXJ5IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGljdGlvbmFyeU5hbWUgLSBUaGUgZGljdGlvbmFyeSB0byBhZGQgdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gZmllbGQgLSBUaGUgZmllbGQgdG8gc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHN0b3JlLlxuICAgKiBAcGFyYW0ge0RpY3Rpb25hcnlTZXRGaWVsZE9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uVHRsfSBbb3B0aW9ucy50dGxdIC0gSG93IHRoZSBUVEwgc2hvdWxkIGJlIG1hbmFnZWQuXG4gICAqIFJlZnJlc2hlcyB0aGUgZGljdGlvbmFyeSdzIFRUTCB1c2luZyB0aGUgY2xpZW50J3MgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdFxuICAgKiBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVEaWN0aW9uYXJ5U2V0RmllbGQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlTZXRGaWVsZC5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5U2V0RmllbGQuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGljdGlvbmFyeVNldEZpZWxkKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGRpY3Rpb25hcnlOYW1lOiBzdHJpbmcsXG4gICAgZmllbGQ6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgdmFsdWU6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgb3B0aW9ucz86IERpY3Rpb25hcnlTZXRGaWVsZE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZURpY3Rpb25hcnlTZXRGaWVsZC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmRpY3Rpb25hcnlTZXRGaWVsZChcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGRpY3Rpb25hcnlOYW1lLFxuICAgICAgZmllbGQsXG4gICAgICB2YWx1ZSxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBtdWx0aXBsZSBlbGVtZW50cyB0byB0aGUgZ2l2ZW4gZGljdGlvbmFyeS4gQ3JlYXRlcyB0aGUgZGljdGlvbmFyeSBpZlxuICAgKiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIHRvIHN0b3JlIHRoZSBkaWN0aW9uYXJ5IGluLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGljdGlvbmFyeU5hbWUgLSBUaGUgZGljdGlvbmFyeSB0byBhZGQgdG8uXG4gICAqIEBwYXJhbSB7TWFwPHN0cmluZyB8IFVpbnQ4QXJyYXksIHN0cmluZyB8IFVpbnQ4QXJyYXk+fSBlbGVtZW50cyAtIFRoZVxuICAgKiBlbGVtZW50cyB0byBzZXQuXG4gICAqIEBwYXJhbSB7RGljdGlvbmFyeVNldEZpZWxkc09wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uVHRsfSBbb3B0aW9ucy50dGxdIC0gSG93IHRoZSBUVEwgc2hvdWxkIGJlIG1hbmFnZWQuXG4gICAqIFJlZnJlc2hlcyB0aGUgZGljdGlvbmFyeSdzIFRUTCB1c2luZyB0aGUgY2xpZW50J3MgZGVmYXVsdCBpZiB0aGlzIGlzIG5vdFxuICAgKiBzdXBwbGllZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVEaWN0aW9uYXJ5U2V0RmllbGRzLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5U2V0RmllbGRzLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlTZXRGaWVsZHMuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGljdGlvbmFyeVNldEZpZWxkcyhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBkaWN0aW9uYXJ5TmFtZTogc3RyaW5nLFxuICAgIGVsZW1lbnRzOlxuICAgICAgfCBNYXA8c3RyaW5nIHwgVWludDhBcnJheSwgc3RyaW5nIHwgVWludDhBcnJheT5cbiAgICAgIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgVWludDhBcnJheT5cbiAgICAgIHwgQXJyYXk8W3N0cmluZywgc3RyaW5nIHwgVWludDhBcnJheV0+LFxuICAgIG9wdGlvbnM/OiBEaWN0aW9uYXJ5U2V0RmllbGRPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVEaWN0aW9uYXJ5U2V0RmllbGRzLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuZGljdGlvbmFyeVNldEZpZWxkcyhcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGRpY3Rpb25hcnlOYW1lLFxuICAgICAgZWxlbWVudHMsXG4gICAgICBvcHRpb25zPy50dGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIHN0b3JlZCBmb3IgdGhlIGdpdmVuIGRpY3Rpb25hcnkgYW5kIGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGRpY3Rpb25hcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWN0aW9uYXJ5TmFtZSAtIFRoZSBkaWN0aW9uYXJ5IHRvIGxvb2sgdXAuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gZmllbGQgLSBUaGUgZmllbGQgdG8gbG9vayB1cC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVEaWN0aW9uYXJ5R2V0RmllbGQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlHZXRGaWVsZC5IaXR9IGNvbnRhaW5pbmcgdGhlIGRpY3Rpb25hcnkgZWxlbWVudCBpZlxuICAgKiBvbmUgaXMgZm91bmQuXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlHZXRGaWVsZC5NaXNzfSBpZiB0aGUgZGljdGlvbmFyeSBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUdldEZpZWxkLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpY3Rpb25hcnlHZXRGaWVsZChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBkaWN0aW9uYXJ5TmFtZTogc3RyaW5nLFxuICAgIGZpZWxkOiBzdHJpbmcgfCBVaW50OEFycmF5XG4gICk6IFByb21pc2U8Q2FjaGVEaWN0aW9uYXJ5R2V0RmllbGQuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5kaWN0aW9uYXJ5R2V0RmllbGQoY2FjaGVOYW1lLCBkaWN0aW9uYXJ5TmFtZSwgZmllbGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgbXVsdGlwbGUgdmFsdWVzIGZyb20gdGhlIGdpdmVuIGRpY3Rpb25hcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgZGljdGlvbmFyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpY3Rpb25hcnlOYW1lIC0gVGhlIGRpY3Rpb25hcnkgdG8gbG9vayB1cC5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXX0gZmllbGRzIC0gVGhlIGZpZWxkcyB0byBsb29rIHVwLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZURpY3Rpb25hcnlHZXRGaWVsZHMuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlHZXRGaWVsZHMuSGl0fSBjb250YWluaW5nIHRoZSBkaWN0aW9uYXJ5IGVsZW1lbnRzIGlmXG4gICAqIHRoZSBkaWN0aW9uYXJ5IGV4aXN0cy5cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUdldEZpZWxkcy5NaXNzfSBpZiB0aGUgZGljdGlvbmFyeSBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUdldEZpZWxkcy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkaWN0aW9uYXJ5R2V0RmllbGRzKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGRpY3Rpb25hcnlOYW1lOiBzdHJpbmcsXG4gICAgZmllbGRzOiBzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXVxuICApOiBQcm9taXNlPENhY2hlRGljdGlvbmFyeUdldEZpZWxkcy5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmRpY3Rpb25hcnlHZXRGaWVsZHMoY2FjaGVOYW1lLCBkaWN0aW9uYXJ5TmFtZSwgZmllbGRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gZGljdGlvbmFyeS5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogUGVyZm9ybXMgYSBuby1vcCBpZiB0aGUgZGljdGlvbmFyeSBvciBmaWVsZCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBkaWN0aW9uYXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGljdGlvbmFyeU5hbWUgLSBUaGUgZGljdGlvbmFyeSB0byByZW1vdmUgZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSBmaWVsZCAtIFRoZSBmaWVsZCB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlRGljdGlvbmFyeVJlbW92ZUZpZWxkLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGQuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeVJlbW92ZUZpZWxkLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpY3Rpb25hcnlSZW1vdmVGaWVsZChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBkaWN0aW9uYXJ5TmFtZTogc3RyaW5nLFxuICAgIGZpZWxkOiBzdHJpbmcgfCBVaW50OEFycmF5XG4gICk6IFByb21pc2U8Q2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGQuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5kaWN0aW9uYXJ5UmVtb3ZlRmllbGQoY2FjaGVOYW1lLCBkaWN0aW9uYXJ5TmFtZSwgZmllbGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgbXVsdGlwbGUgZmllbGRzIGZyb20gdGhlIGdpdmVuIGRpY3Rpb25hcnkuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFBlcmZvcm1zIGEgbm8tb3AgaWYgdGhlIGRpY3Rpb25hcnkgb3IgZmllbGRzIGRvIG5vdCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBkaWN0aW9uYXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGljdGlvbmFyeU5hbWUgLSBUaGUgZGljdGlvbmFyeSB0byByZW1vdmUgZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXX0gZmllbGRzIC0gVGhlIGZpZWxkcyB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlRGljdGlvbmFyeVJlbW92ZUZpZWxkcy5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeVJlbW92ZUZpZWxkcy5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGRzLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpY3Rpb25hcnlSZW1vdmVGaWVsZHMoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgZGljdGlvbmFyeU5hbWU6IHN0cmluZyxcbiAgICBmaWVsZHM6IHN0cmluZ1tdIHwgVWludDhBcnJheVtdXG4gICk6IFByb21pc2U8Q2FjaGVEaWN0aW9uYXJ5UmVtb3ZlRmllbGRzLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuZGljdGlvbmFyeVJlbW92ZUZpZWxkcyhcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIGRpY3Rpb25hcnlOYW1lLFxuICAgICAgZmllbGRzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGludGVnZXIgcXVhbnRpdHkgdG8gYSBkaWN0aW9uYXJ5IHZhbHVlLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBJbmNyZW1lbnRpbmcgdGhlIHZhbHVlIG9mIGEgbWlzc2luZyBmaWVsZCBzZXRzIHRoZSB2YWx1ZSB0byBhbW91bnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgZGljdGlvbmFyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpY3Rpb25hcnlOYW1lIC0gVGhlIGRpY3Rpb25hcnkgdG8gc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGZpZWxkIC0gVGhlIGZpZWxkIHRvIGluY3JlbWVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIFRoZSBxdWFudGl0eSB0byBhZGQgdG8gdGhlIHZhbHVlLiBNYXkgYmUgcG9zaXRpdmUsXG4gICAqIG5lZ2F0aXZlLCBvciB6ZXJvLiBEZWZhdWx0cyB0byAxLlxuICAgKiBAcGFyYW0ge0RpY3Rpb25hcnlJbmNyZW1lbnRPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIGRpY3Rpb25hcnkncyBUVEwgdXNpbmcgdGhlIGNsaWVudCdzIGRlZmF1bHQgaWYgdGhpcyBpcyBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlRGljdGlvbmFyeUluY3JlbWVudC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlRGljdGlvbmFyeUluY3JlbWVudC5TdWNjZXNzfSBjb250YWluaW5nIHRoZSBpbmNyZW1lbnRlZCB2YWx1ZVxuICAgKiBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5SW5jcmVtZW50LkVycm9yfSBvbiBmYWlsdXJlLiBJbmNyZW1lbnRpbmcgYSB2YWx1ZVxuICAgKiB0aGF0IHdhcyBub3Qgc2V0IHVzaW5nIHRoaXMgbWV0aG9kIG9yIGlzIG5vdCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mXG4gICAqIGFuIGludGVnZXIgcmVzdWx0cyBpbiBhIGZhaWx1cmUgd2l0aCBhIEZhaWxlZFByZWNvbmRpdGlvbkV4Y2VwdGlvbiBlcnJvci5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBkaWN0aW9uYXJ5SW5jcmVtZW50KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGRpY3Rpb25hcnlOYW1lOiBzdHJpbmcsXG4gICAgZmllbGQ6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgYW1vdW50ID0gMSxcbiAgICBvcHRpb25zPzogRGljdGlvbmFyeUluY3JlbWVudE9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZURpY3Rpb25hcnlJbmNyZW1lbnQuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5kaWN0aW9uYXJ5SW5jcmVtZW50KFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgZGljdGlvbmFyeU5hbWUsXG4gICAgICBmaWVsZCxcbiAgICAgIGFtb3VudCxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBkaWN0aW9uYXJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGRpY3Rpb25hcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaWN0aW9uYXJ5TmFtZSAtIFRoZSBkaWN0aW9uYXJ5IHRvIGdldCB0aGUgbGVuZ3RoIG9mLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZURpY3Rpb25hcnlMZW5ndGguUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZURpY3Rpb25hcnlMZW5ndGguSGl0fSBjb250YWluaW5nIHRoZSBsZW5ndGggaWYgdGhlIGRpY3Rpb25hcnkgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5TGVuZ3RoLk1pc3N9IGlmIHRoZSBkaWN0aW9uYXJ5IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVEaWN0aW9uYXJ5TGVuZ3RoLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRpY3Rpb25hcnlMZW5ndGgoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgZGljdGlvbmFyeU5hbWU6IHN0cmluZ1xuICApOiBQcm9taXNlPENhY2hlRGljdGlvbmFyeUxlbmd0aC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmRpY3Rpb25hcnlMZW5ndGgoY2FjaGVOYW1lLCBkaWN0aW9uYXJ5TmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBnaXZlbiBzb3J0ZWQgc2V0LiBJZiB0aGUgZWxlbWVudCBhbHJlYWR5IGV4aXN0cywgaXRzXG4gICAqIHNjb3JlIGlzIHVwZGF0ZWQuIENyZWF0ZXMgdGhlIHNvcnRlZCBzZXQgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvcnRlZFNldE5hbWUgLSBUaGUgc29ydGVkIHNldCB0byBhZGQgdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYWRkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NvcmUgLSBUaGUgc2NvcmUgdG8gYXNzaWduIHRvIHRoZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtTb3J0ZWRTZXRQdXRFbGVtZW50T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBzb3J0ZWQgc2V0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldFB1dEVsZW1lbnQuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldFB1dEVsZW1lbnQuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0UHV0RWxlbWVudC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICogQHJldHVybnNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBzb3J0ZWRTZXRQdXRFbGVtZW50KFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNvcnRlZFNldE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBzY29yZTogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiBTb3J0ZWRTZXRQdXRFbGVtZW50T3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU29ydGVkU2V0UHV0RWxlbWVudC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNvcnRlZFNldFB1dEVsZW1lbnQoXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBzb3J0ZWRTZXROYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICBzY29yZSxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBlbGVtZW50cyB0byB0aGUgZ2l2ZW4gc29ydGVkIHNldC4gRm9yIGFueSB2YWx1ZXMgdGhhdCBhbHJlYWR5IGV4aXN0LCBpdFxuICAgKiB0aGUgc2NvcmUgaXMgdXBkYXRlZC4gQ3JlYXRlcyB0aGUgc29ydGVkIHNldCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydGVkU2V0TmFtZSAtIFRoZSBzb3J0ZWQgc2V0IHRvIGFkZCB0by5cbiAgICogQHBhcmFtIHtNYXA8c3RyaW5nIHwgVWludDhBcnJheSwgbnVtYmVyPnwgUmVjb3JkPHN0cmluZywgbnVtYmVyPn0gZWxlbWVudHMgLSBUaGUgdmFsdWUtPnNjb3JlIHBhaXJzIHRvIGFkZCB0byB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtTb3J0ZWRTZXRQdXRFbGVtZW50T3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25UdGx9IFtvcHRpb25zLnR0bF0gLSBIb3cgdGhlIFRUTCBzaG91bGQgYmUgbWFuYWdlZC5cbiAgICogUmVmcmVzaGVzIHRoZSBzb3J0ZWQgc2V0J3MgVFRMIHVzaW5nIHRoZSBjbGllbnQncyBkZWZhdWx0IGlmIHRoaXMgaXMgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldFB1dEVsZW1lbnRzLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRQdXRFbGVtZW50cy5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRQdXRFbGVtZW50cy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICogQHJldHVybnNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBzb3J0ZWRTZXRQdXRFbGVtZW50cyhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzb3J0ZWRTZXROYW1lOiBzdHJpbmcsXG4gICAgZWxlbWVudHM6XG4gICAgICB8IE1hcDxzdHJpbmcgfCBVaW50OEFycmF5LCBudW1iZXI+XG4gICAgICB8IFJlY29yZDxzdHJpbmcsIG51bWJlcj5cbiAgICAgIHwgQXJyYXk8W3N0cmluZywgbnVtYmVyXT4sXG4gICAgb3B0aW9ucz86IFNvcnRlZFNldFB1dEVsZW1lbnRzT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU29ydGVkU2V0UHV0RWxlbWVudHMuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zb3J0ZWRTZXRQdXRFbGVtZW50cyhcbiAgICAgIGNhY2hlTmFtZSxcbiAgICAgIHNvcnRlZFNldE5hbWUsXG4gICAgICBlbGVtZW50cyxcbiAgICAgIG9wdGlvbnM/LnR0bFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBzb3J0ZWQgc2V0IGJ5IGluZGV4IChyYW5rKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydGVkU2V0TmFtZSAtIFRoZSBzb3J0ZWQgc2V0IHRvIGZldGNoIGZyb20uXG4gICAqIEBwYXJhbSB7U29ydGVkU2V0RmV0Y2hCeVJhbmtPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGFydFJhbmtdIC0gVGhlIHJhbmsgb2YgdGhlIGZpcnN0IGVsZW1lbnQgdG9cbiAgICogZmV0Y2guIERlZmF1bHRzIHRvIDAuIFRoaXMgcmFuayBpcyBpbmNsdXNpdmUsIGllIHRoZSBlbGVtZW50IGF0IHRoaXMgcmFua1xuICAgKiB3aWxsIGJlIGZldGNoZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5lbmRSYW5rXSAtIFRoZSByYW5rIG9mIHRoZSBsYXN0IGVsZW1lbnQgdG8gZmV0Y2guXG4gICAqIFRoaXMgcmFuayBpcyBleGNsdXNpdmUsIGllIHRoZSBlbGVtZW50IGF0IHRoaXMgcmFuayB3aWxsIG5vdCBiZSBmZXRjaGVkLlxuICAgKiBEZWZhdWx0cyB0byBudWxsLCB3aGljaCBmZXRjaGVzIHVwIHVudGlsIGFuZCBpbmNsdWRpbmcgdGhlIGxhc3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtTb3J0ZWRTZXRPcmRlcn0gW29wdGlvbnMub3JkZXJdIC0gVGhlIG9yZGVyIHRvIGZldGNoIHRoZSBlbGVtZW50cyBpbi5cbiAgICogRGVmYXVsdHMgdG8gYXNjZW5kaW5nLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldEZldGNoLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0RmV0Y2guSGl0fSBjb250YWluaW5nIHRoZSByZXF1ZXN0ZWQgZWxlbWVudHMgd2hlbiBmb3VuZC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0RmV0Y2guTWlzc30gd2hlbiB0aGUgc29ydGVkIHNldCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0RmV0Y2guRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc29ydGVkU2V0RmV0Y2hCeVJhbmsoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc29ydGVkU2V0TmFtZTogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBTb3J0ZWRTZXRGZXRjaEJ5UmFua09wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZVNvcnRlZFNldEZldGNoLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0RmV0Y2hCeVJhbmsoXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBzb3J0ZWRTZXROYW1lLFxuICAgICAgb3B0aW9ucz8ub3JkZXIgPz8gU29ydGVkU2V0T3JkZXIuQXNjZW5kaW5nLFxuICAgICAgb3B0aW9ucz8uc3RhcnRSYW5rID8/IDAsXG4gICAgICBvcHRpb25zPy5lbmRSYW5rXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZWxlbWVudHMgaW4gdGhlIGdpdmVuIHNvcnRlZCBzZXQgYnkgc2NvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvcnRlZFNldE5hbWUgLSBUaGUgc29ydGVkIHNldCB0byBmZXRjaCBmcm9tLlxuICAgKiBAcGFyYW0ge1NvcnRlZFNldEZldGNoQnlTY29yZU9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pblNjb3JlXSAtIFRoZSBtaW5pbXVtIHNjb3JlIChpbmNsdXNpdmUpIG9mIHRoZVxuICAgKiBlbGVtZW50cyB0byBmZXRjaC4gRGVmYXVsdHMgdG8gbmVnYXRpdmUgaW5maW5pdHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhTY29yZV0gLSBUaGUgbWF4aW11bSBzY29yZSAoaW5jbHVzaXZlKSBvZiB0aGVcbiAgICogZWxlbWVudHMgdG8gZmV0Y2guIERlZmF1bHRzIHRvIHBvc2l0aXZlIGluZmluaXR5LlxuICAgKiBAcGFyYW0ge1NvcnRlZFNldE9yZGVyfSBbb3B0aW9ucy5vcmRlcl0gLSBUaGUgb3JkZXIgdG8gZmV0Y2ggdGhlIGVsZW1lbnRzIGluLlxuICAgKiBEZWZhdWx0cyB0byBhc2NlbmRpbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRdIC0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGJlZm9yZVxuICAgKiByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnQuIERlZmF1bHRzIHRvIDAuIE5vdGU6IHRoaXMgaXMgbm90IHRoZSByYW5rIG9mXG4gICAqIHRoZSBmaXJzdCBlbGVtZW50IHRvIHJldHVybiwgYnV0IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgdGhlIHJlc3VsdCBzZXRcbiAgICogdG8gc2tpcCBiZWZvcmUgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY291bnRdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi5cbiAgICogRGVmYXVsdHMgdG8gdW5kZWZpbmVkLCB3aGljaCByZXR1cm5zIGFsbCBlbGVtZW50cy5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTb3J0ZWRTZXRGZXRjaC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0RmV0Y2guSGl0fSBjb250YWluaW5nIHRoZSByZXF1ZXN0ZWQgZWxlbWVudHMgd2hlbiBmb3VuZC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0RmV0Y2guTWlzc30gd2hlbiB0aGUgc29ydGVkIHNldCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0RmV0Y2guRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc29ydGVkU2V0RmV0Y2hCeVNjb3JlKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNvcnRlZFNldE5hbWU6IHN0cmluZyxcbiAgICBvcHRpb25zPzogU29ydGVkU2V0RmV0Y2hCeVNjb3JlT3B0aW9uc1xuICApOiBQcm9taXNlPENhY2hlU29ydGVkU2V0RmV0Y2guUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zb3J0ZWRTZXRGZXRjaEJ5U2NvcmUoXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBzb3J0ZWRTZXROYW1lLFxuICAgICAgb3B0aW9ucz8ub3JkZXIgPz8gU29ydGVkU2V0T3JkZXIuQXNjZW5kaW5nLFxuICAgICAgb3B0aW9ucz8ubWluU2NvcmUsXG4gICAgICBvcHRpb25zPy5tYXhTY29yZSxcbiAgICAgIG9wdGlvbnM/Lm9mZnNldCxcbiAgICAgIG9wdGlvbnM/LmNvdW50XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rIHVwIHRoZSByYW5rIG9mIGFuIGVsZW1lbnQgaW4gdGhlIHNvcnRlZCBzZXQsIGJ5IHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydGVkU2V0TmFtZSAtIFRoZSBzb3J0ZWQgc2V0IHRvIGZldGNoIGZyb20uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgd2hvc2UgcmFuayB3ZSBhcmUgcmV0cmlldmluZy5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTb3J0ZWRTZXRHZXRSYW5rLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0R2V0UmFuay5IaXR9IGNvbnRhaW5pbmcgdGhlIHJhbmsgb2YgdGhlIHJlcXVlc3RlZCBlbGVtZW50cyB3aGVuIGZvdW5kLlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRHZXRSYW5rLk1pc3N9IHdoZW4gdGhlIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEdldFJhbmsuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc29ydGVkU2V0R2V0UmFuayhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzb3J0ZWRTZXROYW1lOiBzdHJpbmcsXG4gICAgdmFsdWU6IHN0cmluZyB8IFVpbnQ4QXJyYXlcbiAgKTogUHJvbWlzZTxDYWNoZVNvcnRlZFNldEdldFJhbmsuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zb3J0ZWRTZXRHZXRSYW5rKGNhY2hlTmFtZSwgc29ydGVkU2V0TmFtZSwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2sgdXAgdGhlIHNjb3JlIG9mIGFuIGVsZW1lbnQgaW4gdGhlIHNvcnRlZCBzZXQsIGJ5IHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydGVkU2V0TmFtZSAtIFRoZSBzb3J0ZWQgc2V0IHRvIGZldGNoIGZyb20uXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheX0gdmFsdWUgLSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgd2hvc2Ugc2NvcmUgd2UgYXJlIHJldHJpZXZpbmcuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU29ydGVkU2V0R2V0U2NvcmUuUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZS5IaXR9IGNvbnRhaW5pbmcgdGhlIHNjb3JlIG9mIHRoZSByZXF1ZXN0ZWQgZWxlbWVudCB3aGVuIGZvdW5kLlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRHZXRTY29yZS5NaXNzfSB3aGVuIHRoZSBlbGVtZW50IG9yIGNvbGxlY3Rpb24gZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEdldFNjb3JlLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNvcnRlZFNldEdldFNjb3JlKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNvcnRlZFNldE5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZTogc3RyaW5nIHwgVWludDhBcnJheVxuICApOiBQcm9taXNlPENhY2hlU29ydGVkU2V0R2V0U2NvcmUuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zb3J0ZWRTZXRHZXRTY29yZShjYWNoZU5hbWUsIHNvcnRlZFNldE5hbWUsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rIHVwIHRoZSBzY29yZXMgb2YgbXVsdGlwbGUgZWxlbWVudHMgaW4gdGhlIHNvcnRlZCBzZXQsIGJ5IHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvcnRlZFNldE5hbWUgLSBUaGUgc29ydGVkIHNldCB0byBmZXRjaCBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgVWludDhBcnJheVtdfSB2YWx1ZXMgLSBUaGUgdmFsdWVzIG9mIHRoZSBlbGVtZW50cyB3aG9zZSBzY29yZXMgd2UgYXJlIHJldHJpZXZpbmcuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU29ydGVkU2V0R2V0U2NvcmVzLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0R2V0U2NvcmVzLkhpdH0gY29udGFpbmluZyB0aGUgc2NvcmVzIG9mIHRoZSByZXF1ZXN0ZWQgZWxlbWVudHMgd2hlbiBmb3VuZC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0R2V0U2NvcmVzLk1pc3N9IHdoZW4gdGhlIGVsZW1lbnQgb3IgY29sbGVjdGlvbiBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0R2V0U2NvcmVzLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNvcnRlZFNldEdldFNjb3JlcyhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzb3J0ZWRTZXROYW1lOiBzdHJpbmcsXG4gICAgdmFsdWVzOiBzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXVxuICApOiBQcm9taXNlPENhY2hlU29ydGVkU2V0R2V0U2NvcmVzLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0R2V0U2NvcmVzKGNhY2hlTmFtZSwgc29ydGVkU2V0TmFtZSwgdmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgdGhlIHNjb3JlIG9mIGFuIGVsZW1lbnQgaW4gdGhlIHNvcnRlZCBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvcnRlZFNldE5hbWUgLSBUaGUgc29ydGVkIHNldCB0byBmZXRjaCBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHdob3NlIHNjb3JlIHdlIGFyZSBpbmNyZW1lbnRpbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSBUaGUgcXVhbnRpdHkgdG8gYWRkIHRvIHRoZSBzY29yZS4gTWF5IGJlIHBvc2l0aXZlLFxuICAgKiBuZWdhdGl2ZSwgb3IgemVyby4gRGVmYXVsdHMgdG8gMS5cbiAgICogQHBhcmFtIHtTb3J0ZWRTZXRJbmNyZW1lbnRPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvblR0bH0gW29wdGlvbnMudHRsXSAtIEhvdyB0aGUgVFRMIHNob3VsZCBiZSBtYW5hZ2VkLlxuICAgKiBSZWZyZXNoZXMgdGhlIHNvcnRlZCBzZXQncyBUVEwgdXNpbmcgdGhlIGNsaWVudCdzIGRlZmF1bHQgaWYgdGhpcyBpcyBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU29ydGVkU2V0SW5jcmVtZW50U2NvcmUuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEluY3JlbWVudFNjb3JlLlN1Y2Nlc3N9IGNvbnRhaW5pbmcgdGhlIGluY3JlbWVudGVkIHNjb3JlXG4gICAqIG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEluY3JlbWVudFNjb3JlLkVycm9yfSBvbiBmYWlsdXJlLiBJbmNyZW1lbnRpbmcgYSBzY29yZVxuICAgKiB0aGF0IHdhcyBub3Qgc2V0IHVzaW5nIHRoaXMgbWV0aG9kIG9yIGlzIG5vdCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mXG4gICAqIGFuIGludGVnZXIgcmVzdWx0cyBpbiBhIGZhaWx1cmUgd2l0aCBhIEZhaWxlZFByZWNvbmRpdGlvbkV4Y2VwdGlvbiBlcnJvci5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzb3J0ZWRTZXRJbmNyZW1lbnRTY29yZShcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzb3J0ZWRTZXROYW1lOiBzdHJpbmcsXG4gICAgdmFsdWU6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gICAgYW1vdW50PzogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiBTb3J0ZWRTZXRJbmNyZW1lbnRPcHRpb25zXG4gICk6IFByb21pc2U8Q2FjaGVTb3J0ZWRTZXRJbmNyZW1lbnRTY29yZS5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LnNvcnRlZFNldEluY3JlbWVudFNjb3JlKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgc29ydGVkU2V0TmFtZSxcbiAgICAgIHZhbHVlLFxuICAgICAgYW1vdW50IHx8IDEsXG4gICAgICBvcHRpb25zPy50dGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBlbGVtZW50IGZyb20gdGhlIHNvcnRlZCBzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBzb3J0ZWQgc2V0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc29ydGVkU2V0TmFtZSAtIFRoZSBzb3J0ZWQgc2V0IHRvIHJlbW92ZSBmcm9tLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZSBmcm9tIHRoZSBzZXQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlU29ydGVkU2V0UmVtb3ZlRWxlbWVudC5SZXNwb25zZT59XG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldFJlbW92ZUVsZW1lbnQuU3VjY2Vzc30gaWYgdGhlIGVsZW1lbnQgd2FzIHN1Y2Nlc3NmdWxseSByZW1vdmVkXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEluY3JlbWVudFNjb3JlLkVycm9yfSBvbiBmYWlsdXJlXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc29ydGVkU2V0UmVtb3ZlRWxlbWVudChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBzb3J0ZWRTZXROYW1lOiBzdHJpbmcsXG4gICAgdmFsdWU6IHN0cmluZyB8IFVpbnQ4QXJyYXlcbiAgKTogUHJvbWlzZTxDYWNoZVNvcnRlZFNldFJlbW92ZUVsZW1lbnQuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zb3J0ZWRTZXRSZW1vdmVFbGVtZW50KGNhY2hlTmFtZSwgc29ydGVkU2V0TmFtZSwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBtdWx0aXBsZSBlbGVtZW50cyBmcm9tIHRoZSBzb3J0ZWQgc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvcnRlZFNldE5hbWUgLSBUaGUgc29ydGVkIHNldCB0byByZW1vdmUgZnJvbS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVaW50OEFycmF5fSB2YWx1ZXMgLSBUaGUgdmFsdWVzIG9mIHRoZSBlbGVtZW50cyB0byByZW1vdmUgZnJvbSB0aGUgc2V0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldFJlbW92ZUVsZW1lbnQuUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRSZW1vdmVFbGVtZW50LlN1Y2Nlc3N9IGlmIHRoZSBlbGVtZW50cyB3ZXJlIHN1Y2Nlc3NmdWxseSByZW1vdmVkXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldEluY3JlbWVudFNjb3JlLkVycm9yfSBvbiBmYWlsdXJlXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc29ydGVkU2V0UmVtb3ZlRWxlbWVudHMoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc29ydGVkU2V0TmFtZTogc3RyaW5nLFxuICAgIHZhbHVlczogc3RyaW5nW10gfCBVaW50OEFycmF5W11cbiAgKTogUHJvbWlzZTxDYWNoZVNvcnRlZFNldFJlbW92ZUVsZW1lbnRzLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQuc29ydGVkU2V0UmVtb3ZlRWxlbWVudHMoXG4gICAgICBjYWNoZU5hbWUsXG4gICAgICBzb3J0ZWRTZXROYW1lLFxuICAgICAgdmFsdWVzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBsZW5ndGggKG51bWJlciBvZiBpdGVtcykgb2Ygc29ydGVkIHNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIHNvcnRlZCBzZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3J0ZWRTZXROYW1lIC0gVGhlIHNvcnRlZCBzZXQgbmFtZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVTb3J0ZWRTZXRMZW5ndGguUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRMZW5ndGguSGl0fSBjb250YWluaW5nIHRoZSBsZW5ndGggaWYgdGhlIHNvcnRlZCBzZXQgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRMZW5ndGguTWlzc30gaWYgdGhlIHNvcnRlZCBzZXQgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZVNvcnRlZFNldExlbmd0aC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzb3J0ZWRTZXRMZW5ndGgoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgc29ydGVkU2V0TmFtZTogc3RyaW5nXG4gICk6IFByb21pc2U8Q2FjaGVTb3J0ZWRTZXRMZW5ndGguUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zb3J0ZWRTZXRMZW5ndGgoY2FjaGVOYW1lLCBzb3J0ZWRTZXROYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBsZW5ndGggKG51bWJlciBvZiBpdGVtcykgb2Ygc29ydGVkIHNldCB3aXRoaW4gdGhlIHByb3ZpZGVkIHNjb3JlIHJhbmdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgY29udGFpbmluZyB0aGUgc29ydGVkIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvcnRlZFNldE5hbWUgLSBUaGUgc29ydGVkIHNldCBuYW1lLlxuICAgKiBAcGFyYW0ge1NvcnRlZFNldExlbmd0aEJ5U2NvcmVPcHRpb25zfSBvcHRpb25zIC0gT3B0aW9uYWwgcGFyYW1ldGVyIGZvciBzcGVjaWZ5aW5nIHRoZSBzY29yZSByYW5nZSB0byBzZWFyY2ggaW4uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5taW5TY29yZV0gLSBUaGUgbG93ZXIgYm91bmQgb24gdGhlIHNjb3JlIHJhbmdlIHRvIHNlYXJjaCBpbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFNjb3JlXSAtIFRoZSB1cHBlciBib3VuZCBvbiB0aGUgc2NvcmUgcmFuZ2UgdG8gc2VhcmNoIGluLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVNvcnRlZFNldExlbmd0aEJ5U2NvcmUuUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVTb3J0ZWRTZXRMZW5ndGhCeVNjb3JlLkhpdH0gY29udGFpbmluZyB0aGUgbGVuZ3RoIGlmIHRoZSBzb3J0ZWQgc2V0IGV4aXN0cy5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0TGVuZ3RoQnlTY29yZS5NaXNzfSBpZiB0aGUgc29ydGVkIHNldCBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlU29ydGVkU2V0TGVuZ3RoQnlTY29yZS5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzb3J0ZWRTZXRMZW5ndGhCeVNjb3JlKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIHNvcnRlZFNldE5hbWU6IHN0cmluZyxcbiAgICBvcHRpb25zPzogU29ydGVkU2V0TGVuZ3RoQnlTY29yZU9wdGlvbnNcbiAgKTogUHJvbWlzZTxDYWNoZVNvcnRlZFNldExlbmd0aEJ5U2NvcmUuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5zb3J0ZWRTZXRMZW5ndGhCeVNjb3JlKFxuICAgICAgY2FjaGVOYW1lLFxuICAgICAgc29ydGVkU2V0TmFtZSxcbiAgICAgIG9wdGlvbnM/Lm1pblNjb3JlLFxuICAgICAgb3B0aW9ucz8ubWF4U2NvcmVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdHlwZSBvZiB0aGUga2V5IGluIHRoZSBjYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgZm9yIHdoaWNoIHR5cGUgaXMgcmVxdWVzdGVkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUl0ZW1HZXRUeXBlLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlSXRlbUdldFR5cGUuSGl0fSBjb250YWluaW5nIHR5cGUgb2Yga2V5IHdoZW4gZm91bmQuXG4gICAqIHtAbGluayBDYWNoZUl0ZW1HZXRUeXBlLk1pc3N9IHdoZW4gdGhlIGtleSBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlSXRlbUdldFR5cGUuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaXRlbUdldFR5cGUoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcgfCBVaW50OEFycmF5XG4gICk6IFByb21pc2U8Q2FjaGVJdGVtR2V0VHlwZS5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50Lml0ZW1HZXRUeXBlKGNhY2hlTmFtZSwga2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHJlbWFpbmluZyB0dGwgb2YgdGhlIGtleSBpbiB0aGUgY2FjaGUgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgZm9yIHdoaWNoIHRoZSB0dGwgcmVtYWluaW5nIGlzIHJlcXVlc3RlZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVJdGVtR2V0VHRsLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlSXRlbUdldFR0bC5IaXR9IGNvbnRhaW5pbmcgdHRsIHJlbWFpbmluZyBvZiBrZXkgd2hlbiBmb3VuZC5cbiAgICoge0BsaW5rIENhY2hlSXRlbUdldFR0bC5NaXNzfSB3aGVuIHRoZSBrZXkgZG9lcyBub3QgZXhpc3QuXG4gICAqIHtAbGluayBDYWNoZUl0ZW1HZXRUdGwuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaXRlbUdldFR0bChcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXlcbiAgKTogUHJvbWlzZTxDYWNoZUl0ZW1HZXRUdGwuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldE5leHREYXRhQ2xpZW50KCk7XG4gICAgcmV0dXJuIGF3YWl0IGNsaWVudC5pdGVtR2V0VHRsKGNhY2hlTmFtZSwga2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcHJvdmlkZWQga2V5IGV4aXN0cyBpbiB0aGUgY2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSB0byBsb29rIGluLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVpbnQ4QXJyYXl9IGtleSAtIFRoZSBrZXkgdG8gbG9vayB1cC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGVLZXlFeGlzdHMuUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgQ2FjaGVLZXlFeGlzdHMuU3VjY2Vzc30gaWYga2V5IGlzIGZvdW5kPyBvciBpZiBrZXkgaXMgY2hlY2tlZD9cbiAgICoge0BsaW5rIENhY2hlS2V5RXhpc3RzLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGtleUV4aXN0cyhcbiAgICBjYWNoZU5hbWU6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyB8IFVpbnQ4QXJyYXlcbiAgKTogUHJvbWlzZTxDYWNoZUtleUV4aXN0cy5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmtleUV4aXN0cyhjYWNoZU5hbWUsIGtleSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHByb3ZpZGVkIGtleXMgZXhpc3QgaW4gdGhlIGNhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgLSBUaGUgY2FjaGUgdG8gbG9vayBpbi5cbiAgICogQHBhcmFtIHtzdHJpbmdbXSB8IFVpbnQ4QXJyYXlbXX0ga2V5cyAtIFRoZSBrZXlzIHRvIGxvb2sgdXAuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPENhY2hlS2V5c0V4aXN0LlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlS2V5c0V4aXN0LlN1Y2Nlc3N9IGlmIGF0IGxlYXN0IG9uZSBrZXkgaXMgZm91bmQ/IGlmIGFsbCBrZXlzIGNoZWNrZWQ/XG4gICAqIHtAbGluayBDYWNoZUtleXNFeGlzdC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBrZXlzRXhpc3QoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5czogc3RyaW5nW10gfCBVaW50OEFycmF5W11cbiAgKTogUHJvbWlzZTxDYWNoZUtleXNFeGlzdC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmtleXNFeGlzdChjYWNoZU5hbWUsIGtleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgdHRsIG9mIHRoZSBrZXkgaW4gdGhlIGNhY2hlIGluIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZSAtIFRoZSBjYWNoZSBjb250YWluaW5nIHRoZSBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IGZvciB3aGljaCB0aGUgdHRsIHJlbWFpbmluZyBpcyByZXF1ZXN0ZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0dGxNaWxsaXNlY29uZHMgLSBUaGUgdHRsIGluIG1pbGxpc2Vjb25kcyB0aGF0IHNob3VsZCBvdmVyd3JpdGUgdGhlIGN1cnJlbnQgdHRsLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZVVwZGF0ZVR0bC5SZXNwb25zZT59XG4gICAqIHtAbGluayBDYWNoZVVwZGF0ZVR0bC5TZXR9IHdoZW4gdGhlIHR0bCB3YXMgc3VjY2Vzc2Z1bGx5IG92ZXJ3cml0dGVuLlxuICAgKiB7QGxpbmsgQ2FjaGVVcGRhdGVUdGwuTWlzc30gd2hlbiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LlxuICAgKiB7QGxpbmsgQ2FjaGVVcGRhdGVUdGwuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgdXBkYXRlVHRsKFxuICAgIGNhY2hlTmFtZTogc3RyaW5nLFxuICAgIGtleTogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICB0dGxNaWxsaXNlY29uZHM6IG51bWJlclxuICApOiBQcm9taXNlPENhY2hlVXBkYXRlVHRsLlJlc3BvbnNlPiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXROZXh0RGF0YUNsaWVudCgpO1xuICAgIHJldHVybiBhd2FpdCBjbGllbnQudXBkYXRlVHRsKGNhY2hlTmFtZSwga2V5LCB0dGxNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlIHRoZSB0dGwgb2YgdGhlIGtleSBpbiB0aGUgY2FjaGUgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgZm9yIHdoaWNoIHRoZSB0dGwgcmVtYWluaW5nIGlzIHJlcXVlc3RlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHR0bE1pbGxpc2Vjb25kcyAtIFRoZSB0dGwgaW4gbWlsbGlzZWNvbmRzIHRoYXQgc2hvdWxkXG4gICAqIG92ZXJ3cml0ZSB0aGUgY3VycmVudCB0dGwuIFNob3VsZCBiZSBncmVhdGVyIHRoYW4gdGhlIGN1cnJlbnQgdHRsLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZUluY3JlYXNlVHRsLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlSW5jcmVhc2VUdGwuU2V0fSB3aGVuIHRoZSB0dGwgd2FzIHN1Y2Nlc3NmdWxseSBpbmNyZWFzZWQuXG4gICAqIHtAbGluayBDYWNoZUluY3JlYXNlVHRsLk1pc3N9IHdoZW4gdGhlIGtleSBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlSW5jcmVhc2VUdGwuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW5jcmVhc2VUdGwoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIHR0bE1pbGxpc2Vjb25kczogbnVtYmVyXG4gICk6IFByb21pc2U8Q2FjaGVJbmNyZWFzZVR0bC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmluY3JlYXNlVHRsKGNhY2hlTmFtZSwga2V5LCB0dGxNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY3JlYXNlIHRoZSB0dGwgb2YgdGhlIGtleSBpbiB0aGUgY2FjaGUgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FjaGVOYW1lIC0gVGhlIGNhY2hlIGNvbnRhaW5pbmcgdGhlIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgZm9yIHdoaWNoIHRoZSB0dGwgcmVtYWluaW5nIGlzIHJlcXVlc3RlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHR0bE1pbGxpc2Vjb25kcyAtIFRoZSB0dGwgaW4gbWlsbGlzZWNvbmRzIHRoYXQgc2hvdWxkXG4gICAqIG92ZXJ3cml0ZSB0aGUgY3VycmVudCB0dGwuIFNob3VsZCBiZSBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgdHRsLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDYWNoZURlY3JlYXNlVHRsLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIENhY2hlRGVjcmVhc2VUdGwuU2V0fSB3aGVuIHRoZSB0dGwgd2FzIHN1Y2Nlc3NmdWxseSBkZWNyZWFzZWQuXG4gICAqIHtAbGluayBDYWNoZURlY3JlYXNlVHRsLk1pc3N9IHdoZW4gdGhlIGtleSBkb2VzIG5vdCBleGlzdC5cbiAgICoge0BsaW5rIENhY2hlRGVjcmVhc2VUdGwuRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVjcmVhc2VUdGwoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAga2V5OiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIHR0bE1pbGxpc2Vjb25kczogbnVtYmVyXG4gICk6IFByb21pc2U8Q2FjaGVEZWNyZWFzZVR0bC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0TmV4dERhdGFDbGllbnQoKTtcbiAgICByZXR1cm4gYXdhaXQgY2xpZW50LmRlY3JlYXNlVHRsKGNhY2hlTmFtZSwga2V5LCB0dGxNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldE5leHREYXRhQ2xpZW50KCk6IElEYXRhQ2xpZW50IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmRhdGFDbGllbnRzW3RoaXMubmV4dERhdGFDbGllbnRJbmRleF07XG4gICAgdGhpcy5uZXh0RGF0YUNsaWVudEluZGV4ID1cbiAgICAgICh0aGlzLm5leHREYXRhQ2xpZW50SW5kZXggKyAxKSAlIHRoaXMuZGF0YUNsaWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBjbGllbnQ7XG4gIH1cblxuICBhYnN0cmFjdCBjbG9zZSgpOiB2b2lkO1xufVxuIl19