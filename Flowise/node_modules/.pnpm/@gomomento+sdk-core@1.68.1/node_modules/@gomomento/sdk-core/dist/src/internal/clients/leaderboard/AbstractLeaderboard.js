"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractLeaderboard = void 0;
class AbstractLeaderboard {
    constructor(cacheName, leaderboardName, dataClient) {
        this.cacheName = cacheName;
        this.leaderboardName = leaderboardName;
        this.dataClient = dataClient;
    }
    /**
     * Updates elements in a leaderboard or inserts elements if they do not already exist.
     * The leaderboard is also created if it does not already exist.
     * Note: can upsert a maximum of 8192 elements at a time.
     *
     * @param {Map<number, number>} elements - The ID->score pairs to add to the leaderboard.
     * @returns {Promise<LeaderboardUpsert.Response>} -
     * {@link LeaderboardUpsert.Success} on success.
     * {@link LeaderboardUpsert.Error} on failure.
     */
    async upsert(elements) {
        return await this.dataClient.upsert(this.cacheName, this.leaderboardName, elements);
    }
    /**
     * Fetch the elements in the given leaderboard by score.
     * Note: can fetch a maximum of 8192 elements at a time.
     *
     * @param {LeaderboardFetchByScoreCallOptions} options
     * @param {number} [options.minScore] - The minimum score (inclusive) of the
     * elements to fetch. Defaults to negative infinity.
     * @param {number} [options.maxScore] - The maximum score (exclusive) of the
     * elements to fetch. Defaults to positive infinity.
     * @param {LeaderboardOrder} [options.order] - The order to fetch the elements in.
     * Defaults to ascending, meaning 0 is the lowest-scoring rank.
     * @param {number} [options.offset] - The number of elements to skip before
     * returning the first element. Defaults to 0. Note: this is not the score of
     * the first element to return, but the number of elements of the result set
     * to skip before returning the first element.
     * @param {number} [options.count] - The maximum number of elements to return.
     * Defaults to 8192, which is the maximum that can be fetched at a time.
     * @returns {Promise<LeaderboardFetch.Response>} -
     * {@link LeaderboardFetch.Success} containing the requested elements.
     * {@link LeaderboardFetch.Error} on failure.
     */
    async fetchByScore(options) {
        return await this.dataClient.fetchByScore(this.cacheName, this.leaderboardName, options === null || options === void 0 ? void 0 : options.minScore, options === null || options === void 0 ? void 0 : options.maxScore, options === null || options === void 0 ? void 0 : options.order, options === null || options === void 0 ? void 0 : options.offset, options === null || options === void 0 ? void 0 : options.count);
    }
    /**
     * Fetch the elements in the given leaderboard by index (rank).
     * Note: can fetch a maximum of 8192 elements at a time and rank
     * is 0-based (index begins at 0).
     *
     * @param {number} [startRank] - The rank of the first element to
     * fetch. This rank is inclusive, ie the element at this rank
     * will be fetched. Ranks can be used to manually paginate through the leaderboard
     * in batches of 8192 elements (e.g. request 0-8192, then 8192-16384, etc).
     * @param {number} [endRank] - The rank of the last element to fetch.
     * This rank is exclusive, ie the element at this rank will not be fetched.
     * Ranks can be used to manually paginate through the leaderboard
     * in batches of 8192 elements (e.g. request 0-8192, then 8192-16384, etc).
     * @param {LeaderboardFetchByRankOptions} options
     * @param {LeaderboardOrder} [options.order] - The order to fetch the elements in.
     * Defaults to ascending, meaning 0 is the lowest-scoring rank.
     * @returns {Promise<LeaderboardFetch.Response>} -
     * {@link LeaderboardFetch.Success} containing the requested elements.
     * {@link LeaderboardFetch.Error} on failure.
     */
    async fetchByRank(startRank, endRank, options) {
        return await this.dataClient.fetchByRank(this.cacheName, this.leaderboardName, startRank, endRank, options === null || options === void 0 ? void 0 : options.order);
    }
    /**
     * Look up the rank of an element in the leaderboard given the element id.
     * Note: rank is 0-based (index begins at 0).
     *
     * @param {number} ids - The ids of the elements whose rank we are retrieving.
     * @param {LeaderboardGetRankCallOptions} options
     * @param {LeaderboardOrder} [options.order] - The order to fetch the elements in.
     * Defaults to ascending, meaning 0 is the lowest-scoring rank.
     * @returns {Promise<LeaderboardFetch.Response>}
     * {@link LeaderboardFetch.Success} containing the requested elements.
     * {@link LeaderboardFetch.Error} on failure.
     */
    async getRank(ids, options) {
        return await this.dataClient.getRank(this.cacheName, this.leaderboardName, ids, options === null || options === void 0 ? void 0 : options.order);
    }
    /**
     * Fetch length (number of items) of leaderboard
     *
     * @returns {Promise<LeaderboardLength.Response>}
     * {@link LeaderboardLength.Success} containing the length if the leaderboard exists.
     * {@link LeaderboardLength.Error} on failure.
     */
    async length() {
        return await this.dataClient.length(this.cacheName, this.leaderboardName);
    }
    /**
     * Remove multiple elements from the given leaderboard
     * Note: can remove a maximum of 8192 elements at a time.
     *
     * @param {Array<number>} ids - The IDs of the elements to remove from the leaderboard.
     * @returns {Promise<LeaderboardRemoveElements.Response>}
     * {@link LeaderboardRemoveElements.Success} if the elements were successfully removed.
     * {@link LeaderboardRemoveElements.Error} on failure.
     */
    async removeElements(ids) {
        return await this.dataClient.removeElements(this.cacheName, this.leaderboardName, ids);
    }
    /**
     * Delete the given leaderboard
     *
     * @returns {Promise<LeaderboardDelete.Response>}
     * {@link LeaderboardDelete.Success} on success.
     * {@link LeaderboardDelete.Error} on failure.
     */
    async delete() {
        return await this.dataClient.delete(this.cacheName, this.leaderboardName);
    }
}
exports.AbstractLeaderboard = AbstractLeaderboard;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWJzdHJhY3RMZWFkZXJib2FyZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9pbnRlcm5hbC9jbGllbnRzL2xlYWRlcmJvYXJkL0Fic3RyYWN0TGVhZGVyYm9hcmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBZUEsTUFBc0IsbUJBQW1CO0lBS3ZDLFlBQ0UsU0FBaUIsRUFDakIsZUFBdUIsRUFDdkIsVUFBa0M7UUFFbEMsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7UUFDM0IsSUFBSSxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7UUFDdkMsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7SUFDL0IsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLEtBQUssQ0FBQyxNQUFNLENBQ2pCLFFBQXNEO1FBRXRELE9BQU8sTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FDakMsSUFBSSxDQUFDLFNBQVMsRUFDZCxJQUFJLENBQUMsZUFBZSxFQUNwQixRQUFRLENBQ1QsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FvQkc7SUFDSSxLQUFLLENBQUMsWUFBWSxDQUN2QixPQUE0QztRQUU1QyxPQUFPLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQ3ZDLElBQUksQ0FBQyxTQUFTLEVBQ2QsSUFBSSxDQUFDLGVBQWUsRUFDcEIsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLFFBQVEsRUFDakIsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLFFBQVEsRUFDakIsT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLEtBQUssRUFDZCxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsTUFBTSxFQUNmLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxLQUFLLENBQ2YsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQW1CRztJQUNJLEtBQUssQ0FBQyxXQUFXLENBQ3RCLFNBQWlCLEVBQ2pCLE9BQWUsRUFDZixPQUEyQztRQUUzQyxPQUFPLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQ3RDLElBQUksQ0FBQyxTQUFTLEVBQ2QsSUFBSSxDQUFDLGVBQWUsRUFDcEIsU0FBUyxFQUNULE9BQU8sRUFDUCxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsS0FBSyxDQUNmLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSSxLQUFLLENBQUMsT0FBTyxDQUNsQixHQUFrQixFQUNsQixPQUF1QztRQUV2QyxPQUFPLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQ2xDLElBQUksQ0FBQyxTQUFTLEVBQ2QsSUFBSSxDQUFDLGVBQWUsRUFDcEIsR0FBRyxFQUNILE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxLQUFLLENBQ2YsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxLQUFLLENBQUMsTUFBTTtRQUNqQixPQUFPLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDNUUsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksS0FBSyxDQUFDLGNBQWMsQ0FDekIsR0FBa0I7UUFFbEIsT0FBTyxNQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUN6QyxJQUFJLENBQUMsU0FBUyxFQUNkLElBQUksQ0FBQyxlQUFlLEVBQ3BCLEdBQUcsQ0FDSixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLEtBQUssQ0FBQyxNQUFNO1FBQ2pCLE9BQU8sTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUM1RSxDQUFDO0NBQ0Y7QUF4S0Qsa0RBd0tDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSUxlYWRlcmJvYXJkLFxuICBMZWFkZXJib2FyZEZldGNoQnlSYW5rQ2FsbE9wdGlvbnMsXG4gIExlYWRlcmJvYXJkRmV0Y2hCeVNjb3JlQ2FsbE9wdGlvbnMsXG4gIExlYWRlcmJvYXJkR2V0UmFua0NhbGxPcHRpb25zLFxufSBmcm9tICcuLi8uLi8uLi9jbGllbnRzL0lMZWFkZXJib2FyZCc7XG5pbXBvcnQge1xuICBMZWFkZXJib2FyZERlbGV0ZSxcbiAgTGVhZGVyYm9hcmRGZXRjaCxcbiAgTGVhZGVyYm9hcmRMZW5ndGgsXG4gIExlYWRlcmJvYXJkUmVtb3ZlRWxlbWVudHMsXG4gIExlYWRlcmJvYXJkVXBzZXJ0LFxufSBmcm9tICcuLi8uLi8uLi9tZXNzYWdlcy9yZXNwb25zZXMvbGVhZGVyYm9hcmQnO1xuaW1wb3J0IHtJTGVhZGVyYm9hcmREYXRhQ2xpZW50fSBmcm9tICcuL0lMZWFkZXJib2FyZERhdGFDbGllbnQnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RMZWFkZXJib2FyZCBpbXBsZW1lbnRzIElMZWFkZXJib2FyZCB7XG4gIHByb3RlY3RlZCByZWFkb25seSBjYWNoZU5hbWU6IHN0cmluZztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGxlYWRlcmJvYXJkTmFtZTogc3RyaW5nO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGF0YUNsaWVudDogSUxlYWRlcmJvYXJkRGF0YUNsaWVudDtcblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoXG4gICAgY2FjaGVOYW1lOiBzdHJpbmcsXG4gICAgbGVhZGVyYm9hcmROYW1lOiBzdHJpbmcsXG4gICAgZGF0YUNsaWVudDogSUxlYWRlcmJvYXJkRGF0YUNsaWVudFxuICApIHtcbiAgICB0aGlzLmNhY2hlTmFtZSA9IGNhY2hlTmFtZTtcbiAgICB0aGlzLmxlYWRlcmJvYXJkTmFtZSA9IGxlYWRlcmJvYXJkTmFtZTtcbiAgICB0aGlzLmRhdGFDbGllbnQgPSBkYXRhQ2xpZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgZWxlbWVudHMgaW4gYSBsZWFkZXJib2FyZCBvciBpbnNlcnRzIGVsZW1lbnRzIGlmIHRoZXkgZG8gbm90IGFscmVhZHkgZXhpc3QuXG4gICAqIFRoZSBsZWFkZXJib2FyZCBpcyBhbHNvIGNyZWF0ZWQgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICogTm90ZTogY2FuIHVwc2VydCBhIG1heGltdW0gb2YgODE5MiBlbGVtZW50cyBhdCBhIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7TWFwPG51bWJlciwgbnVtYmVyPn0gZWxlbWVudHMgLSBUaGUgSUQtPnNjb3JlIHBhaXJzIHRvIGFkZCB0byB0aGUgbGVhZGVyYm9hcmQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPExlYWRlcmJvYXJkVXBzZXJ0LlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgTGVhZGVyYm9hcmRVcHNlcnQuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIExlYWRlcmJvYXJkVXBzZXJ0LkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHVwc2VydChcbiAgICBlbGVtZW50czogUmVjb3JkPG51bWJlciwgbnVtYmVyPiB8IE1hcDxudW1iZXIsIG51bWJlcj5cbiAgKTogUHJvbWlzZTxMZWFkZXJib2FyZFVwc2VydC5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRhdGFDbGllbnQudXBzZXJ0KFxuICAgICAgdGhpcy5jYWNoZU5hbWUsXG4gICAgICB0aGlzLmxlYWRlcmJvYXJkTmFtZSxcbiAgICAgIGVsZW1lbnRzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGxlYWRlcmJvYXJkIGJ5IHNjb3JlLlxuICAgKiBOb3RlOiBjYW4gZmV0Y2ggYSBtYXhpbXVtIG9mIDgxOTIgZWxlbWVudHMgYXQgYSB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0xlYWRlcmJvYXJkRmV0Y2hCeVNjb3JlQ2FsbE9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1pblNjb3JlXSAtIFRoZSBtaW5pbXVtIHNjb3JlIChpbmNsdXNpdmUpIG9mIHRoZVxuICAgKiBlbGVtZW50cyB0byBmZXRjaC4gRGVmYXVsdHMgdG8gbmVnYXRpdmUgaW5maW5pdHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhTY29yZV0gLSBUaGUgbWF4aW11bSBzY29yZSAoZXhjbHVzaXZlKSBvZiB0aGVcbiAgICogZWxlbWVudHMgdG8gZmV0Y2guIERlZmF1bHRzIHRvIHBvc2l0aXZlIGluZmluaXR5LlxuICAgKiBAcGFyYW0ge0xlYWRlcmJvYXJkT3JkZXJ9IFtvcHRpb25zLm9yZGVyXSAtIFRoZSBvcmRlciB0byBmZXRjaCB0aGUgZWxlbWVudHMgaW4uXG4gICAqIERlZmF1bHRzIHRvIGFzY2VuZGluZywgbWVhbmluZyAwIGlzIHRoZSBsb3dlc3Qtc2NvcmluZyByYW5rLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMub2Zmc2V0XSAtIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBiZWZvcmVcbiAgICogcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50LiBEZWZhdWx0cyB0byAwLiBOb3RlOiB0aGlzIGlzIG5vdCB0aGUgc2NvcmUgb2ZcbiAgICogdGhlIGZpcnN0IGVsZW1lbnQgdG8gcmV0dXJuLCBidXQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiB0aGUgcmVzdWx0IHNldFxuICAgKiB0byBza2lwIGJlZm9yZSByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb3VudF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLlxuICAgKiBEZWZhdWx0cyB0byA4MTkyLCB3aGljaCBpcyB0aGUgbWF4aW11bSB0aGF0IGNhbiBiZSBmZXRjaGVkIGF0IGEgdGltZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8TGVhZGVyYm9hcmRGZXRjaC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIExlYWRlcmJvYXJkRmV0Y2guU3VjY2Vzc30gY29udGFpbmluZyB0aGUgcmVxdWVzdGVkIGVsZW1lbnRzLlxuICAgKiB7QGxpbmsgTGVhZGVyYm9hcmRGZXRjaC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBmZXRjaEJ5U2NvcmUoXG4gICAgb3B0aW9ucz86IExlYWRlcmJvYXJkRmV0Y2hCeVNjb3JlQ2FsbE9wdGlvbnNcbiAgKTogUHJvbWlzZTxMZWFkZXJib2FyZEZldGNoLlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGF0YUNsaWVudC5mZXRjaEJ5U2NvcmUoXG4gICAgICB0aGlzLmNhY2hlTmFtZSxcbiAgICAgIHRoaXMubGVhZGVyYm9hcmROYW1lLFxuICAgICAgb3B0aW9ucz8ubWluU2NvcmUsXG4gICAgICBvcHRpb25zPy5tYXhTY29yZSxcbiAgICAgIG9wdGlvbnM/Lm9yZGVyLFxuICAgICAgb3B0aW9ucz8ub2Zmc2V0LFxuICAgICAgb3B0aW9ucz8uY291bnRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gbGVhZGVyYm9hcmQgYnkgaW5kZXggKHJhbmspLlxuICAgKiBOb3RlOiBjYW4gZmV0Y2ggYSBtYXhpbXVtIG9mIDgxOTIgZWxlbWVudHMgYXQgYSB0aW1lIGFuZCByYW5rXG4gICAqIGlzIDAtYmFzZWQgKGluZGV4IGJlZ2lucyBhdCAwKS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydFJhbmtdIC0gVGhlIHJhbmsgb2YgdGhlIGZpcnN0IGVsZW1lbnQgdG9cbiAgICogZmV0Y2guIFRoaXMgcmFuayBpcyBpbmNsdXNpdmUsIGllIHRoZSBlbGVtZW50IGF0IHRoaXMgcmFua1xuICAgKiB3aWxsIGJlIGZldGNoZWQuIFJhbmtzIGNhbiBiZSB1c2VkIHRvIG1hbnVhbGx5IHBhZ2luYXRlIHRocm91Z2ggdGhlIGxlYWRlcmJvYXJkXG4gICAqIGluIGJhdGNoZXMgb2YgODE5MiBlbGVtZW50cyAoZS5nLiByZXF1ZXN0IDAtODE5MiwgdGhlbiA4MTkyLTE2Mzg0LCBldGMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZFJhbmtdIC0gVGhlIHJhbmsgb2YgdGhlIGxhc3QgZWxlbWVudCB0byBmZXRjaC5cbiAgICogVGhpcyByYW5rIGlzIGV4Y2x1c2l2ZSwgaWUgdGhlIGVsZW1lbnQgYXQgdGhpcyByYW5rIHdpbGwgbm90IGJlIGZldGNoZWQuXG4gICAqIFJhbmtzIGNhbiBiZSB1c2VkIHRvIG1hbnVhbGx5IHBhZ2luYXRlIHRocm91Z2ggdGhlIGxlYWRlcmJvYXJkXG4gICAqIGluIGJhdGNoZXMgb2YgODE5MiBlbGVtZW50cyAoZS5nLiByZXF1ZXN0IDAtODE5MiwgdGhlbiA4MTkyLTE2Mzg0LCBldGMpLlxuICAgKiBAcGFyYW0ge0xlYWRlcmJvYXJkRmV0Y2hCeVJhbmtPcHRpb25zfSBvcHRpb25zXG4gICAqIEBwYXJhbSB7TGVhZGVyYm9hcmRPcmRlcn0gW29wdGlvbnMub3JkZXJdIC0gVGhlIG9yZGVyIHRvIGZldGNoIHRoZSBlbGVtZW50cyBpbi5cbiAgICogRGVmYXVsdHMgdG8gYXNjZW5kaW5nLCBtZWFuaW5nIDAgaXMgdGhlIGxvd2VzdC1zY29yaW5nIHJhbmsuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPExlYWRlcmJvYXJkRmV0Y2guUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBMZWFkZXJib2FyZEZldGNoLlN1Y2Nlc3N9IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3RlZCBlbGVtZW50cy5cbiAgICoge0BsaW5rIExlYWRlcmJvYXJkRmV0Y2guRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZmV0Y2hCeVJhbmsoXG4gICAgc3RhcnRSYW5rOiBudW1iZXIsXG4gICAgZW5kUmFuazogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiBMZWFkZXJib2FyZEZldGNoQnlSYW5rQ2FsbE9wdGlvbnNcbiAgKTogUHJvbWlzZTxMZWFkZXJib2FyZEZldGNoLlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGF0YUNsaWVudC5mZXRjaEJ5UmFuayhcbiAgICAgIHRoaXMuY2FjaGVOYW1lLFxuICAgICAgdGhpcy5sZWFkZXJib2FyZE5hbWUsXG4gICAgICBzdGFydFJhbmssXG4gICAgICBlbmRSYW5rLFxuICAgICAgb3B0aW9ucz8ub3JkZXJcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2sgdXAgdGhlIHJhbmsgb2YgYW4gZWxlbWVudCBpbiB0aGUgbGVhZGVyYm9hcmQgZ2l2ZW4gdGhlIGVsZW1lbnQgaWQuXG4gICAqIE5vdGU6IHJhbmsgaXMgMC1iYXNlZCAoaW5kZXggYmVnaW5zIGF0IDApLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaWRzIC0gVGhlIGlkcyBvZiB0aGUgZWxlbWVudHMgd2hvc2UgcmFuayB3ZSBhcmUgcmV0cmlldmluZy5cbiAgICogQHBhcmFtIHtMZWFkZXJib2FyZEdldFJhbmtDYWxsT3B0aW9uc30gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0xlYWRlcmJvYXJkT3JkZXJ9IFtvcHRpb25zLm9yZGVyXSAtIFRoZSBvcmRlciB0byBmZXRjaCB0aGUgZWxlbWVudHMgaW4uXG4gICAqIERlZmF1bHRzIHRvIGFzY2VuZGluZywgbWVhbmluZyAwIGlzIHRoZSBsb3dlc3Qtc2NvcmluZyByYW5rLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMZWFkZXJib2FyZEZldGNoLlJlc3BvbnNlPn1cbiAgICoge0BsaW5rIExlYWRlcmJvYXJkRmV0Y2guU3VjY2Vzc30gY29udGFpbmluZyB0aGUgcmVxdWVzdGVkIGVsZW1lbnRzLlxuICAgKiB7QGxpbmsgTGVhZGVyYm9hcmRGZXRjaC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRSYW5rKFxuICAgIGlkczogQXJyYXk8bnVtYmVyPixcbiAgICBvcHRpb25zPzogTGVhZGVyYm9hcmRHZXRSYW5rQ2FsbE9wdGlvbnNcbiAgKTogUHJvbWlzZTxMZWFkZXJib2FyZEZldGNoLlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGF0YUNsaWVudC5nZXRSYW5rKFxuICAgICAgdGhpcy5jYWNoZU5hbWUsXG4gICAgICB0aGlzLmxlYWRlcmJvYXJkTmFtZSxcbiAgICAgIGlkcyxcbiAgICAgIG9wdGlvbnM/Lm9yZGVyXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBsZW5ndGggKG51bWJlciBvZiBpdGVtcykgb2YgbGVhZGVyYm9hcmRcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TGVhZGVyYm9hcmRMZW5ndGguUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgTGVhZGVyYm9hcmRMZW5ndGguU3VjY2Vzc30gY29udGFpbmluZyB0aGUgbGVuZ3RoIGlmIHRoZSBsZWFkZXJib2FyZCBleGlzdHMuXG4gICAqIHtAbGluayBMZWFkZXJib2FyZExlbmd0aC5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBsZW5ndGgoKTogUHJvbWlzZTxMZWFkZXJib2FyZExlbmd0aC5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRhdGFDbGllbnQubGVuZ3RoKHRoaXMuY2FjaGVOYW1lLCB0aGlzLmxlYWRlcmJvYXJkTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIG11bHRpcGxlIGVsZW1lbnRzIGZyb20gdGhlIGdpdmVuIGxlYWRlcmJvYXJkXG4gICAqIE5vdGU6IGNhbiByZW1vdmUgYSBtYXhpbXVtIG9mIDgxOTIgZWxlbWVudHMgYXQgYSB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlkcyAtIFRoZSBJRHMgb2YgdGhlIGVsZW1lbnRzIHRvIHJlbW92ZSBmcm9tIHRoZSBsZWFkZXJib2FyZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8TGVhZGVyYm9hcmRSZW1vdmVFbGVtZW50cy5SZXNwb25zZT59XG4gICAqIHtAbGluayBMZWFkZXJib2FyZFJlbW92ZUVsZW1lbnRzLlN1Y2Nlc3N9IGlmIHRoZSBlbGVtZW50cyB3ZXJlIHN1Y2Nlc3NmdWxseSByZW1vdmVkLlxuICAgKiB7QGxpbmsgTGVhZGVyYm9hcmRSZW1vdmVFbGVtZW50cy5FcnJvcn0gb24gZmFpbHVyZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyByZW1vdmVFbGVtZW50cyhcbiAgICBpZHM6IEFycmF5PG51bWJlcj5cbiAgKTogUHJvbWlzZTxMZWFkZXJib2FyZFJlbW92ZUVsZW1lbnRzLlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGF0YUNsaWVudC5yZW1vdmVFbGVtZW50cyhcbiAgICAgIHRoaXMuY2FjaGVOYW1lLFxuICAgICAgdGhpcy5sZWFkZXJib2FyZE5hbWUsXG4gICAgICBpZHNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSB0aGUgZ2l2ZW4gbGVhZGVyYm9hcmRcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TGVhZGVyYm9hcmREZWxldGUuUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgTGVhZGVyYm9hcmREZWxldGUuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIExlYWRlcmJvYXJkRGVsZXRlLkVycm9yfSBvbiBmYWlsdXJlLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGRlbGV0ZSgpOiBQcm9taXNlPExlYWRlcmJvYXJkRGVsZXRlLlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGF0YUNsaWVudC5kZWxldGUodGhpcy5jYWNoZU5hbWUsIHRoaXMubGVhZGVyYm9hcmROYW1lKTtcbiAgfVxufVxuIl19