"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractVectorIndexClient = void 0;
class AbstractVectorIndexClient {
    constructor(controlClient, dataClient) {
        this.controlClient = controlClient;
        this.dataClient = dataClient;
    }
    /**
     * Creates a vector index if it does not exist.
     *
     * Remark on the choice of similarity metric:
     * - Cosine similarity is appropriate for most embedding models as they tend to be optimized
     *     for this metric.
     * - If the vectors are unit normalized, cosine similarity is equivalent to inner product.
     *     If your vectors are already unit normalized, you can use inner product to improve
     *     performance.
     * - Euclidean similarity, the sum of squared differences, is appropriate for datasets where
     *     this metric is meaningful. For example, if the vectors represent images, and the
     *     embedding model is trained to optimize the euclidean distance between images, then
     *     euclidean similarity is appropriate.
     *
     * @param {string} indexName - The vector index to be created.
     * @param {number} numDimensions - Number of dimensions per vector.
     * @param {VectorSimilarityMetric} similarityMetric - The metric used to
     * quantify the distance between vectors. Can be cosine similarity,
     * inner product, or euclidean similarity. Defaults to cosine similarity.
     * @returns {Promise<CreateVectorIndex.Response>} -
     * {@link CreateVectorIndex.Success} on success.
     * {@link CreateVectorIndex.AlreadyExists} if the cache already exists.
     * {@link CreateVectorIndex.Error} on failure.
     */
    async createIndex(indexName, numDimensions, similarityMetric) {
        return await this.controlClient.createIndex(indexName, numDimensions, similarityMetric);
    }
    /**
     * Lists all vector indexes.
     *
     * @returns {Promise<ListVectorIndexes.Response>} -
     * {@link ListVectorIndexes.Success} containing the list on success.
     * {@link ListVectorIndexes.Error} on error.
     */
    async listIndexes() {
        return await this.controlClient.listIndexes();
    }
    /**
     * Deletes a vector index and all the items stored in it.
     *
     * @param {string} indexName - The name of the vector index to delete.
     * @returns {Promise<DeleteVectorIndex.Response>} -
     * {@link DeleteVectorIndex.Success} on success.
     * {@link DeleteVectorIndex.Error} on error.
     */
    async deleteIndex(indexName) {
        return await this.controlClient.deleteIndex(indexName);
    }
    /**
     * Counts the number of items in a vector index.
     *
     * Note that if the index does not exist, an error with
     * {@link MomentoErrorCode} `NOT_FOUND` error will be returned.
     *
     * @param indexName - Name of the index to count the items in.
     * @returns {Promise<VectorCountItems.Response>} -
     * {@link VectorCountItems.Success} on success.
     * {@link VectorCountItems.Error} on error.
     */
    async countItems(indexName) {
        return await this.dataClient.countItems(indexName);
    }
    /**
     * Upserts a batch of items into a vector index.
     *
     * If an item with the same ID already exists in the index, it will be replaced.
     * Otherwise, it will be added to the index.
     *
     * @param {string} indexName - Name of the index to upsert the items into.
     * @param {Array<VectorIndexItem>} items - The items to be upserted into the index.
     * @returns {Promise<VectorUpsertItemBatch.Response>} -
     * {@link VectorUpsertItemBatch.Success} on success.
     * {@link VectorUpsertItemBatch.Error} on error.
     */
    async upsertItemBatch(indexName, items) {
        return await this.dataClient.upsertItemBatch(indexName, items);
    }
    /**
     * Searches for the most similar vectors to the query vector in the index.
     *
     * Ranks the vectors according to the similarity metric specified when the
     * index was created.
     *
     * @param {string} indexName - Name of the index to search in.
     * @param {Array<number>} queryVector - The vector to search for.
     * @param {SearchOptions} options - Optional search arguments, including
     * the number of results to return, metadata fields to return, and a score
     * threshold to filter results by.
     * @returns {Promise<VectorSearch.Response>} -
     * {@link VectorSearch.Success} on success.
     * {@link VectorSearch.Error} on error.
     */
    async search(indexName, queryVector, options) {
        return await this.dataClient.search(indexName, queryVector, options);
    }
    /**
     * Searches for the most similar vectors to the query vector in the index.
     *
     * Ranks the vectors according to the similarity metric specified when the
     * index was created.
     * Also returns the vectors associated with each result.
     *
     * @param indexName - Name of the index to search in.
     * @param queryVector - The vector to search for.
     * @param options - Optional search arguments, including
     * the number of results to return, metadata fields to return, and a score
     * threshold to filter results by.
     * @returns {Promise<VectorSearchAndFetchVectors.Response>} -
     * {@link VectorSearchAndFetchVectors.Success} on success.
     * {@link VectorSearchAndFetchVectors.Error} on error.
     */
    async searchAndFetchVectors(indexName, queryVector, options) {
        return await this.dataClient.searchAndFetchVectors(indexName, queryVector, options);
    }
    /**
     * Deletes a batch of items from a vector index.
     * Deletes any and all items with the given IDs from the index.
     *
     * @param {string} indexName - Name of the index to delete the items from.
     * @param {VectorFilterExpression | Array<string>} filter - A filter expression to match the items to be deleted
     * or an array of item IDs to be deleted.
     * @returns {Promise<VectorDeleteItemBatch.Response>}
     * {@link VectorDeleteItemBatch.Success} on success.
     * {@link VectorDeleteItemBatch.Error} on error.
     */
    async deleteItemBatch(indexName, filter) {
        return await this.dataClient.deleteItemBatch(indexName, filter);
    }
    /**
     * Gets a batch of items from a vector index by ID.
     *
     * @param indexName - Name of the index to get the items from.
     * @param filter - The IDs of the items to be retrieved from the index.
     * @returns {Promise<VectorGetItemBatch.Response>}
     * {@link VectorGetItemBatch.Success} on success, with the found items.
     * {@link VectorGetItemBatch.Error} on error.
     */
    async getItemBatch(indexName, filter) {
        return await this.dataClient.getItemBatch(indexName, filter);
    }
    /**
     * Gets metadata for a batch of items from a vector index by ID.
     *
     * @param indexName - Name of the index to get the items from.
     * @param filter - The IDs of the items to be retrieved from the index.
     * @returns {Promise<VectorGetItemMetadataBatch.Response>}
     * {@link VectorGetItemMetadataBatch.Success} on success, with the found item metadata.
     * {@link VectorGetItemMetadataBatch.Error} on error.
     */
    async getItemMetadataBatch(indexName, filter) {
        return await this.dataClient.getItemMetadataBatch(indexName, filter);
    }
}
exports.AbstractVectorIndexClient = AbstractVectorIndexClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWJzdHJhY3RWZWN0b3JJbmRleENsaWVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9pbnRlcm5hbC9jbGllbnRzL3ZlY3Rvci9BYnN0cmFjdFZlY3RvckluZGV4Q2xpZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQXdCQSxNQUFzQix5QkFBeUI7SUFNN0MsWUFDRSxhQUF3QyxFQUN4QyxVQUFrQztRQUVsQyxJQUFJLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQztRQUNuQyxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztJQUMvQixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BdUJHO0lBQ0ksS0FBSyxDQUFDLFdBQVcsQ0FDdEIsU0FBaUIsRUFDakIsYUFBcUIsRUFDckIsZ0JBQXlDO1FBRXpDLE9BQU8sTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FDekMsU0FBUyxFQUNULGFBQWEsRUFDYixnQkFBZ0IsQ0FDakIsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxLQUFLLENBQUMsV0FBVztRQUN0QixPQUFPLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNoRCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLEtBQUssQ0FBQyxXQUFXLENBQ3RCLFNBQWlCO1FBRWpCLE9BQU8sTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLEtBQUssQ0FBQyxVQUFVLENBQ3JCLFNBQWlCO1FBRWpCLE9BQU8sTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSSxLQUFLLENBQUMsZUFBZSxDQUMxQixTQUFpQixFQUNqQixLQUE2QjtRQUU3QixPQUFPLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7T0FjRztJQUNJLEtBQUssQ0FBQyxNQUFNLENBQ2pCLFNBQWlCLEVBQ2pCLFdBQTBCLEVBQzFCLE9BQXVCO1FBRXZCLE9BQU8sTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7O09BZUc7SUFDSSxLQUFLLENBQUMscUJBQXFCLENBQ2hDLFNBQWlCLEVBQ2pCLFdBQXFCLEVBQ3JCLE9BQW1DO1FBRW5DLE9BQU8sTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLHFCQUFxQixDQUNoRCxTQUFTLEVBQ1QsV0FBVyxFQUNYLE9BQU8sQ0FDUixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSSxLQUFLLENBQUMsZUFBZSxDQUMxQixTQUFpQixFQUNqQixNQUE4QztRQUU5QyxPQUFPLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLEtBQUssQ0FBQyxZQUFZLENBQ3ZCLFNBQWlCLEVBQ2pCLE1BQWdCO1FBRWhCLE9BQU8sTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDL0QsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksS0FBSyxDQUFDLG9CQUFvQixDQUMvQixTQUFpQixFQUNqQixNQUFnQjtRQUVoQixPQUFPLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDdkUsQ0FBQztDQUNGO0FBbk5ELDhEQW1OQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENyZWF0ZVZlY3RvckluZGV4LFxuICBEZWxldGVWZWN0b3JJbmRleCxcbiAgTGlzdFZlY3RvckluZGV4ZXMsXG4gIFZlY3RvckNvdW50SXRlbXMsXG4gIFZlY3RvckRlbGV0ZUl0ZW1CYXRjaCxcbiAgVmVjdG9yRmlsdGVyRXhwcmVzc2lvbixcbiAgVmVjdG9yR2V0SXRlbUJhdGNoLFxuICBWZWN0b3JHZXRJdGVtTWV0YWRhdGFCYXRjaCxcbiAgVmVjdG9yU2VhcmNoLFxuICBWZWN0b3JTZWFyY2hBbmRGZXRjaFZlY3RvcnMsXG4gIFZlY3RvclVwc2VydEl0ZW1CYXRjaCxcbn0gZnJvbSAnLi4vLi4vLi4nO1xuaW1wb3J0IHtcbiAgSVZlY3RvckluZGV4Q2xpZW50LFxuICBTZWFyY2hPcHRpb25zLFxufSBmcm9tICcuLi8uLi8uLi9jbGllbnRzL0lWZWN0b3JJbmRleENsaWVudCc7XG5pbXBvcnQge1xuICBJVmVjdG9ySW5kZXhDb250cm9sQ2xpZW50LFxuICBWZWN0b3JTaW1pbGFyaXR5TWV0cmljLFxufSBmcm9tICcuL0lWZWN0b3JJbmRleENvbnRyb2xDbGllbnQnO1xuaW1wb3J0IHtWZWN0b3JJbmRleEl0ZW19IGZyb20gJy4uLy4uLy4uL21lc3NhZ2VzL3ZlY3Rvci1pbmRleCc7XG5pbXBvcnQge0lWZWN0b3JJbmRleERhdGFDbGllbnR9IGZyb20gJy4vSVZlY3RvckluZGV4RGF0YUNsaWVudCc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdFZlY3RvckluZGV4Q2xpZW50XG4gIGltcGxlbWVudHMgSVZlY3RvckluZGV4Q2xpZW50LCBJVmVjdG9ySW5kZXhEYXRhQ2xpZW50XG57XG4gIHByb3RlY3RlZCByZWFkb25seSBjb250cm9sQ2xpZW50OiBJVmVjdG9ySW5kZXhDb250cm9sQ2xpZW50O1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGF0YUNsaWVudDogSVZlY3RvckluZGV4RGF0YUNsaWVudDtcblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoXG4gICAgY29udHJvbENsaWVudDogSVZlY3RvckluZGV4Q29udHJvbENsaWVudCxcbiAgICBkYXRhQ2xpZW50OiBJVmVjdG9ySW5kZXhEYXRhQ2xpZW50XG4gICkge1xuICAgIHRoaXMuY29udHJvbENsaWVudCA9IGNvbnRyb2xDbGllbnQ7XG4gICAgdGhpcy5kYXRhQ2xpZW50ID0gZGF0YUNsaWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdmVjdG9yIGluZGV4IGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBSZW1hcmsgb24gdGhlIGNob2ljZSBvZiBzaW1pbGFyaXR5IG1ldHJpYzpcbiAgICogLSBDb3NpbmUgc2ltaWxhcml0eSBpcyBhcHByb3ByaWF0ZSBmb3IgbW9zdCBlbWJlZGRpbmcgbW9kZWxzIGFzIHRoZXkgdGVuZCB0byBiZSBvcHRpbWl6ZWRcbiAgICogICAgIGZvciB0aGlzIG1ldHJpYy5cbiAgICogLSBJZiB0aGUgdmVjdG9ycyBhcmUgdW5pdCBub3JtYWxpemVkLCBjb3NpbmUgc2ltaWxhcml0eSBpcyBlcXVpdmFsZW50IHRvIGlubmVyIHByb2R1Y3QuXG4gICAqICAgICBJZiB5b3VyIHZlY3RvcnMgYXJlIGFscmVhZHkgdW5pdCBub3JtYWxpemVkLCB5b3UgY2FuIHVzZSBpbm5lciBwcm9kdWN0IHRvIGltcHJvdmVcbiAgICogICAgIHBlcmZvcm1hbmNlLlxuICAgKiAtIEV1Y2xpZGVhbiBzaW1pbGFyaXR5LCB0aGUgc3VtIG9mIHNxdWFyZWQgZGlmZmVyZW5jZXMsIGlzIGFwcHJvcHJpYXRlIGZvciBkYXRhc2V0cyB3aGVyZVxuICAgKiAgICAgdGhpcyBtZXRyaWMgaXMgbWVhbmluZ2Z1bC4gRm9yIGV4YW1wbGUsIGlmIHRoZSB2ZWN0b3JzIHJlcHJlc2VudCBpbWFnZXMsIGFuZCB0aGVcbiAgICogICAgIGVtYmVkZGluZyBtb2RlbCBpcyB0cmFpbmVkIHRvIG9wdGltaXplIHRoZSBldWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiBpbWFnZXMsIHRoZW5cbiAgICogICAgIGV1Y2xpZGVhbiBzaW1pbGFyaXR5IGlzIGFwcHJvcHJpYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5kZXhOYW1lIC0gVGhlIHZlY3RvciBpbmRleCB0byBiZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtRGltZW5zaW9ucyAtIE51bWJlciBvZiBkaW1lbnNpb25zIHBlciB2ZWN0b3IuXG4gICAqIEBwYXJhbSB7VmVjdG9yU2ltaWxhcml0eU1ldHJpY30gc2ltaWxhcml0eU1ldHJpYyAtIFRoZSBtZXRyaWMgdXNlZCB0b1xuICAgKiBxdWFudGlmeSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB2ZWN0b3JzLiBDYW4gYmUgY29zaW5lIHNpbWlsYXJpdHksXG4gICAqIGlubmVyIHByb2R1Y3QsIG9yIGV1Y2xpZGVhbiBzaW1pbGFyaXR5LiBEZWZhdWx0cyB0byBjb3NpbmUgc2ltaWxhcml0eS5cbiAgICogQHJldHVybnMge1Byb21pc2U8Q3JlYXRlVmVjdG9ySW5kZXguUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBDcmVhdGVWZWN0b3JJbmRleC5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgQ3JlYXRlVmVjdG9ySW5kZXguQWxyZWFkeUV4aXN0c30gaWYgdGhlIGNhY2hlIGFscmVhZHkgZXhpc3RzLlxuICAgKiB7QGxpbmsgQ3JlYXRlVmVjdG9ySW5kZXguRXJyb3J9IG9uIGZhaWx1cmUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY3JlYXRlSW5kZXgoXG4gICAgaW5kZXhOYW1lOiBzdHJpbmcsXG4gICAgbnVtRGltZW5zaW9uczogbnVtYmVyLFxuICAgIHNpbWlsYXJpdHlNZXRyaWM/OiBWZWN0b3JTaW1pbGFyaXR5TWV0cmljXG4gICk6IFByb21pc2U8Q3JlYXRlVmVjdG9ySW5kZXguUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cm9sQ2xpZW50LmNyZWF0ZUluZGV4KFxuICAgICAgaW5kZXhOYW1lLFxuICAgICAgbnVtRGltZW5zaW9ucyxcbiAgICAgIHNpbWlsYXJpdHlNZXRyaWNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RzIGFsbCB2ZWN0b3IgaW5kZXhlcy5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8TGlzdFZlY3RvckluZGV4ZXMuUmVzcG9uc2U+fSAtXG4gICAqIHtAbGluayBMaXN0VmVjdG9ySW5kZXhlcy5TdWNjZXNzfSBjb250YWluaW5nIHRoZSBsaXN0IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBMaXN0VmVjdG9ySW5kZXhlcy5FcnJvcn0gb24gZXJyb3IuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbGlzdEluZGV4ZXMoKTogUHJvbWlzZTxMaXN0VmVjdG9ySW5kZXhlcy5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyb2xDbGllbnQubGlzdEluZGV4ZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgdmVjdG9yIGluZGV4IGFuZCBhbGwgdGhlIGl0ZW1zIHN0b3JlZCBpbiBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGluZGV4TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB2ZWN0b3IgaW5kZXggdG8gZGVsZXRlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxEZWxldGVWZWN0b3JJbmRleC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIERlbGV0ZVZlY3RvckluZGV4LlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBEZWxldGVWZWN0b3JJbmRleC5FcnJvcn0gb24gZXJyb3IuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVsZXRlSW5kZXgoXG4gICAgaW5kZXhOYW1lOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxEZWxldGVWZWN0b3JJbmRleC5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyb2xDbGllbnQuZGVsZXRlSW5kZXgoaW5kZXhOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBpdGVtcyBpbiBhIHZlY3RvciBpbmRleC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHRoZSBpbmRleCBkb2VzIG5vdCBleGlzdCwgYW4gZXJyb3Igd2l0aFxuICAgKiB7QGxpbmsgTW9tZW50b0Vycm9yQ29kZX0gYE5PVF9GT1VORGAgZXJyb3Igd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4IHRvIGNvdW50IHRoZSBpdGVtcyBpbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8VmVjdG9yQ291bnRJdGVtcy5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIFZlY3RvckNvdW50SXRlbXMuU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIFZlY3RvckNvdW50SXRlbXMuRXJyb3J9IG9uIGVycm9yLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNvdW50SXRlbXMoXG4gICAgaW5kZXhOYW1lOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxWZWN0b3JDb3VudEl0ZW1zLlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGF0YUNsaWVudC5jb3VudEl0ZW1zKGluZGV4TmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogVXBzZXJ0cyBhIGJhdGNoIG9mIGl0ZW1zIGludG8gYSB2ZWN0b3IgaW5kZXguXG4gICAqXG4gICAqIElmIGFuIGl0ZW0gd2l0aCB0aGUgc2FtZSBJRCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgaW5kZXgsIGl0IHdpbGwgYmUgcmVwbGFjZWQuXG4gICAqIE90aGVyd2lzZSwgaXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbmRleE5hbWUgLSBOYW1lIG9mIHRoZSBpbmRleCB0byB1cHNlcnQgdGhlIGl0ZW1zIGludG8uXG4gICAqIEBwYXJhbSB7QXJyYXk8VmVjdG9ySW5kZXhJdGVtPn0gaXRlbXMgLSBUaGUgaXRlbXMgdG8gYmUgdXBzZXJ0ZWQgaW50byB0aGUgaW5kZXguXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFZlY3RvclVwc2VydEl0ZW1CYXRjaC5SZXNwb25zZT59IC1cbiAgICoge0BsaW5rIFZlY3RvclVwc2VydEl0ZW1CYXRjaC5TdWNjZXNzfSBvbiBzdWNjZXNzLlxuICAgKiB7QGxpbmsgVmVjdG9yVXBzZXJ0SXRlbUJhdGNoLkVycm9yfSBvbiBlcnJvci5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB1cHNlcnRJdGVtQmF0Y2goXG4gICAgaW5kZXhOYW1lOiBzdHJpbmcsXG4gICAgaXRlbXM6IEFycmF5PFZlY3RvckluZGV4SXRlbT5cbiAgKTogUHJvbWlzZTxWZWN0b3JVcHNlcnRJdGVtQmF0Y2guUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kYXRhQ2xpZW50LnVwc2VydEl0ZW1CYXRjaChpbmRleE5hbWUsIGl0ZW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3IgdGhlIG1vc3Qgc2ltaWxhciB2ZWN0b3JzIHRvIHRoZSBxdWVyeSB2ZWN0b3IgaW4gdGhlIGluZGV4LlxuICAgKlxuICAgKiBSYW5rcyB0aGUgdmVjdG9ycyBhY2NvcmRpbmcgdG8gdGhlIHNpbWlsYXJpdHkgbWV0cmljIHNwZWNpZmllZCB3aGVuIHRoZVxuICAgKiBpbmRleCB3YXMgY3JlYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4IHRvIHNlYXJjaCBpbi5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBxdWVyeVZlY3RvciAtIFRoZSB2ZWN0b3IgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtTZWFyY2hPcHRpb25zfSBvcHRpb25zIC0gT3B0aW9uYWwgc2VhcmNoIGFyZ3VtZW50cywgaW5jbHVkaW5nXG4gICAqIHRoZSBudW1iZXIgb2YgcmVzdWx0cyB0byByZXR1cm4sIG1ldGFkYXRhIGZpZWxkcyB0byByZXR1cm4sIGFuZCBhIHNjb3JlXG4gICAqIHRocmVzaG9sZCB0byBmaWx0ZXIgcmVzdWx0cyBieS5cbiAgICogQHJldHVybnMge1Byb21pc2U8VmVjdG9yU2VhcmNoLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgVmVjdG9yU2VhcmNoLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBWZWN0b3JTZWFyY2guRXJyb3J9IG9uIGVycm9yLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNlYXJjaChcbiAgICBpbmRleE5hbWU6IHN0cmluZyxcbiAgICBxdWVyeVZlY3RvcjogQXJyYXk8bnVtYmVyPixcbiAgICBvcHRpb25zPzogU2VhcmNoT3B0aW9uc1xuICApOiBQcm9taXNlPFZlY3RvclNlYXJjaC5SZXNwb25zZT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRhdGFDbGllbnQuc2VhcmNoKGluZGV4TmFtZSwgcXVlcnlWZWN0b3IsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGZvciB0aGUgbW9zdCBzaW1pbGFyIHZlY3RvcnMgdG8gdGhlIHF1ZXJ5IHZlY3RvciBpbiB0aGUgaW5kZXguXG4gICAqXG4gICAqIFJhbmtzIHRoZSB2ZWN0b3JzIGFjY29yZGluZyB0byB0aGUgc2ltaWxhcml0eSBtZXRyaWMgc3BlY2lmaWVkIHdoZW4gdGhlXG4gICAqIGluZGV4IHdhcyBjcmVhdGVkLlxuICAgKiBBbHNvIHJldHVybnMgdGhlIHZlY3RvcnMgYXNzb2NpYXRlZCB3aXRoIGVhY2ggcmVzdWx0LlxuICAgKlxuICAgKiBAcGFyYW0gaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXggdG8gc2VhcmNoIGluLlxuICAgKiBAcGFyYW0gcXVlcnlWZWN0b3IgLSBUaGUgdmVjdG9yIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgc2VhcmNoIGFyZ3VtZW50cywgaW5jbHVkaW5nXG4gICAqIHRoZSBudW1iZXIgb2YgcmVzdWx0cyB0byByZXR1cm4sIG1ldGFkYXRhIGZpZWxkcyB0byByZXR1cm4sIGFuZCBhIHNjb3JlXG4gICAqIHRocmVzaG9sZCB0byBmaWx0ZXIgcmVzdWx0cyBieS5cbiAgICogQHJldHVybnMge1Byb21pc2U8VmVjdG9yU2VhcmNoQW5kRmV0Y2hWZWN0b3JzLlJlc3BvbnNlPn0gLVxuICAgKiB7QGxpbmsgVmVjdG9yU2VhcmNoQW5kRmV0Y2hWZWN0b3JzLlN1Y2Nlc3N9IG9uIHN1Y2Nlc3MuXG4gICAqIHtAbGluayBWZWN0b3JTZWFyY2hBbmRGZXRjaFZlY3RvcnMuRXJyb3J9IG9uIGVycm9yLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNlYXJjaEFuZEZldGNoVmVjdG9ycyhcbiAgICBpbmRleE5hbWU6IHN0cmluZyxcbiAgICBxdWVyeVZlY3RvcjogbnVtYmVyW10sXG4gICAgb3B0aW9ucz86IFNlYXJjaE9wdGlvbnMgfCB1bmRlZmluZWRcbiAgKTogUHJvbWlzZTxWZWN0b3JTZWFyY2hBbmRGZXRjaFZlY3RvcnMuUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kYXRhQ2xpZW50LnNlYXJjaEFuZEZldGNoVmVjdG9ycyhcbiAgICAgIGluZGV4TmFtZSxcbiAgICAgIHF1ZXJ5VmVjdG9yLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhIGJhdGNoIG9mIGl0ZW1zIGZyb20gYSB2ZWN0b3IgaW5kZXguXG4gICAqIERlbGV0ZXMgYW55IGFuZCBhbGwgaXRlbXMgd2l0aCB0aGUgZ2l2ZW4gSURzIGZyb20gdGhlIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXggdG8gZGVsZXRlIHRoZSBpdGVtcyBmcm9tLlxuICAgKiBAcGFyYW0ge1ZlY3RvckZpbHRlckV4cHJlc3Npb24gfCBBcnJheTxzdHJpbmc+fSBmaWx0ZXIgLSBBIGZpbHRlciBleHByZXNzaW9uIHRvIG1hdGNoIHRoZSBpdGVtcyB0byBiZSBkZWxldGVkXG4gICAqIG9yIGFuIGFycmF5IG9mIGl0ZW0gSURzIHRvIGJlIGRlbGV0ZWQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFZlY3RvckRlbGV0ZUl0ZW1CYXRjaC5SZXNwb25zZT59XG4gICAqIHtAbGluayBWZWN0b3JEZWxldGVJdGVtQmF0Y2guU3VjY2Vzc30gb24gc3VjY2Vzcy5cbiAgICoge0BsaW5rIFZlY3RvckRlbGV0ZUl0ZW1CYXRjaC5FcnJvcn0gb24gZXJyb3IuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGVsZXRlSXRlbUJhdGNoKFxuICAgIGluZGV4TmFtZTogc3RyaW5nLFxuICAgIGZpbHRlcjogVmVjdG9yRmlsdGVyRXhwcmVzc2lvbiB8IEFycmF5PHN0cmluZz5cbiAgKTogUHJvbWlzZTxWZWN0b3JEZWxldGVJdGVtQmF0Y2guUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kYXRhQ2xpZW50LmRlbGV0ZUl0ZW1CYXRjaChpbmRleE5hbWUsIGZpbHRlcik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIGJhdGNoIG9mIGl0ZW1zIGZyb20gYSB2ZWN0b3IgaW5kZXggYnkgSUQuXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleE5hbWUgLSBOYW1lIG9mIHRoZSBpbmRleCB0byBnZXQgdGhlIGl0ZW1zIGZyb20uXG4gICAqIEBwYXJhbSBmaWx0ZXIgLSBUaGUgSURzIG9mIHRoZSBpdGVtcyB0byBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgaW5kZXguXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFZlY3RvckdldEl0ZW1CYXRjaC5SZXNwb25zZT59XG4gICAqIHtAbGluayBWZWN0b3JHZXRJdGVtQmF0Y2guU3VjY2Vzc30gb24gc3VjY2Vzcywgd2l0aCB0aGUgZm91bmQgaXRlbXMuXG4gICAqIHtAbGluayBWZWN0b3JHZXRJdGVtQmF0Y2guRXJyb3J9IG9uIGVycm9yLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldEl0ZW1CYXRjaChcbiAgICBpbmRleE5hbWU6IHN0cmluZyxcbiAgICBmaWx0ZXI6IHN0cmluZ1tdXG4gICk6IFByb21pc2U8VmVjdG9yR2V0SXRlbUJhdGNoLlJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGF0YUNsaWVudC5nZXRJdGVtQmF0Y2goaW5kZXhOYW1lLCBmaWx0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgbWV0YWRhdGEgZm9yIGEgYmF0Y2ggb2YgaXRlbXMgZnJvbSBhIHZlY3RvciBpbmRleCBieSBJRC5cbiAgICpcbiAgICogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4IHRvIGdldCB0aGUgaXRlbXMgZnJvbS5cbiAgICogQHBhcmFtIGZpbHRlciAtIFRoZSBJRHMgb2YgdGhlIGl0ZW1zIHRvIGJlIHJldHJpZXZlZCBmcm9tIHRoZSBpbmRleC5cbiAgICogQHJldHVybnMge1Byb21pc2U8VmVjdG9yR2V0SXRlbU1ldGFkYXRhQmF0Y2guUmVzcG9uc2U+fVxuICAgKiB7QGxpbmsgVmVjdG9yR2V0SXRlbU1ldGFkYXRhQmF0Y2guU3VjY2Vzc30gb24gc3VjY2Vzcywgd2l0aCB0aGUgZm91bmQgaXRlbSBtZXRhZGF0YS5cbiAgICoge0BsaW5rIFZlY3RvckdldEl0ZW1NZXRhZGF0YUJhdGNoLkVycm9yfSBvbiBlcnJvci5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRJdGVtTWV0YWRhdGFCYXRjaChcbiAgICBpbmRleE5hbWU6IHN0cmluZyxcbiAgICBmaWx0ZXI6IHN0cmluZ1tdXG4gICk6IFByb21pc2U8VmVjdG9yR2V0SXRlbU1ldGFkYXRhQmF0Y2guUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kYXRhQ2xpZW50LmdldEl0ZW1NZXRhZGF0YUJhdGNoKGluZGV4TmFtZSwgZmlsdGVyKTtcbiAgfVxufVxuIl19