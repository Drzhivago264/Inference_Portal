"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalSuperUserPermissions = exports.decodeAuthToken = exports.populateAllEndpointsFromBaseEndpoint = void 0;
const errors_1 = require("../../errors");
const jwt_decode_1 = require("jwt-decode");
const validators_1 = require("./validators");
const string_1 = require("./string");
const permission_scope_1 = require("../../auth/tokens/permission-scope");
function decodeAuthTokenClaims(authToken) {
    return (0, jwt_decode_1.default)(authToken);
}
function populateAllEndpointsFromBaseEndpoint(endpointOverride) {
    let prefix = '';
    if (endpointOverride.endpointPrefix) {
        prefix = `${endpointOverride.endpointPrefix}.`;
    }
    return {
        controlEndpoint: `${prefix}control.${endpointOverride.baseEndpoint}`,
        cacheEndpoint: `${prefix}cache.${endpointOverride.baseEndpoint}`,
        tokenEndpoint: `${prefix}token.${endpointOverride.baseEndpoint}`,
        vectorEndpoint: `${prefix}vector.${endpointOverride.baseEndpoint}`,
    };
}
exports.populateAllEndpointsFromBaseEndpoint = populateAllEndpointsFromBaseEndpoint;
/**
 * @param {string} token
 * @returns TokenAndEndpoints
 */
const decodeAuthToken = (token) => {
    if (!token) {
        throw new errors_1.InvalidArgumentError('malformed auth token');
    }
    try {
        // v1 api tokens don't have an endpoint as part of their claims. Instead, when the SDK returns tokens, we
        // give it to them as a base64 encoded string of '{ "api_key": "<the key>", "endpoint": "prod.momentohq.com" }'.
        // Since in the near future, most customers are going to be using these newer tokens, we are first checking to see if
        // they are base64 encoded, which will tell us that they are our v1 api tokens. If its not, we will fall back to decoding
        // it as one of our legacy jwts.
        if ((0, validators_1.isBase64)(token)) {
            const base64DecodedToken = JSON.parse((0, string_1.decodeFromBase64)(token));
            if (!base64DecodedToken.endpoint || !base64DecodedToken.api_key) {
                throw new errors_1.InvalidArgumentError('failed to parse token');
            }
            return {
                ...populateAllEndpointsFromBaseEndpoint({
                    baseEndpoint: base64DecodedToken.endpoint,
                }),
                authToken: base64DecodedToken.api_key,
            };
        }
        else {
            // This decode function uses generics to advertise that we will usually expect to find the LegacyClaims.  However,
            // if the token is a valid JWT but not actually one of our legacy tokens, the endpoint claims will be undefined,
            // which is why the return type for this function specifies that the controlEndpoint/cacheEndpoint may be undefined.
            const decodedLegacyToken = decodeAuthTokenClaims(token);
            return {
                controlEndpoint: decodedLegacyToken.cp,
                cacheEndpoint: decodedLegacyToken.c,
                tokenEndpoint: decodedLegacyToken.c,
                vectorEndpoint: decodedLegacyToken.c,
                authToken: token,
            };
        }
    }
    catch (e) {
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        throw new errors_1.InvalidArgumentError(`failed to parse token: ${e}`);
    }
};
exports.decodeAuthToken = decodeAuthToken;
class InternalSuperUserPermissions extends permission_scope_1.PredefinedScope {
}
exports.InternalSuperUserPermissions = InternalSuperUserPermissions;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9pbnRlcm5hbC91dGlscy9hdXRoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHlDQUFrRDtBQUNsRCwyQ0FBbUM7QUFDbkMsNkNBQXNDO0FBQ3RDLHFDQUEwQztBQUMxQyx5RUFBbUU7QUFtQm5FLFNBQVMscUJBQXFCLENBQUksU0FBaUI7SUFDakQsT0FBTyxJQUFBLG9CQUFTLEVBQUksU0FBUyxDQUFDLENBQUM7QUFDakMsQ0FBQztBQW1CRCxTQUFnQixvQ0FBb0MsQ0FDbEQsZ0JBQXNDO0lBRXRDLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztJQUNoQixJQUFJLGdCQUFnQixDQUFDLGNBQWMsRUFBRTtRQUNuQyxNQUFNLEdBQUcsR0FBRyxnQkFBZ0IsQ0FBQyxjQUFjLEdBQUcsQ0FBQztLQUNoRDtJQUNELE9BQU87UUFDTCxlQUFlLEVBQUUsR0FBRyxNQUFNLFdBQVcsZ0JBQWdCLENBQUMsWUFBWSxFQUFFO1FBQ3BFLGFBQWEsRUFBRSxHQUFHLE1BQU0sU0FBUyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUU7UUFDaEUsYUFBYSxFQUFFLEdBQUcsTUFBTSxTQUFTLGdCQUFnQixDQUFDLFlBQVksRUFBRTtRQUNoRSxjQUFjLEVBQUUsR0FBRyxNQUFNLFVBQVUsZ0JBQWdCLENBQUMsWUFBWSxFQUFFO0tBQ25FLENBQUM7QUFDSixDQUFDO0FBYkQsb0ZBYUM7QUFFRDs7O0dBR0c7QUFDSSxNQUFNLGVBQWUsR0FBRyxDQUFDLEtBQWMsRUFBcUIsRUFBRTtJQUNuRSxJQUFJLENBQUMsS0FBSyxFQUFFO1FBQ1YsTUFBTSxJQUFJLDZCQUFvQixDQUFDLHNCQUFzQixDQUFDLENBQUM7S0FDeEQ7SUFFRCxJQUFJO1FBQ0YseUdBQXlHO1FBQ3pHLGdIQUFnSDtRQUNoSCxxSEFBcUg7UUFDckgseUhBQXlIO1FBQ3pILGdDQUFnQztRQUNoQyxJQUFJLElBQUEscUJBQVEsRUFBQyxLQUFLLENBQUMsRUFBRTtZQUNuQixNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQ25DLElBQUEseUJBQWdCLEVBQUMsS0FBSyxDQUFDLENBQ0EsQ0FBQztZQUMxQixJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxJQUFJLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFO2dCQUMvRCxNQUFNLElBQUksNkJBQW9CLENBQUMsdUJBQXVCLENBQUMsQ0FBQzthQUN6RDtZQUNELE9BQU87Z0JBQ0wsR0FBRyxvQ0FBb0MsQ0FBQztvQkFDdEMsWUFBWSxFQUFFLGtCQUFrQixDQUFDLFFBQVE7aUJBQzFDLENBQUM7Z0JBQ0YsU0FBUyxFQUFFLGtCQUFrQixDQUFDLE9BQU87YUFDdEMsQ0FBQztTQUNIO2FBQU07WUFDTCxrSEFBa0g7WUFDbEgsZ0hBQWdIO1lBQ2hILG9IQUFvSDtZQUNwSCxNQUFNLGtCQUFrQixHQUFHLHFCQUFxQixDQUFlLEtBQUssQ0FBQyxDQUFDO1lBQ3RFLE9BQU87Z0JBQ0wsZUFBZSxFQUFFLGtCQUFrQixDQUFDLEVBQUU7Z0JBQ3RDLGFBQWEsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO2dCQUNuQyxhQUFhLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztnQkFDbkMsY0FBYyxFQUFFLGtCQUFrQixDQUFDLENBQUM7Z0JBQ3BDLFNBQVMsRUFBRSxLQUFLO2FBQ2pCLENBQUM7U0FDSDtLQUNGO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDViw0RUFBNEU7UUFDNUUsTUFBTSxJQUFJLDZCQUFvQixDQUFDLDBCQUEwQixDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQy9EO0FBQ0gsQ0FBQyxDQUFDO0FBekNXLFFBQUEsZUFBZSxtQkF5QzFCO0FBRUYsTUFBYSw0QkFBNkIsU0FBUSxrQ0FBZTtDQUFHO0FBQXBFLG9FQUFvRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW52YWxpZEFyZ3VtZW50RXJyb3J9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgand0RGVjb2RlIGZyb20gJ2p3dC1kZWNvZGUnO1xuaW1wb3J0IHtpc0Jhc2U2NH0gZnJvbSAnLi92YWxpZGF0b3JzJztcbmltcG9ydCB7ZGVjb2RlRnJvbUJhc2U2NH0gZnJvbSAnLi9zdHJpbmcnO1xuaW1wb3J0IHtQcmVkZWZpbmVkU2NvcGV9IGZyb20gJy4uLy4uL2F1dGgvdG9rZW5zL3Blcm1pc3Npb24tc2NvcGUnO1xuaW1wb3J0IHtCYXNlRW5kcG9pbnRPdmVycmlkZX0gZnJvbSAnLi4vLi4vYXV0aCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGVnYWN5Q2xhaW1zIHtcbiAgLyoqXG4gICAqIGNvbnRyb2wgcGxhbmUgZW5kcG9pbnRcbiAgICovXG4gIGNwOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBjYWNoZSBlbmRwb2ludFxuICAgKi9cbiAgYzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhc2U2NERlY29kZWRWMVRva2VuIHtcbiAgYXBpX2tleTogc3RyaW5nO1xuICBlbmRwb2ludDogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVBdXRoVG9rZW5DbGFpbXM8VD4oYXV0aFRva2VuOiBzdHJpbmcpOiBUIHtcbiAgcmV0dXJuIGp3dERlY29kZTxUPihhdXRoVG9rZW4pO1xufVxuXG5pbnRlcmZhY2UgVG9rZW5BbmRFbmRwb2ludHMge1xuICAvLyBJZiB3ZSBkZWNvZGUgYSBKV1QgdGhhdCBkb2Vzbid0IGFjdHVhbGx5IGhhdmUgdGhlIGNvbnRyb2xFbmRwb2ludC9jYWNoZUVuZHBvaW50IGNsYWltcywgdGhlbiB0aGV5IHdpbGwgY29tZSBiYWNrXG4gIC8vIGFzIHVuZGVmaW5lZDsgdGh1cyB3ZSBuZWVkIHRoZSB0eXBlcyBoZXJlIHRvIGJlIGBzdHJpbmcgfCB1bmRlZmluZWRgLlxuICBjb250cm9sRW5kcG9pbnQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgY2FjaGVFbmRwb2ludDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICB0b2tlbkVuZHBvaW50OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHZlY3RvckVuZHBvaW50OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGF1dGhUb2tlbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFsbEVuZHBvaW50cyB7XG4gIGNvbnRyb2xFbmRwb2ludDogc3RyaW5nO1xuICBjYWNoZUVuZHBvaW50OiBzdHJpbmc7XG4gIHRva2VuRW5kcG9pbnQ6IHN0cmluZztcbiAgdmVjdG9yRW5kcG9pbnQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHVsYXRlQWxsRW5kcG9pbnRzRnJvbUJhc2VFbmRwb2ludChcbiAgZW5kcG9pbnRPdmVycmlkZTogQmFzZUVuZHBvaW50T3ZlcnJpZGVcbik6IEFsbEVuZHBvaW50cyB7XG4gIGxldCBwcmVmaXggPSAnJztcbiAgaWYgKGVuZHBvaW50T3ZlcnJpZGUuZW5kcG9pbnRQcmVmaXgpIHtcbiAgICBwcmVmaXggPSBgJHtlbmRwb2ludE92ZXJyaWRlLmVuZHBvaW50UHJlZml4fS5gO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29udHJvbEVuZHBvaW50OiBgJHtwcmVmaXh9Y29udHJvbC4ke2VuZHBvaW50T3ZlcnJpZGUuYmFzZUVuZHBvaW50fWAsXG4gICAgY2FjaGVFbmRwb2ludDogYCR7cHJlZml4fWNhY2hlLiR7ZW5kcG9pbnRPdmVycmlkZS5iYXNlRW5kcG9pbnR9YCxcbiAgICB0b2tlbkVuZHBvaW50OiBgJHtwcmVmaXh9dG9rZW4uJHtlbmRwb2ludE92ZXJyaWRlLmJhc2VFbmRwb2ludH1gLFxuICAgIHZlY3RvckVuZHBvaW50OiBgJHtwcmVmaXh9dmVjdG9yLiR7ZW5kcG9pbnRPdmVycmlkZS5iYXNlRW5kcG9pbnR9YCxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAqIEByZXR1cm5zIFRva2VuQW5kRW5kcG9pbnRzXG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVBdXRoVG9rZW4gPSAodG9rZW4/OiBzdHJpbmcpOiBUb2tlbkFuZEVuZHBvaW50cyA9PiB7XG4gIGlmICghdG9rZW4pIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21hbGZvcm1lZCBhdXRoIHRva2VuJyk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIHYxIGFwaSB0b2tlbnMgZG9uJ3QgaGF2ZSBhbiBlbmRwb2ludCBhcyBwYXJ0IG9mIHRoZWlyIGNsYWltcy4gSW5zdGVhZCwgd2hlbiB0aGUgU0RLIHJldHVybnMgdG9rZW5zLCB3ZVxuICAgIC8vIGdpdmUgaXQgdG8gdGhlbSBhcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyBvZiAneyBcImFwaV9rZXlcIjogXCI8dGhlIGtleT5cIiwgXCJlbmRwb2ludFwiOiBcInByb2QubW9tZW50b2hxLmNvbVwiIH0nLlxuICAgIC8vIFNpbmNlIGluIHRoZSBuZWFyIGZ1dHVyZSwgbW9zdCBjdXN0b21lcnMgYXJlIGdvaW5nIHRvIGJlIHVzaW5nIHRoZXNlIG5ld2VyIHRva2Vucywgd2UgYXJlIGZpcnN0IGNoZWNraW5nIHRvIHNlZSBpZlxuICAgIC8vIHRoZXkgYXJlIGJhc2U2NCBlbmNvZGVkLCB3aGljaCB3aWxsIHRlbGwgdXMgdGhhdCB0aGV5IGFyZSBvdXIgdjEgYXBpIHRva2Vucy4gSWYgaXRzIG5vdCwgd2Ugd2lsbCBmYWxsIGJhY2sgdG8gZGVjb2RpbmdcbiAgICAvLyBpdCBhcyBvbmUgb2Ygb3VyIGxlZ2FjeSBqd3RzLlxuICAgIGlmIChpc0Jhc2U2NCh0b2tlbikpIHtcbiAgICAgIGNvbnN0IGJhc2U2NERlY29kZWRUb2tlbiA9IEpTT04ucGFyc2UoXG4gICAgICAgIGRlY29kZUZyb21CYXNlNjQodG9rZW4pXG4gICAgICApIGFzIEJhc2U2NERlY29kZWRWMVRva2VuO1xuICAgICAgaWYgKCFiYXNlNjREZWNvZGVkVG9rZW4uZW5kcG9pbnQgfHwgIWJhc2U2NERlY29kZWRUb2tlbi5hcGlfa2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignZmFpbGVkIHRvIHBhcnNlIHRva2VuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5wb3B1bGF0ZUFsbEVuZHBvaW50c0Zyb21CYXNlRW5kcG9pbnQoe1xuICAgICAgICAgIGJhc2VFbmRwb2ludDogYmFzZTY0RGVjb2RlZFRva2VuLmVuZHBvaW50LFxuICAgICAgICB9KSxcbiAgICAgICAgYXV0aFRva2VuOiBiYXNlNjREZWNvZGVkVG9rZW4uYXBpX2tleSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgZGVjb2RlIGZ1bmN0aW9uIHVzZXMgZ2VuZXJpY3MgdG8gYWR2ZXJ0aXNlIHRoYXQgd2Ugd2lsbCB1c3VhbGx5IGV4cGVjdCB0byBmaW5kIHRoZSBMZWdhY3lDbGFpbXMuICBIb3dldmVyLFxuICAgICAgLy8gaWYgdGhlIHRva2VuIGlzIGEgdmFsaWQgSldUIGJ1dCBub3QgYWN0dWFsbHkgb25lIG9mIG91ciBsZWdhY3kgdG9rZW5zLCB0aGUgZW5kcG9pbnQgY2xhaW1zIHdpbGwgYmUgdW5kZWZpbmVkLFxuICAgICAgLy8gd2hpY2ggaXMgd2h5IHRoZSByZXR1cm4gdHlwZSBmb3IgdGhpcyBmdW5jdGlvbiBzcGVjaWZpZXMgdGhhdCB0aGUgY29udHJvbEVuZHBvaW50L2NhY2hlRW5kcG9pbnQgbWF5IGJlIHVuZGVmaW5lZC5cbiAgICAgIGNvbnN0IGRlY29kZWRMZWdhY3lUb2tlbiA9IGRlY29kZUF1dGhUb2tlbkNsYWltczxMZWdhY3lDbGFpbXM+KHRva2VuKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRyb2xFbmRwb2ludDogZGVjb2RlZExlZ2FjeVRva2VuLmNwLFxuICAgICAgICBjYWNoZUVuZHBvaW50OiBkZWNvZGVkTGVnYWN5VG9rZW4uYyxcbiAgICAgICAgdG9rZW5FbmRwb2ludDogZGVjb2RlZExlZ2FjeVRva2VuLmMsXG4gICAgICAgIHZlY3RvckVuZHBvaW50OiBkZWNvZGVkTGVnYWN5VG9rZW4uYyxcbiAgICAgICAgYXV0aFRva2VuOiB0b2tlbixcbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgZmFpbGVkIHRvIHBhcnNlIHRva2VuOiAke2V9YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBJbnRlcm5hbFN1cGVyVXNlclBlcm1pc3Npb25zIGV4dGVuZHMgUHJlZGVmaW5lZFNjb3BlIHt9XG4iXX0=