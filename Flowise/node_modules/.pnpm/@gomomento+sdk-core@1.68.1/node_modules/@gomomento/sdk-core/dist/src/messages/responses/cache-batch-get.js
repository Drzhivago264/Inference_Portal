"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Error = exports.Success = exports.Response = void 0;
const response_base_1 = require("./response-base");
const TEXT_DECODER = new TextDecoder();
/**
 * Parent response type for a cache get batch request.  The
 * response object is resolved to a type-safe object of one of
 * the following subtypes:
 *
 * - {Success}
 * - {Error}
 *
 * `instanceof` type guards can be used to operate on the appropriate subtype.
 * @example
 * For example:
 * ```
 * if (response instanceof BatchGet.Error) {
 *   // Handle error as appropriate.  The compiler will smart-cast `response` to type
 *   // `BatchGet.Error` in this block, so you will have access to the properties
 *   // of the Error class; e.g. `response.errorCode()`.
 * }
 * ```
 */
class Response extends response_base_1.ResponseBase {
    values() {
        if (this instanceof Success) {
            return this.values();
        }
        return undefined;
    }
    results() {
        if (this instanceof Success) {
            return this.results();
        }
        return undefined;
    }
}
exports.Response = Response;
class _Success extends Response {
    constructor(items, keys) {
        super();
        this.items = items;
        this.keys = keys;
    }
    /**
     * Returns the status for each request in the batch as a list of CacheGet.Response objects.
     * @returns {CacheGet.Response[]}
     */
    results() {
        return this.items;
    }
    /**
     * Returns the data as a Record whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This can be used in most places where an Object is desired.  This is a convenience alias for
     * {valueRecordStringString}.
     * @returns {Record<string, string>}
     */
    values() {
        return this.valuesRecordStringString();
    }
    /**
     * Returns the data as a Record whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This can be used in most places where an Object is desired.  This is a convenience alias for
     * {valueRecordStringString}.
     * @returns {Record<string, string>}
     */
    valuesRecord() {
        return this.valuesRecordStringString();
    }
    /**
     * Returns the data as a Record whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This can be used in most places where an Object is desired.
     * @returns {Record<string, string>}
     */
    valuesRecordStringString() {
        return this.items.reduce((acc, item, index) => {
            if (item.value() !== undefined) {
                acc[TEXT_DECODER.decode(this.keys[index])] = item.valueString();
            }
            return acc;
        }, {});
    }
    /**
     * Returns the data as a Record whose keys are utf-8 strings, decoded from the underlying byte array, and whose
     * values are byte arrays.  This can be used in most places where an Object is desired.
     * @returns {Record<string, Uint8Array>}
     */
    valuesRecordStringUint8Array() {
        return this.items.reduce((acc, item, index) => {
            if (item.value() !== undefined) {
                acc[TEXT_DECODER.decode(this.keys[index])] = item.valueUint8Array();
            }
            return acc;
        }, {});
    }
    /**
     * Returns the data as a Map whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * This is a convenience alias for {valueMapStringString}.
     * @returns {Map<string, string>}
     */
    valuesMap() {
        return this.valuesMapStringString();
    }
    /**
     * Returns the data as a Map whose keys and values are utf-8 strings, decoded from the underlying byte arrays.
     * @returns {Map<string, string>}
     */
    valuesMapStringString() {
        return this.items.reduce((acc, item, index) => {
            if (item.value() !== undefined) {
                acc.set(TEXT_DECODER.decode(this.keys[index]), item.valueString());
            }
            return acc;
        }, new Map());
    }
    /**
     * Returns the data as a Map whose keys and values are byte arrays.
     * @returns {Map<Uint8Array, Uint8Array>}
     */
    valuesMapUint8ArrayUint8Array() {
        return this.items.reduce((acc, item, index) => {
            if (item.value() !== undefined) {
                acc.set(this.keys[index], item.valueUint8Array());
            }
            return acc;
        }, new Map());
    }
    toString() {
        const display = this.results()
            .map(result => result.toString())
            .toString();
        return `${super.toString()}: ${display}`;
    }
}
/**
 * Indicates that the requested data was successfully retrieved from the cache.  Provides
 * `value*` accessors to retrieve the data in the appropriate format.
 */
class Success extends (0, response_base_1.ResponseSuccess)(_Success) {
}
exports.Success = Success;
class _Error extends Response {
    constructor(_innerException) {
        super();
        this._innerException = _innerException;
    }
}
/**
 * Indicates that an error occurred during the cache get request.
 *
 * This response object includes the following fields that you can use to determine
 * how you would like to handle the error:
 *
 * - `errorCode()` - a unique Momento error code indicating the type of error that occurred.
 * - `message()` - a human-readable description of the error
 * - `innerException()` - the original error that caused the failure; can be re-thrown.
 */
class Error extends (0, response_base_1.ResponseError)(_Error) {
}
exports.Error = Error;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGUtYmF0Y2gtZ2V0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL21lc3NhZ2VzL3Jlc3BvbnNlcy9jYWNoZS1iYXRjaC1nZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsbURBQTZFO0FBRzdFLE1BQU0sWUFBWSxHQUFHLElBQUksV0FBVyxFQUFFLENBQUM7QUFFdkM7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtCRztBQUNILE1BQXNCLFFBQVMsU0FBUSw0QkFBWTtJQUMxQyxNQUFNO1FBQ1gsSUFBSSxJQUFJLFlBQVksT0FBTyxFQUFFO1lBQzNCLE9BQVEsSUFBZ0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUNuQztRQUNELE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFTSxPQUFPO1FBQ1osSUFBSSxJQUFJLFlBQVksT0FBTyxFQUFFO1lBQzNCLE9BQVEsSUFBZ0IsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUNwQztRQUNELE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7Q0FDRjtBQWRELDRCQWNDO0FBRUQsTUFBTSxRQUFTLFNBQVEsUUFBUTtJQUk3QixZQUFZLEtBQTBCLEVBQUUsSUFBa0I7UUFDeEQsS0FBSyxFQUFFLENBQUM7UUFDUixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztJQUNuQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksT0FBTztRQUNaLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztJQUNwQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNO1FBQ1gsT0FBTyxJQUFJLENBQUMsd0JBQXdCLEVBQUUsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxZQUFZO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLHdCQUF3QixFQUFFLENBQUM7SUFDekMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSx3QkFBd0I7UUFDN0IsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBeUIsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQ3BFLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLFNBQVMsRUFBRTtnQkFDOUIsR0FBRyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQ3hDLElBQ0QsQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUNqQjtZQUNELE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ1QsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSw0QkFBNEI7UUFDakMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBNkIsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQ3hFLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLFNBQVMsRUFBRTtnQkFDOUIsR0FBRyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQ3hDLElBQ0QsQ0FBQyxlQUFlLEVBQUUsQ0FBQzthQUNyQjtZQUNELE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ1QsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxTQUFTO1FBQ2QsT0FBTyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0kscUJBQXFCO1FBQzFCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQzVDLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLFNBQVMsRUFBRTtnQkFDOUIsR0FBRyxDQUFDLEdBQUcsQ0FDTCxZQUFZLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFDcEMsSUFBcUIsQ0FBQyxXQUFXLEVBQUUsQ0FDckMsQ0FBQzthQUNIO1lBQ0QsT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDLEVBQUUsSUFBSSxHQUFHLEVBQWtCLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksNkJBQTZCO1FBQ2xDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQzVDLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLFNBQVMsRUFBRTtnQkFDOUIsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFHLElBQXFCLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQzthQUNyRTtZQUNELE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQyxFQUFFLElBQUksR0FBRyxFQUEwQixDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVlLFFBQVE7UUFDdEIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRTthQUMzQixHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUM7YUFDaEMsUUFBUSxFQUFFLENBQUM7UUFDZCxPQUFPLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxLQUFLLE9BQU8sRUFBRSxDQUFDO0lBQzNDLENBQUM7Q0FDRjtBQUVEOzs7R0FHRztBQUNILE1BQWEsT0FBUSxTQUFRLElBQUEsK0JBQWUsRUFBQyxRQUFRLENBQUM7Q0FBRztBQUF6RCwwQkFBeUQ7QUFFekQsTUFBTSxNQUFPLFNBQVEsUUFBUTtJQUMzQixZQUFzQixlQUF5QjtRQUM3QyxLQUFLLEVBQUUsQ0FBQztRQURZLG9CQUFlLEdBQWYsZUFBZSxDQUFVO0lBRS9DLENBQUM7Q0FDRjtBQUVEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQWEsS0FBTSxTQUFRLElBQUEsNkJBQWEsRUFBQyxNQUFNLENBQUM7Q0FBRztBQUFuRCxzQkFBbUQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1Nka0Vycm9yfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHtSZXNwb25zZUJhc2UsIFJlc3BvbnNlRXJyb3IsIFJlc3BvbnNlU3VjY2Vzc30gZnJvbSAnLi9yZXNwb25zZS1iYXNlJztcbmltcG9ydCB7Q2FjaGVHZXR9IGZyb20gJy4uLy4uJztcblxuY29uc3QgVEVYVF9ERUNPREVSID0gbmV3IFRleHREZWNvZGVyKCk7XG5cbi8qKlxuICogUGFyZW50IHJlc3BvbnNlIHR5cGUgZm9yIGEgY2FjaGUgZ2V0IGJhdGNoIHJlcXVlc3QuICBUaGVcbiAqIHJlc3BvbnNlIG9iamVjdCBpcyByZXNvbHZlZCB0byBhIHR5cGUtc2FmZSBvYmplY3Qgb2Ygb25lIG9mXG4gKiB0aGUgZm9sbG93aW5nIHN1YnR5cGVzOlxuICpcbiAqIC0ge1N1Y2Nlc3N9XG4gKiAtIHtFcnJvcn1cbiAqXG4gKiBgaW5zdGFuY2VvZmAgdHlwZSBndWFyZHMgY2FuIGJlIHVzZWQgdG8gb3BlcmF0ZSBvbiB0aGUgYXBwcm9wcmlhdGUgc3VidHlwZS5cbiAqIEBleGFtcGxlXG4gKiBGb3IgZXhhbXBsZTpcbiAqIGBgYFxuICogaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgQmF0Y2hHZXQuRXJyb3IpIHtcbiAqICAgLy8gSGFuZGxlIGVycm9yIGFzIGFwcHJvcHJpYXRlLiAgVGhlIGNvbXBpbGVyIHdpbGwgc21hcnQtY2FzdCBgcmVzcG9uc2VgIHRvIHR5cGVcbiAqICAgLy8gYEJhdGNoR2V0LkVycm9yYCBpbiB0aGlzIGJsb2NrLCBzbyB5b3Ugd2lsbCBoYXZlIGFjY2VzcyB0byB0aGUgcHJvcGVydGllc1xuICogICAvLyBvZiB0aGUgRXJyb3IgY2xhc3M7IGUuZy4gYHJlc3BvbnNlLmVycm9yQ29kZSgpYC5cbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVzcG9uc2UgZXh0ZW5kcyBSZXNwb25zZUJhc2Uge1xuICBwdWJsaWMgdmFsdWVzKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU3VjY2Vzcykge1xuICAgICAgcmV0dXJuICh0aGlzIGFzIFN1Y2Nlc3MpLnZhbHVlcygpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHVibGljIHJlc3VsdHMoKTogQ2FjaGVHZXQuUmVzcG9uc2VbXSB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTdWNjZXNzKSB7XG4gICAgICByZXR1cm4gKHRoaXMgYXMgU3VjY2VzcykucmVzdWx0cygpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmNsYXNzIF9TdWNjZXNzIGV4dGVuZHMgUmVzcG9uc2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IGl0ZW1zOiBDYWNoZUdldC5SZXNwb25zZVtdO1xuICBwcml2YXRlIHJlYWRvbmx5IGtleXM6IFVpbnQ4QXJyYXlbXTtcblxuICBjb25zdHJ1Y3RvcihpdGVtczogQ2FjaGVHZXQuUmVzcG9uc2VbXSwga2V5czogVWludDhBcnJheVtdKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgdGhpcy5rZXlzID0ga2V5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGF0dXMgZm9yIGVhY2ggcmVxdWVzdCBpbiB0aGUgYmF0Y2ggYXMgYSBsaXN0IG9mIENhY2hlR2V0LlJlc3BvbnNlIG9iamVjdHMuXG4gICAqIEByZXR1cm5zIHtDYWNoZUdldC5SZXNwb25zZVtdfVxuICAgKi9cbiAgcHVibGljIHJlc3VsdHMoKTogQ2FjaGVHZXQuUmVzcG9uc2VbXSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0YSBhcyBhIFJlY29yZCB3aG9zZSBrZXlzIGFuZCB2YWx1ZXMgYXJlIHV0Zi04IHN0cmluZ3MsIGRlY29kZWQgZnJvbSB0aGUgdW5kZXJseWluZyBieXRlIGFycmF5cy5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCBpbiBtb3N0IHBsYWNlcyB3aGVyZSBhbiBPYmplY3QgaXMgZGVzaXJlZC4gIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBhbGlhcyBmb3JcbiAgICoge3ZhbHVlUmVjb3JkU3RyaW5nU3RyaW5nfS5cbiAgICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gICAqL1xuICBwdWJsaWMgdmFsdWVzKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1JlY29yZFN0cmluZ1N0cmluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGEgYXMgYSBSZWNvcmQgd2hvc2Uga2V5cyBhbmQgdmFsdWVzIGFyZSB1dGYtOCBzdHJpbmdzLCBkZWNvZGVkIGZyb20gdGhlIHVuZGVybHlpbmcgYnl0ZSBhcnJheXMuXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgaW4gbW9zdCBwbGFjZXMgd2hlcmUgYW4gT2JqZWN0IGlzIGRlc2lyZWQuICBUaGlzIGlzIGEgY29udmVuaWVuY2UgYWxpYXMgZm9yXG4gICAqIHt2YWx1ZVJlY29yZFN0cmluZ1N0cmluZ30uXG4gICAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICAgKi9cbiAgcHVibGljIHZhbHVlc1JlY29yZCgpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNSZWNvcmRTdHJpbmdTdHJpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRhIGFzIGEgUmVjb3JkIHdob3NlIGtleXMgYW5kIHZhbHVlcyBhcmUgdXRmLTggc3RyaW5ncywgZGVjb2RlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ5dGUgYXJyYXlzLlxuICAgKiBUaGlzIGNhbiBiZSB1c2VkIGluIG1vc3QgcGxhY2VzIHdoZXJlIGFuIE9iamVjdCBpcyBkZXNpcmVkLlxuICAgKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAgICovXG4gIHB1YmxpYyB2YWx1ZXNSZWNvcmRTdHJpbmdTdHJpbmcoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMucmVkdWNlPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+KChhY2MsIGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaXRlbS52YWx1ZSgpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWNjW1RFWFRfREVDT0RFUi5kZWNvZGUodGhpcy5rZXlzW2luZGV4XSldID0gKFxuICAgICAgICAgIGl0ZW0gYXMgQ2FjaGVHZXQuSGl0XG4gICAgICAgICkudmFsdWVTdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGEgYXMgYSBSZWNvcmQgd2hvc2Uga2V5cyBhcmUgdXRmLTggc3RyaW5ncywgZGVjb2RlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ5dGUgYXJyYXksIGFuZCB3aG9zZVxuICAgKiB2YWx1ZXMgYXJlIGJ5dGUgYXJyYXlzLiAgVGhpcyBjYW4gYmUgdXNlZCBpbiBtb3N0IHBsYWNlcyB3aGVyZSBhbiBPYmplY3QgaXMgZGVzaXJlZC5cbiAgICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIFVpbnQ4QXJyYXk+fVxuICAgKi9cbiAgcHVibGljIHZhbHVlc1JlY29yZFN0cmluZ1VpbnQ4QXJyYXkoKTogUmVjb3JkPHN0cmluZywgVWludDhBcnJheT4ge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLnJlZHVjZTxSZWNvcmQ8c3RyaW5nLCBVaW50OEFycmF5Pj4oKGFjYywgaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpdGVtLnZhbHVlKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhY2NbVEVYVF9ERUNPREVSLmRlY29kZSh0aGlzLmtleXNbaW5kZXhdKV0gPSAoXG4gICAgICAgICAgaXRlbSBhcyBDYWNoZUdldC5IaXRcbiAgICAgICAgKS52YWx1ZVVpbnQ4QXJyYXkoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGEgYXMgYSBNYXAgd2hvc2Uga2V5cyBhbmQgdmFsdWVzIGFyZSB1dGYtOCBzdHJpbmdzLCBkZWNvZGVkIGZyb20gdGhlIHVuZGVybHlpbmcgYnl0ZSBhcnJheXMuXG4gICAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSBhbGlhcyBmb3Ige3ZhbHVlTWFwU3RyaW5nU3RyaW5nfS5cbiAgICogQHJldHVybnMge01hcDxzdHJpbmcsIHN0cmluZz59XG4gICAqL1xuICBwdWJsaWMgdmFsdWVzTWFwKCk6IE1hcDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc01hcFN0cmluZ1N0cmluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGEgYXMgYSBNYXAgd2hvc2Uga2V5cyBhbmQgdmFsdWVzIGFyZSB1dGYtOCBzdHJpbmdzLCBkZWNvZGVkIGZyb20gdGhlIHVuZGVybHlpbmcgYnl0ZSBhcnJheXMuXG4gICAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBzdHJpbmc+fVxuICAgKi9cbiAgcHVibGljIHZhbHVlc01hcFN0cmluZ1N0cmluZygpOiBNYXA8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5yZWR1Y2UoKGFjYywgaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpdGVtLnZhbHVlKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhY2Muc2V0KFxuICAgICAgICAgIFRFWFRfREVDT0RFUi5kZWNvZGUodGhpcy5rZXlzW2luZGV4XSksXG4gICAgICAgICAgKGl0ZW0gYXMgQ2FjaGVHZXQuSGl0KS52YWx1ZVN0cmluZygpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGEgYXMgYSBNYXAgd2hvc2Uga2V5cyBhbmQgdmFsdWVzIGFyZSBieXRlIGFycmF5cy5cbiAgICogQHJldHVybnMge01hcDxVaW50OEFycmF5LCBVaW50OEFycmF5Pn1cbiAgICovXG4gIHB1YmxpYyB2YWx1ZXNNYXBVaW50OEFycmF5VWludDhBcnJheSgpOiBNYXA8VWludDhBcnJheSwgVWludDhBcnJheT4ge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLnJlZHVjZSgoYWNjLCBpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGl0ZW0udmFsdWUoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFjYy5zZXQodGhpcy5rZXlzW2luZGV4XSwgKGl0ZW0gYXMgQ2FjaGVHZXQuSGl0KS52YWx1ZVVpbnQ4QXJyYXkoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIG5ldyBNYXA8VWludDhBcnJheSwgVWludDhBcnJheT4oKSk7XG4gIH1cblxuICBwdWJsaWMgb3ZlcnJpZGUgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5yZXN1bHRzKClcbiAgICAgIC5tYXAocmVzdWx0ID0+IHJlc3VsdC50b1N0cmluZygpKVxuICAgICAgLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIGAke3N1cGVyLnRvU3RyaW5nKCl9OiAke2Rpc3BsYXl9YDtcbiAgfVxufVxuXG4vKipcbiAqIEluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0ZWQgZGF0YSB3YXMgc3VjY2Vzc2Z1bGx5IHJldHJpZXZlZCBmcm9tIHRoZSBjYWNoZS4gIFByb3ZpZGVzXG4gKiBgdmFsdWUqYCBhY2Nlc3NvcnMgdG8gcmV0cmlldmUgdGhlIGRhdGEgaW4gdGhlIGFwcHJvcHJpYXRlIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGNsYXNzIFN1Y2Nlc3MgZXh0ZW5kcyBSZXNwb25zZVN1Y2Nlc3MoX1N1Y2Nlc3MpIHt9XG5cbmNsYXNzIF9FcnJvciBleHRlbmRzIFJlc3BvbnNlIHtcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIF9pbm5lckV4Y2VwdGlvbjogU2RrRXJyb3IpIHtcbiAgICBzdXBlcigpO1xuICB9XG59XG5cbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBjYWNoZSBnZXQgcmVxdWVzdC5cbiAqXG4gKiBUaGlzIHJlc3BvbnNlIG9iamVjdCBpbmNsdWRlcyB0aGUgZm9sbG93aW5nIGZpZWxkcyB0aGF0IHlvdSBjYW4gdXNlIHRvIGRldGVybWluZVxuICogaG93IHlvdSB3b3VsZCBsaWtlIHRvIGhhbmRsZSB0aGUgZXJyb3I6XG4gKlxuICogLSBgZXJyb3JDb2RlKClgIC0gYSB1bmlxdWUgTW9tZW50byBlcnJvciBjb2RlIGluZGljYXRpbmcgdGhlIHR5cGUgb2YgZXJyb3IgdGhhdCBvY2N1cnJlZC5cbiAqIC0gYG1lc3NhZ2UoKWAgLSBhIGh1bWFuLXJlYWRhYmxlIGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvclxuICogLSBgaW5uZXJFeGNlcHRpb24oKWAgLSB0aGUgb3JpZ2luYWwgZXJyb3IgdGhhdCBjYXVzZWQgdGhlIGZhaWx1cmU7IGNhbiBiZSByZS10aHJvd24uXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvciBleHRlbmRzIFJlc3BvbnNlRXJyb3IoX0Vycm9yKSB7fVxuIl19