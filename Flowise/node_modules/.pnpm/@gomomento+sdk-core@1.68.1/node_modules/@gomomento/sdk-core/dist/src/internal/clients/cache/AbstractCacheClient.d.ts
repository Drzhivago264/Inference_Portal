import { CreateCache, DeleteCache, ListCaches, CacheFlush, CacheGet, CacheSet, CacheDelete, CacheIncrement, IncrementOptions, CacheSetIfNotExists, SetIfNotExistsOptions, CacheSetFetch, CacheSetAddElement, CacheSetAddElements, CacheSetRemoveElement, CacheSetRemoveElements, CacheListFetch, CacheListLength, CacheListPushFront, CacheListPushBack, CacheListConcatenateBack, CacheListConcatenateFront, CacheListPopBack, CacheListPopFront, CacheListRemoveValue, CacheListRetain, CacheDictionarySetField, CacheDictionarySetFields, CacheDictionaryGetField, CacheDictionaryGetFields, CacheDictionaryIncrement, CacheDictionaryFetch, CacheDictionaryRemoveField, CacheDictionaryRemoveFields, CacheDictionaryLength, CacheSortedSetFetch, CacheSortedSetPutElement, CacheSortedSetPutElements, CacheSortedSetGetRank, CacheSortedSetGetScore, CacheSortedSetGetScores, CacheSortedSetIncrementScore, CacheSortedSetRemoveElement, CacheSortedSetRemoveElements, CacheSortedSetLength, CacheSortedSetLengthByScore, CacheItemGetTtl, CacheItemGetType, CacheKeyExists, CacheKeysExist, CacheUpdateTtl, CacheIncreaseTtl, CacheDecreaseTtl, GetBatch, SetBatch } from '../../../index';
import { ListFetchCallOptions, ListRetainCallOptions } from '../../../utils';
import { ICacheClient, SetOptions, SetAddElementOptions, SetAddElementsOptions, ListPushFrontOptions, ListPushBackOptions, ListConcatenateBackOptions, ListConcatenateFrontOptions, DictionarySetFieldOptions, DictionaryIncrementOptions, SortedSetFetchByRankOptions, SortedSetPutElementOptions, SortedSetPutElementsOptions, SortedSetFetchByScoreOptions, SortedSetIncrementOptions, SortedSetLengthByScoreOptions, SetBatchOptions } from '../../../clients/ICacheClient';
import { IControlClient } from './IControlClient';
import { IDataClient } from './IDataClient';
import { IPingClient } from './IPingClient';
import { IMomentoCache } from '../../../clients/IMomentoCache';
export declare abstract class AbstractCacheClient implements ICacheClient {
    protected readonly controlClient: IControlClient;
    protected readonly dataClients: IDataClient[];
    protected readonly pingClient?: IPingClient;
    protected nextDataClientIndex: number;
    protected constructor(controlClient: IControlClient, dataClients: IDataClient[], pingClient?: IPingClient);
    cache(cacheName: string): IMomentoCache;
    /**
     * Ping the service to verify it is up and running
     */
    ping(): Promise<void>;
    /**
     * Creates a cache if it does not exist.
     *
     * @param {string} cacheName - The cache to be created.
     * @returns {Promise<CreateCache.Response>} -
     * {@link CreateCache.Success} on success.
     * {@link CreateCache.AlreadyExists} if the cache already exists.
     * {@link CreateCache.Error} on failure.
     */
    createCache(cacheName: string): Promise<CreateCache.Response>;
    /**
     * Deletes a cache and all items stored in it.
     *
     * @param {string} cacheName - The cache to delete.
     * @returns {Promise<DeleteCache.Response>} -
     * {@link DeleteCache.Success} on success.
     * {@link DeleteCache.Error} on failure.
     */
    deleteCache(cacheName: string): Promise<DeleteCache.Response>;
    /**
     * Lists all caches.
     *
     * @returns {Promise<ListCaches.Response>} -
     * {@link ListCaches.Success} containing the list on success.
     * {@link ListCaches.Error} on failure.
     */
    listCaches(): Promise<ListCaches.Response>;
    /**
     * Gets the value stored for the given key.
     *
     * @param {string} cacheName - The cache to perform the lookup in.
     * @param {string | Uint8Array} key - The key to look up.
     * @returns {Promise<CacheGet.Response>} -
     * {@link CacheGet.Hit} containing the value if one is found.
     * {@link CacheGet.Miss} if the key does not exist.
     * {@link CacheGet.Error} on failure.
     */
    get(cacheName: string, key: string | Uint8Array): Promise<CacheGet.Response>;
    /**
     * Associates the given key with the given value. If a value for the key is
     * already present it is replaced with the new value.
     *
     * @param {string} cacheName - The cache to store the value in.
     * @param {string | Uint8Array} key - The key to set.
     * @param {string | Uint8Array} value - The value to be stored.
     * @param {SetOptions} [options]
     * @param {number} [options.ttl] - The time to live for the item in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @returns {Promise<CacheSet.Response>} -
     * {@link CacheSet.Success} on success.
     * {@link CacheSet.Error} on failure.
     */
    set(cacheName: string, key: string | Uint8Array, value: string | Uint8Array, options?: SetOptions): Promise<CacheSet.Response>;
    /**
     * Removes the given key from the cache. The key can represent a single value
     * or a collection.
     *
     * @param {string} cacheName - The cache to delete from.
     * @param {string | Uint8Array} key - The key to delete.
     * @returns {Promise<CacheDelete.Response>} -
     * {@link CacheDelete.Success} on success.
     * {@link CacheDelete.Error} on failure.
     */
    delete(cacheName: string, key: string | Uint8Array): Promise<CacheDelete.Response>;
    /**
     * Gets the value stored for the given keys.
     *
     * @param {string} cacheName - The cache to perform the lookup in.
     * @param {string[] | Uint8Array[]} keys - The list of keys to look up.
     * @returns {Promise<GetBatch.Response>} -
     * {@link GetBatch.Success} containing the values if they were found.
     * {@link GetBatch.Error} on failure.
     */
    getBatch(cacheName: string, keys: Array<string | Uint8Array>): Promise<GetBatch.Response>;
    /**
     * Associates the given keys with the given values. If a value for the key is
     * already present it is replaced with the new value.
     *
     * @param {string} cacheName - The cache to store the values in.
     * @param {Record<string, string | Uint8Array> | Map<string | Uint8Array, string | Uint8Array>} items - The key-value pairs to be stored.
     * @param {SetOptions} [options]
     * @param {number} [options.ttl] - The time to live for the items in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @returns {Promise<CacheSet.Response>} -
     * {@link SetBatch.Success} on success.
     * {@link SetBatch.Error} on failure.
     */
    setBatch(cacheName: string, items: Record<string, string | Uint8Array> | Map<string | Uint8Array, string | Uint8Array>, options?: SetBatchOptions): Promise<SetBatch.Response>;
    /**
     * Adds multiple elements to the back of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to add to.
     * @param {string[] | Uint8Array[]} values - The elements to add to the list.
     * @param {ListConcatenateBackOptions} [options]
     * @param {number} [options.truncateFrontToSize] - If the list exceeds this
     * length, remove excess from the front of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListConcatenateBack.Response>} -
     * {@link CacheListConcatenateBack.Success} on success.
     * {@link CacheListConcatenateBack.Error} on failure.
     */
    listConcatenateBack(cacheName: string, listName: string, values: string[] | Uint8Array[], options?: ListConcatenateBackOptions): Promise<CacheListConcatenateBack.Response>;
    /**
     * Adds multiple elements to the front of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to add to.
     * @param {string[] | Uint8Array[]} values - The elements to add to the list.
     * @param {ListConcatenateFrontOptions} [options]
     * @param {number} [options.truncateBackToSize] - If the list exceeds this
     * length, remove excess from the back of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListConcatenateFront.Response>} -
     * {@link CacheListConcatenateFront.Success} on success.
     * {@link CacheListConcatenateFront.Error} on failure.
     */
    listConcatenateFront(cacheName: string, listName: string, values: string[] | Uint8Array[], options?: ListConcatenateFrontOptions): Promise<CacheListConcatenateFront.Response>;
    /**
     * Fetches all elements of the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to fetch.
     * @param {ListFetchCallOptions} [options]
     * @param {number} [options.startIndex] - Start inclusive index for fetch operation.
     * @param {number} [options.endIndex] - End exclusive index for fetch operation.
     * @returns {Promise<CacheListFetch.Response>} -
     * {@link CacheListFetch.Hit} containing the list elements if the list exists.
     * {@link CacheListFetch.Miss} if the list does not exist.
     * {@link CacheListFetch.Error} on failure.
     */
    listFetch(cacheName: string, listName: string, options?: ListFetchCallOptions): Promise<CacheListFetch.Response>;
    /**
     * Gets the number of elements in the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to get the length of.
     * @returns {Promise<CacheListLength.Response>} -
     * {@link CacheListLength.Hit} containing the length if the list exists.
     * {@link CacheListLength.Miss} if the list does not exist.
     * {@link CacheListLength.Error} on failure.
     */
    listLength(cacheName: string, listName: string): Promise<CacheListLength.Response>;
    /**
     * Gets and removes the last value from the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to pop.
     * @returns {Promise<CacheListPopBack.Response>} -
     * {@link CacheListPopBack.Hit} containing the element if the list exists.
     * {@link CacheListPopBack.Miss} if the list does not exist.
     * {@link CacheListPopBack.Error} on failure.
     */
    listPopBack(cacheName: string, listName: string): Promise<CacheListPopBack.Response>;
    /**
     * Gets and removes the first value from the given list.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to pop.
     * @returns {Promise<CacheListPopFront.Response>} -
     * {@link CacheListPopFront.Hit} containing the element if the list exists.
     * {@link CacheListPopFront.Miss} if the list does not exist.
     * {@link CacheListPopFront.Error} on failure.
     */
    listPopFront(cacheName: string, listName: string): Promise<CacheListPopFront.Response>;
    /**
     * Adds an element to the back of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to push to.
     * @param {string | Uint8Array} value - The value to push.
     * @param {ListPushBackOptions} [options]
     * @param {number} [options.truncateFrontToSize] - If the list exceeds this
     * length, remove excess from the front of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListPushBack.Response>} -
     * {@link CacheListPushBack.Success} containing the list's new length on
     * success.
     * {@link CacheListPushBack.Error} on failure.
     */
    listPushBack(cacheName: string, listName: string, value: string | Uint8Array, options?: ListPushBackOptions): Promise<CacheListPushBack.Response>;
    /**
     * Adds an element to the front of the given list. Creates the list if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the list in.
     * @param {string} listName - The list to push to.
     * @param {string | Uint8Array} value - The value to push.
     * @param {ListPushFrontOptions} [options]
     * @param {number} [options.truncateBackToSize] - If the list exceeds this
     * length, remove excess from the end of the list. Must be positive.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListPushFront.Response>} -
     * {@link CacheListPushFront.Success} containing the list's new length on
     * success.
     * {@link CacheListPushFront.Error} on failure.
     */
    listPushFront(cacheName: string, listName: string, value: string | Uint8Array, options?: ListPushFrontOptions): Promise<CacheListPushFront.Response>;
    /**
     * Removes all elements from the given list equal to the given value.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to remove from.
     * @param {string | Uint8Array} value - The value to remove.
     * @returns {Promise<CacheListRemoveValue.Response>} -
     * {@link CacheListRemoveValue.Success} on success. Removing an element that
     * does not occur in the list or removing from a non-existent list counts as a
     * success.
     * {@link CacheListRemoveValue.Error} on failure.
     */
    listRemoveValue(cacheName: string, listName: string, value: string | Uint8Array): Promise<CacheListRemoveValue.Response>;
    /**
     * Retains slice of elements of a given list, deletes the rest of the list
     * that isn't being retained. Returns a Success or Error.
     *
     * @param {string} cacheName - The cache containing the list.
     * @param {string} listName - The list to retain a slice of.
     * @param {ListRetainCallOptions} [options]
     * @param {number} [options.startIndex] - Start inclusive index for fetch
     * operation. Defaults to start of array if not given, 0.
     * @param {number} [options.endIndex] - End exclusive index for fetch
     * operation. Defaults to end of array if not given.
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the list's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheListRetain.Response>} -
     * {@link CacheListRetain.Success} on success.
     * {@link CacheListRetain.Error} on failure.
     */
    listRetain(cacheName: string, listName: string, options?: ListRetainCallOptions): Promise<CacheListRetain.Response>;
    /**
     * Fetches all elements of the given set
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to fetch.
     * @returns {Promise<CacheSetFetch.Response>} -
     * {@link CacheSetFetch.Hit} containing the set elements if the set exists.
     * {@link CacheSetFetch.Miss} if the set does not exist.
     * {@link CacheSetFetch.Error} on failure.
     */
    setFetch(cacheName: string, setName: string): Promise<CacheSetFetch.Response>;
    /**
     * Adds an element to the given set. Creates the set if it does not already
     * exist.
     *
     * @remarks
     * After this operation the set will contain the union of the element passed
     * in and the original elements of the set.
     *
     * @param {string} cacheName - The cache to store the set in.
     * @param {string} setName - The set to add to.
     * @param {string | Uint8Array} element - The element to add.
     * @param {SetAddElementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the set's TTL using the client's default if this is not supplied.
     * @returns {Promise<CacheSetAddElement.Response>} -
     * {@link CacheSetAddElement.Success} on success.
     * {@link CacheSetAddElement.Error} on failure.
     */
    setAddElement(cacheName: string, setName: string, element: string | Uint8Array, options?: SetAddElementOptions): Promise<CacheSetAddElement.Response>;
    /**
     * Adds multiple elements to the given set. Creates the set if it does not
     * already exist.
     *
     * @remarks
     * After this operation, the set will contain the union of the elements passed
     * in and the original elements of the set.
     *
     * @param {string} cacheName - The cache to store the set in.
     * @param {string} setName - The set to add to.
     * @param {string[] | Uint8Array[]} elements - The elements to add.
     * @param {SetAddElementsOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the set's TTL using the client's default if this is not supplied.
     * @returns {Promise<CacheSetAddElements.Response>} -
     * {@link CacheSetAddElements.Success} on success.
     * {@link CacheSetAddElements.Error} on failure.
     */
    setAddElements(cacheName: string, setName: string, elements: string[] | Uint8Array[], options?: SetAddElementsOptions): Promise<CacheSetAddElements.Response>;
    /**
     * Removes an element from the given set.
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to remove from.
     * @param {string | Uint8Array} element - The element to remove.
     * @returns {Promise<CacheSetRemoveElement.Response>} -
     * {@link CacheSetRemoveElement.Success} on success. Removing an element that
     * does not occur in the set or removing from a non-existent set counts as a
     * success.
     * {@link CacheSetRemoveElement.Error} on failure.
     */
    setRemoveElement(cacheName: string, setName: string, element: string | Uint8Array): Promise<CacheSetRemoveElement.Response>;
    /**
     * Removes multiple elements from the given set.
     *
     * @param {string} cacheName - The cache containing the set.
     * @param {string} setName - The set to remove from.
     * @param {string[] | Uint8Array[]} elements - The elements to remove.
     * @returns {Promise<CacheSetRemoveElements.Response>} -
     * {@link CacheSetRemoveElements.Success} on success. Removing elements that
     * do not occur in the set or removing from a non-existent set counts as a
     * success.
     * {@link CacheSetRemoveElements.Error} on failure.
     */
    setRemoveElements(cacheName: string, setName: string, elements: string[] | Uint8Array[]): Promise<CacheSetRemoveElements.Response>;
    /**
     * Associates the given key with the given value. If a value for the key is
     * already present it is not replaced with the new value.
     *
     * @param {string} cacheName - The cache to store the value in.
     * @param {string | Uint8Array} key - The key to set.
     * @param {string | Uint8Array} field - The value to be stored.
     * @param {SetIfNotExistsOptions} [options]
     * @param {number} [options.ttl] - The time to live for the item in the cache.
     * Uses the client's default TTL if this is not supplied.
     * @returns {Promise<CacheSetIfNotExists.Response>} -
     * {@link CacheSetIfNotExists.Stored} on storing the new value.
     * {@link CacheSetIfNotExists.NotStored} on not storing the new value.
     * {@link CacheSetIfNotExists.Error} on failure.
     */
    setIfNotExists(cacheName: string, key: string | Uint8Array, field: string | Uint8Array, options?: SetIfNotExistsOptions): Promise<CacheSetIfNotExists.Response>;
    /**
     * Flushes / clears all the items of the given cache
     *
     * @param {string} cacheName - The cache to be flushed.
     * @returns {Promise<CacheFlush.Response>} -
     * {@link CacheFlush.Success} on success.
     * {@link CacheFlush.Error} on failure.
     */
    flushCache(cacheName: string): Promise<CacheFlush.Response>;
    /**
     * Fetches all elements of the given dictionary.
     *
     * @param {string} cacheName - The cache to perform the lookup in.
     * @param {string} dictionaryName - The dictionary to fetch.
     * @returns {Promise<CacheDictionaryFetch.Response>} -
     * {@link CacheDictionaryFetch.Hit} containing the dictionary elements if the
     * dictionary exists.
     * {@link CacheDictionaryFetch.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryFetch.Error} on failure.
     */
    dictionaryFetch(cacheName: string, dictionaryName: string): Promise<CacheDictionaryFetch.Response>;
    /**
     * Adds an integer quantity to a field value.
     *
     * @remarks
     * Incrementing the value of a missing field sets the value to amount.
     *
     * @param {string} cacheName - The cache containing the field.
     * @param {string | Uint8Array} field - The field to increment.
     * @param {number} amount - The quantity to add to the value. May be positive,
     * negative, or zero. Defaults to 1.
     * @param {IncrementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * @returns {Promise<CacheIncrement>} -
     * {@link CacheIncrement.Success} containing the incremented value
     * on success.
     * {@link CacheIncrement.Error} on failure. Incrementing a value
     * that was not set using this method or is not the string representation of
     * an integer results in a failure with a FailedPreconditionException error.
     */
    increment(cacheName: string, field: string | Uint8Array, amount?: number, options?: IncrementOptions): Promise<CacheIncrement.Response>;
    /**
     * Adds an element to the given dictionary. Creates the dictionary if it does
     * not already exist.
     *
     * @param {string} cacheName - The cache to store the dictionary in.
     * @param {string} dictionaryName - The dictionary to add to.
     * @param {string | Uint8Array} field - The field to set.
     * @param {string | Uint8Array} value - The value to store.
     * @param {DictionarySetFieldOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the dictionary's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheDictionarySetField.Response>} -
     * {@link CacheDictionarySetField.Success} on success.
     * {@link CacheDictionarySetField.Error} on failure.
     */
    dictionarySetField(cacheName: string, dictionaryName: string, field: string | Uint8Array, value: string | Uint8Array, options?: DictionarySetFieldOptions): Promise<CacheDictionarySetField.Response>;
    /**
     * Adds multiple elements to the given dictionary. Creates the dictionary if
     * it does not already exist.
     *
     * @param {string} cacheName - The cache to store the dictionary in.
     * @param {string} dictionaryName - The dictionary to add to.
     * @param {Map<string | Uint8Array, string | Uint8Array>} elements - The
     * elements to set.
     * @param {DictionarySetFieldsOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the dictionary's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheDictionarySetFields.Response>} -
     * {@link CacheDictionarySetFields.Success} on success.
     * {@link CacheDictionarySetFields.Error} on failure.
     */
    dictionarySetFields(cacheName: string, dictionaryName: string, elements: Map<string | Uint8Array, string | Uint8Array> | Record<string, string | Uint8Array> | Array<[string, string | Uint8Array]>, options?: DictionarySetFieldOptions): Promise<CacheDictionarySetFields.Response>;
    /**
     * Gets the value stored for the given dictionary and field.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to look up.
     * @param {string | Uint8Array} field - The field to look up.
     * @returns {Promise<CacheDictionaryGetField.Response>} -
     * {@link CacheDictionaryGetField.Hit} containing the dictionary element if
     * one is found.
     * {@link CacheDictionaryGetField.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryGetField.Error} on failure.
     */
    dictionaryGetField(cacheName: string, dictionaryName: string, field: string | Uint8Array): Promise<CacheDictionaryGetField.Response>;
    /**
     * Gets multiple values from the given dictionary.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to look up.
     * @param {string[] | Uint8Array[]} fields - The fields to look up.
     * @returns {Promise<CacheDictionaryGetFields.Response>} -
     * {@link CacheDictionaryGetFields.Hit} containing the dictionary elements if
     * the dictionary exists.
     * {@link CacheDictionaryGetFields.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryGetFields.Error} on failure.
     */
    dictionaryGetFields(cacheName: string, dictionaryName: string, fields: string[] | Uint8Array[]): Promise<CacheDictionaryGetFields.Response>;
    /**
     * Removes an element from the given dictionary.
     *
     * @remarks
     * Performs a no-op if the dictionary or field does not exist.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to remove from.
     * @param {string | Uint8Array} field - The field to remove.
     * @returns {Promise<CacheDictionaryRemoveField.Response>} -
     * {@link CacheDictionaryRemoveField.Success} on success.
     * {@link CacheDictionaryRemoveField.Error} on failure.
     */
    dictionaryRemoveField(cacheName: string, dictionaryName: string, field: string | Uint8Array): Promise<CacheDictionaryRemoveField.Response>;
    /**
     * Removes multiple fields from the given dictionary.
     *
     * @remarks
     * Performs a no-op if the dictionary or fields do not exist.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to remove from.
     * @param {string[] | Uint8Array[]} fields - The fields to remove.
     * @returns {Promise<CacheDictionaryRemoveFields.Response>} -
     * {@link CacheDictionaryRemoveFields.Success} on success.
     * {@link CacheDictionaryRemoveFields.Error} on failure.
     */
    dictionaryRemoveFields(cacheName: string, dictionaryName: string, fields: string[] | Uint8Array[]): Promise<CacheDictionaryRemoveFields.Response>;
    /**
     * Adds an integer quantity to a dictionary value.
     *
     * @remarks
     * Incrementing the value of a missing field sets the value to amount.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to set.
     * @param {string | Uint8Array} field - The field to increment.
     * @param {number} amount - The quantity to add to the value. May be positive,
     * negative, or zero. Defaults to 1.
     * @param {DictionaryIncrementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the dictionary's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheDictionaryIncrement.Response>} -
     * {@link CacheDictionaryIncrement.Success} containing the incremented value
     * on success.
     * {@link CacheDictionaryIncrement.Error} on failure. Incrementing a value
     * that was not set using this method or is not the string representation of
     * an integer results in a failure with a FailedPreconditionException error.
     */
    dictionaryIncrement(cacheName: string, dictionaryName: string, field: string | Uint8Array, amount?: number, options?: DictionaryIncrementOptions): Promise<CacheDictionaryIncrement.Response>;
    /**
     * Gets the number of elements in the given dictionary.
     *
     * @param {string} cacheName - The cache containing the dictionary.
     * @param {string} dictionaryName - The dictionary to get the length of.
     * @returns {Promise<CacheDictionaryLength.Response>} -
     * {@link CacheDictionaryLength.Hit} containing the length if the dictionary exists.
     * {@link CacheDictionaryLength.Miss} if the dictionary does not exist.
     * {@link CacheDictionaryLength.Error} on failure.
     */
    dictionaryLength(cacheName: string, dictionaryName: string): Promise<CacheDictionaryLength.Response>;
    /**
     * Adds an element to the given sorted set. If the element already exists, its
     * score is updated. Creates the sorted set if it does not exist.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to add to.
     * @param {string | Uint8Array} value - The value to add.
     * @param {number} score - The score to assign to the value.
     * @param {SortedSetPutElementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the sorted set's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheSortedSetPutElement.Response>} -
     * {@link CacheSortedSetPutElement.Success} on success.
     * {@link CacheSortedSetPutElement.Error} on failure.
     * @returns
     */
    sortedSetPutElement(cacheName: string, sortedSetName: string, value: string | Uint8Array, score: number, options?: SortedSetPutElementOptions): Promise<CacheSortedSetPutElement.Response>;
    /**
     * Adds elements to the given sorted set. For any values that already exist, it
     * the score is updated. Creates the sorted set if it does not exist.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to add to.
     * @param {Map<string | Uint8Array, number>| Record<string, number>} elements - The value->score pairs to add to the sorted set.
     * @param {SortedSetPutElementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the sorted set's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheSortedSetPutElements.Response>} -
     * {@link CacheSortedSetPutElements.Success} on success.
     * {@link CacheSortedSetPutElements.Error} on failure.
     * @returns
     */
    sortedSetPutElements(cacheName: string, sortedSetName: string, elements: Map<string | Uint8Array, number> | Record<string, number> | Array<[string, number]>, options?: SortedSetPutElementsOptions): Promise<CacheSortedSetPutElements.Response>;
    /**
     * Fetch the elements in the given sorted set by index (rank).
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {SortedSetFetchByRankOptions} options
     * @param {number} [options.startRank] - The rank of the first element to
     * fetch. Defaults to 0. This rank is inclusive, ie the element at this rank
     * will be fetched.
     * @param {number} [options.endRank] - The rank of the last element to fetch.
     * This rank is exclusive, ie the element at this rank will not be fetched.
     * Defaults to null, which fetches up until and including the last element.
     * @param {SortedSetOrder} [options.order] - The order to fetch the elements in.
     * Defaults to ascending.
     * @returns {Promise<CacheSortedSetFetch.Response>}
     * {@link CacheSortedSetFetch.Hit} containing the requested elements when found.
     * {@link CacheSortedSetFetch.Miss} when the sorted set does not exist.
     * {@link CacheSortedSetFetch.Error} on failure.
     */
    sortedSetFetchByRank(cacheName: string, sortedSetName: string, options?: SortedSetFetchByRankOptions): Promise<CacheSortedSetFetch.Response>;
    /**
     * Fetch the elements in the given sorted set by score.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {SortedSetFetchByScoreOptions} options
     * @param {number} [options.minScore] - The minimum score (inclusive) of the
     * elements to fetch. Defaults to negative infinity.
     * @param {number} [options.maxScore] - The maximum score (inclusive) of the
     * elements to fetch. Defaults to positive infinity.
     * @param {SortedSetOrder} [options.order] - The order to fetch the elements in.
     * Defaults to ascending.
     * @param {number} [options.offset] - The number of elements to skip before
     * returning the first element. Defaults to 0. Note: this is not the rank of
     * the first element to return, but the number of elements of the result set
     * to skip before returning the first element.
     * @param {number} [options.count] - The maximum number of elements to return.
     * Defaults to undefined, which returns all elements.
     * @returns {Promise<CacheSortedSetFetch.Response>} -
     * {@link CacheSortedSetFetch.Hit} containing the requested elements when found.
     * {@link CacheSortedSetFetch.Miss} when the sorted set does not exist.
     * {@link CacheSortedSetFetch.Error} on failure.
     */
    sortedSetFetchByScore(cacheName: string, sortedSetName: string, options?: SortedSetFetchByScoreOptions): Promise<CacheSortedSetFetch.Response>;
    /**
     * Look up the rank of an element in the sorted set, by the value of the element.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string | Uint8Array} value - The value of the element whose rank we are retrieving.
     * @returns {Promise<CacheSortedSetGetRank.Response>}
     * {@link CacheSortedSetGetRank.Hit} containing the rank of the requested elements when found.
     * {@link CacheSortedSetGetRank.Miss} when the element does not exist.
     * {@link CacheSortedSetGetRank.Error} on failure.
     */
    sortedSetGetRank(cacheName: string, sortedSetName: string, value: string | Uint8Array): Promise<CacheSortedSetGetRank.Response>;
    /**
     * Look up the score of an element in the sorted set, by the value of the element.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string | Uint8Array} value - The value of the element whose score we are retrieving.
     * @returns {Promise<CacheSortedSetGetScore.Response>}
     * {@link CacheSortedSetGetScore.Hit} containing the score of the requested element when found.
     * {@link CacheSortedSetGetScore.Miss} when the element or collection does not exist.
     * {@link CacheSortedSetGetScore.Error} on failure.
     */
    sortedSetGetScore(cacheName: string, sortedSetName: string, value: string | Uint8Array): Promise<CacheSortedSetGetScore.Response>;
    /**
     * Look up the scores of multiple elements in the sorted set, by the value of the elements.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string[] | Uint8Array[]} values - The values of the elements whose scores we are retrieving.
     * @returns {Promise<CacheSortedSetGetScores.Response>}
     * {@link CacheSortedSetGetScores.Hit} containing the scores of the requested elements when found.
     * {@link CacheSortedSetGetScores.Miss} when the element or collection does not exist.
     * {@link CacheSortedSetGetScores.Error} on failure.
     */
    sortedSetGetScores(cacheName: string, sortedSetName: string, values: string[] | Uint8Array[]): Promise<CacheSortedSetGetScores.Response>;
    /**
     * Increment the score of an element in the sorted set.
     *
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to fetch from.
     * @param {string | Uint8Array} value - The value of the element whose score we are incrementing.
     * @param {number} amount - The quantity to add to the score. May be positive,
     * negative, or zero. Defaults to 1.
     * @param {SortedSetIncrementOptions} options
     * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.
     * Refreshes the sorted set's TTL using the client's default if this is not
     * supplied.
     * @returns {Promise<CacheSortedSetIncrementScore.Response>} -
     * {@link CacheSortedSetIncrementScore.Success} containing the incremented score
     * on success.
     * {@link CacheSortedSetIncrementScore.Error} on failure. Incrementing a score
     * that was not set using this method or is not the string representation of
     * an integer results in a failure with a FailedPreconditionException error.
     */
    sortedSetIncrementScore(cacheName: string, sortedSetName: string, value: string | Uint8Array, amount?: number, options?: SortedSetIncrementOptions): Promise<CacheSortedSetIncrementScore.Response>;
    /**
     * Remove an element from the sorted set
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to remove from.
     * @param {string | Uint8Array} value - The value of the element to remove from the set.
     * @returns {Promise<CacheSortedSetRemoveElement.Response>}
     * {@link CacheSortedSetRemoveElement.Success} if the element was successfully removed
     * {@link CacheSortedSetIncrementScore.Error} on failure
     */
    sortedSetRemoveElement(cacheName: string, sortedSetName: string, value: string | Uint8Array): Promise<CacheSortedSetRemoveElement.Response>;
    /**
     * Remove multiple elements from the sorted set
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set to remove from.
     * @param {string | Uint8Array} values - The values of the elements to remove from the set.
     * @returns {Promise<CacheSortedSetRemoveElement.Response>}
     * {@link CacheSortedSetRemoveElement.Success} if the elements were successfully removed
     * {@link CacheSortedSetIncrementScore.Error} on failure
     */
    sortedSetRemoveElements(cacheName: string, sortedSetName: string, values: string[] | Uint8Array[]): Promise<CacheSortedSetRemoveElements.Response>;
    /**
     * Fetch length (number of items) of sorted set
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set name.
     * @returns {Promise<CacheSortedSetLength.Response>}
     * {@link CacheSortedSetLength.Hit} containing the length if the sorted set exists.
     * {@link CacheSortedSetLength.Miss} if the sorted set does not exist.
     * {@link CacheSortedSetLength.Error} on failure.
     */
    sortedSetLength(cacheName: string, sortedSetName: string): Promise<CacheSortedSetLength.Response>;
    /**
     * Fetch length (number of items) of sorted set within the provided score range
     * @param {string} cacheName - The cache containing the sorted set.
     * @param {string} sortedSetName - The sorted set name.
     * @param {SortedSetLengthByScoreOptions} options - Optional parameter for specifying the score range to search in.
     * @param {number} [options.minScore] - The lower bound on the score range to search in.
     * @param {number} [options.maxScore] - The upper bound on the score range to search in.
     * @returns {Promise<CacheSortedSetLengthByScore.Response>}
     * {@link CacheSortedSetLengthByScore.Hit} containing the length if the sorted set exists.
     * {@link CacheSortedSetLengthByScore.Miss} if the sorted set does not exist.
     * {@link CacheSortedSetLengthByScore.Error} on failure.
     */
    sortedSetLengthByScore(cacheName: string, sortedSetName: string, options?: SortedSetLengthByScoreOptions): Promise<CacheSortedSetLengthByScore.Response>;
    /**
     * Return the type of the key in the cache
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which type is requested.
     * @returns {Promise<CacheItemGetType.Response>}
     * {@link CacheItemGetType.Hit} containing type of key when found.
     * {@link CacheItemGetType.Miss} when the key does not exist.
     * {@link CacheItemGetType.Error} on failure.
     */
    itemGetType(cacheName: string, key: string | Uint8Array): Promise<CacheItemGetType.Response>;
    /**
     * Return the remaining ttl of the key in the cache in milliseconds.
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which the ttl remaining is requested.
     * @returns {Promise<CacheItemGetTtl.Response>}
     * {@link CacheItemGetTtl.Hit} containing ttl remaining of key when found.
     * {@link CacheItemGetTtl.Miss} when the key does not exist.
     * {@link CacheItemGetTtl.Error} on failure.
     */
    itemGetTtl(cacheName: string, key: string | Uint8Array): Promise<CacheItemGetTtl.Response>;
    /**
     * Check if the provided key exists in the cache
     * @param {string} cacheName - The cache to look in.
     * @param {string | Uint8Array} key - The key to look up.
     * @returns {Promise<CacheKeyExists.Response>}
     * {@link CacheKeyExists.Success} if key is found? or if key is checked?
     * {@link CacheKeyExists.Error} on failure.
     */
    keyExists(cacheName: string, key: string | Uint8Array): Promise<CacheKeyExists.Response>;
    /**
     * Check if the provided keys exist in the cache
     * @param {string} cacheName - The cache to look in.
     * @param {string[] | Uint8Array[]} keys - The keys to look up.
     * @returns {Promise<CacheKeysExist.Response>}
     * {@link CacheKeysExist.Success} if at least one key is found? if all keys checked?
     * {@link CacheKeysExist.Error} on failure.
     */
    keysExist(cacheName: string, keys: string[] | Uint8Array[]): Promise<CacheKeysExist.Response>;
    /**
     * Update the ttl of the key in the cache in milliseconds.
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which the ttl remaining is requested.
     * @param {number} ttlMilliseconds - The ttl in milliseconds that should overwrite the current ttl.
     * @returns {Promise<CacheUpdateTtl.Response>}
     * {@link CacheUpdateTtl.Set} when the ttl was successfully overwritten.
     * {@link CacheUpdateTtl.Miss} when the key does not exist.
     * {@link CacheUpdateTtl.Error} on failure.
     */
    updateTtl(cacheName: string, key: string | Uint8Array, ttlMilliseconds: number): Promise<CacheUpdateTtl.Response>;
    /**
     * Increase the ttl of the key in the cache in milliseconds.
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which the ttl remaining is requested.
     * @param {number} ttlMilliseconds - The ttl in milliseconds that should
     * overwrite the current ttl. Should be greater than the current ttl.
     * @returns {Promise<CacheIncreaseTtl.Response>}
     * {@link CacheIncreaseTtl.Set} when the ttl was successfully increased.
     * {@link CacheIncreaseTtl.Miss} when the key does not exist.
     * {@link CacheIncreaseTtl.Error} on failure.
     */
    increaseTtl(cacheName: string, key: string | Uint8Array, ttlMilliseconds: number): Promise<CacheIncreaseTtl.Response>;
    /**
     * Decrease the ttl of the key in the cache in milliseconds.
     * @param {string} cacheName - The cache containing the key.
     * @param {string} key - The key for which the ttl remaining is requested.
     * @param {number} ttlMilliseconds - The ttl in milliseconds that should
     * overwrite the current ttl. Should be less than the current ttl.
     * @returns {Promise<CacheDecreaseTtl.Response>}
     * {@link CacheDecreaseTtl.Set} when the ttl was successfully decreased.
     * {@link CacheDecreaseTtl.Miss} when the key does not exist.
     * {@link CacheDecreaseTtl.Error} on failure.
     */
    decreaseTtl(cacheName: string, key: string | Uint8Array, ttlMilliseconds: number): Promise<CacheDecreaseTtl.Response>;
    protected getNextDataClient(): IDataClient;
    abstract close(): void;
}
