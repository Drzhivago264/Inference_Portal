"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectionTtl = void 0;
const utils_1 = require("../internal/utils");
/** Represents the desired behavior for managing the TTL on collection
 *  objects (dictionaries, lists, sets) in your cache.
 *
 *  For cache operations that modify a collection, there are a few things
 *  to consider.  The first time the collection is created, we need to
 *  set a TTL on it.  For subsequent operations that modify the collection
 *  you may choose to update the TTL in order to prolong the life of the
 *  cached collection object, or you may choose to leave the TTL unmodified
 *  in order to ensure that the collection expires at the original TTL.
 *
 *  The default behavior is to refresh the TTL (to prolong the life of the
 *  collection) each time it is written.  This behavior can be modified
 *  by calling CollectionTtl.withNoRefreshTtlOnUpdates().
 *
 *  A null TTL means to use the client's TTL.
 */
class CollectionTtl {
    /**
     * If refreshTtl is true, the client must update the collection's TTL
     * when it modifies a collection.
     * A null ttl means to use the client's TTL.
     * @param {number | null} [ttlSeconds=null]
     * @param {boolean} [refreshTtl=true]
     */
    constructor(ttlSeconds = null, refreshTtl = true) {
        if (ttlSeconds !== null) {
            (0, utils_1.validateTtlSeconds)(ttlSeconds);
        }
        this._refreshTtl = refreshTtl;
        this._ttlSeconds = ttlSeconds;
    }
    /** Time-to-live, in seconds.
     * @returns {number | null}
     */
    ttlSeconds() {
        return this._ttlSeconds;
    }
    /** Time-to-live, in milliseconds.
     * @returns {number | null}
     */
    ttlMilliseconds() {
        return this._ttlSeconds === null ? null : this._ttlSeconds * 1000;
    }
    /** Whether or not to refresh a collection's TTL when it's modified.
     * @returns {boolean}
     */
    refreshTtl() {
        return this._refreshTtl;
    }
    /** The default way to handle TTLs for collections. The client's default TTL
     *  will be used, and the TTL for the collection will be refreshed any
     *  time the collection is modified.
     * @constructor
     * @returns {CollectionTtl}
     */
    static fromCacheTtl() {
        return new CollectionTtl(null, true);
    }
    /** Constructs a CollectionTtl with the specified TTL. The TTL
     *  for the collection will be refreshed any time the collection is
     *  modified.
     * @constructor
     * @param {number} [ttlSeconds]
     * @returns {CollectionTtl}
     */
    static of(ttlSeconds) {
        return new CollectionTtl(ttlSeconds, true);
    }
    /** Constructs a CollectionTtl with the specified TTL.
     *  Will only refresh if the TTL is provided.
     * @constructor
     * @param {number | null} [ttlSeconds=null]
     * @returns {CollectionTtl}
     */
    static refreshTtlIfProvided(ttlSeconds = null) {
        return new CollectionTtl(ttlSeconds, ttlSeconds !== null);
    }
    /** Copies the CollectionTtl, but it will refresh the TTL when
     *  the collection is modified.
     * @returns {CollectionTtl}
     */
    withRefreshTtlOnUpdates() {
        return new CollectionTtl(this._ttlSeconds, true);
    }
    /** Copies the CollectionTTL, but the TTL will not be refreshed
     *  when the collection is modified. Use this if you want to ensure
     *  that your collection expires at the originally specified time, even
     *  if you make modifications to the value of the collection.
     * @returns {CollectionTtl}
     */
    withNoRefreshTtlOnUpdates() {
        return new CollectionTtl(this._ttlSeconds, false);
    }
    /** A string represenation of the CollectionTtl for debugging purposes.
     * @return {CollectionTtl}
     */
    toString() {
        return `ttl: ${this._ttlSeconds || 'null'}, refreshTtl: ${this._refreshTtl ? 'true' : 'false'}`;
    }
}
exports.CollectionTtl = CollectionTtl;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sbGVjdGlvbi10dGwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvY29sbGVjdGlvbi10dGwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNkNBQXFEO0FBRXJEOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE1BQWEsYUFBYTtJQUl4Qjs7Ozs7O09BTUc7SUFDSCxZQUFZLGFBQTRCLElBQUksRUFBRSxVQUFVLEdBQUcsSUFBSTtRQUM3RCxJQUFJLFVBQVUsS0FBSyxJQUFJLEVBQUU7WUFDdkIsSUFBQSwwQkFBa0IsRUFBQyxVQUFVLENBQUMsQ0FBQztTQUNoQztRQUNELElBQUksQ0FBQyxXQUFXLEdBQUcsVUFBVSxDQUFDO1FBQzlCLElBQUksQ0FBQyxXQUFXLEdBQUcsVUFBVSxDQUFDO0lBQ2hDLENBQUM7SUFFRDs7T0FFRztJQUNJLFVBQVU7UUFDZixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksZUFBZTtRQUNwQixPQUFPLElBQUksQ0FBQyxXQUFXLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO0lBQ3BFLENBQUM7SUFFRDs7T0FFRztJQUNJLFVBQVU7UUFDZixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksTUFBTSxDQUFDLFlBQVk7UUFDeEIsT0FBTyxJQUFJLGFBQWEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLE1BQU0sQ0FBQyxFQUFFLENBQUMsVUFBa0I7UUFDakMsT0FBTyxJQUFJLGFBQWEsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksTUFBTSxDQUFDLG9CQUFvQixDQUNoQyxhQUE0QixJQUFJO1FBRWhDLE9BQU8sSUFBSSxhQUFhLENBQUMsVUFBVSxFQUFFLFVBQVUsS0FBSyxJQUFJLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksdUJBQXVCO1FBQzVCLE9BQU8sSUFBSSxhQUFhLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSx5QkFBeUI7UUFDOUIsT0FBTyxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRDs7T0FFRztJQUNJLFFBQVE7UUFDYixPQUFPLFFBQVEsSUFBSSxDQUFDLFdBQVcsSUFBSSxNQUFNLGlCQUN2QyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQzlCLEVBQUUsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQW5HRCxzQ0FtR0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3ZhbGlkYXRlVHRsU2Vjb25kc30gZnJvbSAnLi4vaW50ZXJuYWwvdXRpbHMnO1xuXG4vKiogUmVwcmVzZW50cyB0aGUgZGVzaXJlZCBiZWhhdmlvciBmb3IgbWFuYWdpbmcgdGhlIFRUTCBvbiBjb2xsZWN0aW9uXG4gKiAgb2JqZWN0cyAoZGljdGlvbmFyaWVzLCBsaXN0cywgc2V0cykgaW4geW91ciBjYWNoZS5cbiAqXG4gKiAgRm9yIGNhY2hlIG9wZXJhdGlvbnMgdGhhdCBtb2RpZnkgYSBjb2xsZWN0aW9uLCB0aGVyZSBhcmUgYSBmZXcgdGhpbmdzXG4gKiAgdG8gY29uc2lkZXIuICBUaGUgZmlyc3QgdGltZSB0aGUgY29sbGVjdGlvbiBpcyBjcmVhdGVkLCB3ZSBuZWVkIHRvXG4gKiAgc2V0IGEgVFRMIG9uIGl0LiAgRm9yIHN1YnNlcXVlbnQgb3BlcmF0aW9ucyB0aGF0IG1vZGlmeSB0aGUgY29sbGVjdGlvblxuICogIHlvdSBtYXkgY2hvb3NlIHRvIHVwZGF0ZSB0aGUgVFRMIGluIG9yZGVyIHRvIHByb2xvbmcgdGhlIGxpZmUgb2YgdGhlXG4gKiAgY2FjaGVkIGNvbGxlY3Rpb24gb2JqZWN0LCBvciB5b3UgbWF5IGNob29zZSB0byBsZWF2ZSB0aGUgVFRMIHVubW9kaWZpZWRcbiAqICBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCB0aGUgY29sbGVjdGlvbiBleHBpcmVzIGF0IHRoZSBvcmlnaW5hbCBUVEwuXG4gKlxuICogIFRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHJlZnJlc2ggdGhlIFRUTCAodG8gcHJvbG9uZyB0aGUgbGlmZSBvZiB0aGVcbiAqICBjb2xsZWN0aW9uKSBlYWNoIHRpbWUgaXQgaXMgd3JpdHRlbi4gIFRoaXMgYmVoYXZpb3IgY2FuIGJlIG1vZGlmaWVkXG4gKiAgYnkgY2FsbGluZyBDb2xsZWN0aW9uVHRsLndpdGhOb1JlZnJlc2hUdGxPblVwZGF0ZXMoKS5cbiAqXG4gKiAgQSBudWxsIFRUTCBtZWFucyB0byB1c2UgdGhlIGNsaWVudCdzIFRUTC5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbGxlY3Rpb25UdGwge1xuICBwcml2YXRlIHJlYWRvbmx5IF90dGxTZWNvbmRzOiBudW1iZXIgfCBudWxsO1xuICBwcml2YXRlIHJlYWRvbmx5IF9yZWZyZXNoVHRsOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJZiByZWZyZXNoVHRsIGlzIHRydWUsIHRoZSBjbGllbnQgbXVzdCB1cGRhdGUgdGhlIGNvbGxlY3Rpb24ncyBUVExcbiAgICogd2hlbiBpdCBtb2RpZmllcyBhIGNvbGxlY3Rpb24uXG4gICAqIEEgbnVsbCB0dGwgbWVhbnMgdG8gdXNlIHRoZSBjbGllbnQncyBUVEwuXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gW3R0bFNlY29uZHM9bnVsbF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaFR0bD10cnVlXVxuICAgKi9cbiAgY29uc3RydWN0b3IodHRsU2Vjb25kczogbnVtYmVyIHwgbnVsbCA9IG51bGwsIHJlZnJlc2hUdGwgPSB0cnVlKSB7XG4gICAgaWYgKHR0bFNlY29uZHMgIT09IG51bGwpIHtcbiAgICAgIHZhbGlkYXRlVHRsU2Vjb25kcyh0dGxTZWNvbmRzKTtcbiAgICB9XG4gICAgdGhpcy5fcmVmcmVzaFR0bCA9IHJlZnJlc2hUdGw7XG4gICAgdGhpcy5fdHRsU2Vjb25kcyA9IHR0bFNlY29uZHM7XG4gIH1cblxuICAvKiogVGltZS10by1saXZlLCBpbiBzZWNvbmRzLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgbnVsbH1cbiAgICovXG4gIHB1YmxpYyB0dGxTZWNvbmRzKCk6IG51bWJlciB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl90dGxTZWNvbmRzO1xuICB9XG5cbiAgLyoqIFRpbWUtdG8tbGl2ZSwgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgbnVsbH1cbiAgICovXG4gIHB1YmxpYyB0dGxNaWxsaXNlY29uZHMoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX3R0bFNlY29uZHMgPT09IG51bGwgPyBudWxsIDogdGhpcy5fdHRsU2Vjb25kcyAqIDEwMDA7XG4gIH1cblxuICAvKiogV2hldGhlciBvciBub3QgdG8gcmVmcmVzaCBhIGNvbGxlY3Rpb24ncyBUVEwgd2hlbiBpdCdzIG1vZGlmaWVkLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHB1YmxpYyByZWZyZXNoVHRsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9yZWZyZXNoVHRsO1xuICB9XG5cbiAgLyoqIFRoZSBkZWZhdWx0IHdheSB0byBoYW5kbGUgVFRMcyBmb3IgY29sbGVjdGlvbnMuIFRoZSBjbGllbnQncyBkZWZhdWx0IFRUTFxuICAgKiAgd2lsbCBiZSB1c2VkLCBhbmQgdGhlIFRUTCBmb3IgdGhlIGNvbGxlY3Rpb24gd2lsbCBiZSByZWZyZXNoZWQgYW55XG4gICAqICB0aW1lIHRoZSBjb2xsZWN0aW9uIGlzIG1vZGlmaWVkLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHJldHVybnMge0NvbGxlY3Rpb25UdGx9XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21DYWNoZVR0bCgpOiBDb2xsZWN0aW9uVHRsIHtcbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25UdGwobnVsbCwgdHJ1ZSk7XG4gIH1cblxuICAvKiogQ29uc3RydWN0cyBhIENvbGxlY3Rpb25UdGwgd2l0aCB0aGUgc3BlY2lmaWVkIFRUTC4gVGhlIFRUTFxuICAgKiAgZm9yIHRoZSBjb2xsZWN0aW9uIHdpbGwgYmUgcmVmcmVzaGVkIGFueSB0aW1lIHRoZSBjb2xsZWN0aW9uIGlzXG4gICAqICBtb2RpZmllZC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdHRsU2Vjb25kc11cbiAgICogQHJldHVybnMge0NvbGxlY3Rpb25UdGx9XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIG9mKHR0bFNlY29uZHM6IG51bWJlcik6IENvbGxlY3Rpb25UdGwge1xuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvblR0bCh0dGxTZWNvbmRzLCB0cnVlKTtcbiAgfVxuXG4gIC8qKiBDb25zdHJ1Y3RzIGEgQ29sbGVjdGlvblR0bCB3aXRoIHRoZSBzcGVjaWZpZWQgVFRMLlxuICAgKiAgV2lsbCBvbmx5IHJlZnJlc2ggaWYgdGhlIFRUTCBpcyBwcm92aWRlZC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gW3R0bFNlY29uZHM9bnVsbF1cbiAgICogQHJldHVybnMge0NvbGxlY3Rpb25UdGx9XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlZnJlc2hUdGxJZlByb3ZpZGVkKFxuICAgIHR0bFNlY29uZHM6IG51bWJlciB8IG51bGwgPSBudWxsXG4gICk6IENvbGxlY3Rpb25UdGwge1xuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvblR0bCh0dGxTZWNvbmRzLCB0dGxTZWNvbmRzICE9PSBudWxsKTtcbiAgfVxuXG4gIC8qKiBDb3BpZXMgdGhlIENvbGxlY3Rpb25UdGwsIGJ1dCBpdCB3aWxsIHJlZnJlc2ggdGhlIFRUTCB3aGVuXG4gICAqICB0aGUgY29sbGVjdGlvbiBpcyBtb2RpZmllZC5cbiAgICogQHJldHVybnMge0NvbGxlY3Rpb25UdGx9XG4gICAqL1xuICBwdWJsaWMgd2l0aFJlZnJlc2hUdGxPblVwZGF0ZXMoKTogQ29sbGVjdGlvblR0bCB7XG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uVHRsKHRoaXMuX3R0bFNlY29uZHMsIHRydWUpO1xuICB9XG5cbiAgLyoqIENvcGllcyB0aGUgQ29sbGVjdGlvblRUTCwgYnV0IHRoZSBUVEwgd2lsbCBub3QgYmUgcmVmcmVzaGVkXG4gICAqICB3aGVuIHRoZSBjb2xsZWN0aW9uIGlzIG1vZGlmaWVkLiBVc2UgdGhpcyBpZiB5b3Ugd2FudCB0byBlbnN1cmVcbiAgICogIHRoYXQgeW91ciBjb2xsZWN0aW9uIGV4cGlyZXMgYXQgdGhlIG9yaWdpbmFsbHkgc3BlY2lmaWVkIHRpbWUsIGV2ZW5cbiAgICogIGlmIHlvdSBtYWtlIG1vZGlmaWNhdGlvbnMgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcmV0dXJucyB7Q29sbGVjdGlvblR0bH1cbiAgICovXG4gIHB1YmxpYyB3aXRoTm9SZWZyZXNoVHRsT25VcGRhdGVzKCk6IENvbGxlY3Rpb25UdGwge1xuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvblR0bCh0aGlzLl90dGxTZWNvbmRzLCBmYWxzZSk7XG4gIH1cblxuICAvKiogQSBzdHJpbmcgcmVwcmVzZW5hdGlvbiBvZiB0aGUgQ29sbGVjdGlvblR0bCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uVHRsfVxuICAgKi9cbiAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGB0dGw6ICR7dGhpcy5fdHRsU2Vjb25kcyB8fCAnbnVsbCd9LCByZWZyZXNoVHRsOiAke1xuICAgICAgdGhpcy5fcmVmcmVzaFR0bCA/ICd0cnVlJyA6ICdmYWxzZSdcbiAgICB9YDtcbiAgfVxufVxuIl19