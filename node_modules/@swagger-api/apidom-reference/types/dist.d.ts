/// <reference types="node" />
/// <reference types="@swagger-api/apidom-core/types/minim" />
import { ParseResultElement, Element, RefElement } from '@swagger-api/apidom-core';
import stampit from 'stampit';
import { ApiDOMError } from '@swagger-api/apidom-error';

interface File$1 {
    uri: string;
    mediaType: string;
    data: Buffer | DataView | ArrayBuffer | string;
    parseResult: ParseResultElement;
    readonly extension: string;
}
interface Resolver$1 {
    canRead(file: File$1): boolean;
    read(file: File$1): Promise<Buffer>;
}
interface HttpResolver$1 extends Resolver$1 {
    timeout: number;
    redirects: number;
    withCredentials: boolean;
    getHttpClient(): unknown;
}
interface Parser$1 {
    allowEmpty: boolean;
    sourceMap: boolean;
    fileExtensions: string[];
    mediaTypes: string[];
    decoder: TextDecoder;
    canParse(file: File$1): boolean | Promise<boolean>;
    parse(file: File$1): Promise<ParseResultElement>;
}
interface ResolveStrategy$1 {
    canResolve(file: File$1): boolean;
    resolve(file: File$1, options: ReferenceOptions): Promise<ReferenceSet$1>;
}
interface DereferenceStrategy$1 {
    canDereference(file: File$1, options: ReferenceOptions): boolean;
    dereference(file: File$1, options: ReferenceOptions): Promise<Element>;
}
interface BundleStrategy$1 {
    canBundle(file: File$1): boolean;
    bundle(file: File$1, options: ReferenceOptions): Promise<Element>;
}
interface Reference$1 {
    uri: string;
    depth: number;
    value: ParseResultElement;
    refSet: null | ReferenceSet$1;
    errors: Array<Error>;
}
interface ReferenceSet$1 {
    rootRef: Reference$1;
    refs: Array<Reference$1>;
    circular: boolean;
    readonly size: number;
    add(reference: Reference$1): ReferenceSet$1;
    merge(anotherRefSet: ReferenceSet$1): ReferenceSet$1;
    has(uri: string): boolean;
    find(callback: (reference: Reference$1) => boolean): undefined | Reference$1;
    values(): IterableIterator<Reference$1>;
    clean(): void;
}
interface ReferenceParseOptions {
    mediaType: string;
    parsers: Array<Parser$1>;
    parserOpts: Record<string, any>;
}
interface ReferenceResolveOptions {
    baseURI: string;
    resolvers: Array<Resolver$1>;
    resolverOpts: Record<string, any>;
    strategies: Array<ResolveStrategy$1>;
    strategyOpts: Record<string, any>;
    internal: boolean;
    external: boolean;
    maxDepth: number;
}
interface ReferenceDereferenceOptions {
    strategies: Array<DereferenceStrategy$1>;
    strategyOpts: Record<string, any>;
    refSet: null | ReferenceSet$1;
    maxDepth: number;
    circular: 'ignore' | 'replace' | 'error';
    circularReplacer: (ref: RefElement) => unknown;
    immutable: boolean;
}
interface ReferenceBundleOptions {
    strategies: Array<BundleStrategy$1>;
    refSet: null | ReferenceSet$1;
    maxDepth: number;
}
interface ReferenceOptions {
    readonly parse: ReferenceParseOptions;
    readonly resolve: ReferenceResolveOptions;
    readonly dereference: ReferenceDereferenceOptions;
    readonly bundle: ReferenceBundleOptions;
}

/**
 * This stamp represents a File object with url and data.
 */
declare const File: stampit.Stamp<File$1>;

/**
 * SPDX-FileCopyrightText: Copyright (c) 2015 James Messinger
 *
 * SPDX-License-Identifier: MIT
 */
type WindowsPredicate = () => boolean;
/**
 * Returns the protocol of the given URL, or `undefined` if it has no protocol.
 */
declare const getProtocol: (url: string) => string | undefined;
/**
 * Returns true if given URL has protocol.
 */
declare const hasProtocol: (url: string) => boolean;
/**
 * Returns the lower-cased file extension of the given URL,
 * or an empty string if it has no extension.
 */
declare const getExtension: (url: string) => string;
/**
 * Determines whether the given path is a filesystem path.
 * This includes "file://" URLs.
 */
declare const isFileSystemPath: (uri: string) => boolean;
/**
 * Determines whether the given URI is an HTTP(S) URL.
 */
declare const isHttpUrl: (url: string) => boolean;
/**
 * Determines whether the given URI
 * @param uri
 */
declare const isURI: (uri: string) => boolean;
interface ToFileSystemPathOptions {
    keepFileProtocol?: boolean;
    isWindows?: WindowsPredicate;
}
/**
 * Converts a URL to a local filesystem path.
 */
declare const toFileSystemPath: (uri: string, options?: ToFileSystemPathOptions) => string;
/**
 * Converts a filesystem path to a properly-encoded URL.
 *
 * This is intended to handle situations where resolver is called
 * with a filesystem path that contains characters which are not allowed in URLs.
 *
 * @example
 * The following filesystem paths would be converted to the following URLs:
 *
 *    <"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\'%3E.json
 *    C:\\My Documents\\File (1).json   ==>   C:/My%20Documents/File%20(1).json
 *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json
 */
declare const fromFileSystemPath: (uri: string) => string;
/**
 * Returns the hash (URL fragment), of the given path.
 * If there is no hash, then the root hash ("#") is returned.
 */
declare const getHash: (uri: string) => string;
/**
 * Removes the hash (URL fragment), if any, from the given path.
 */
declare const stripHash: (uri: string) => string;
/**
 * Returns the current working directory (in Node) or the current page URL (in browsers).
 */
declare const cwd: () => string;
/**
 *  Resolves a target URI relative to a base URI in a manner similar to that of a Web browser resolving an anchor tag HREF.
 */
declare const resolve$1: (from: string, to: string) => string;
/**
 * Sanitizes/Encodes URI to it's url encoded form.
 *
 * The functional will compensate with the usecase when
 * already sanitized URI is passed to it,
 * by first unsatizing it and then performing sanitization again.
 */
declare const sanitize: (uri: string) => string;
/**
 * Unsanitizes/Decodes URI to it's url encoded form.
 * This function already assumes that hash part of the URI
 * has been removed prior to transforming it to it's sanitized form.
 */
declare const unsanitize: (uri: string) => string;

declare const url_d_cwd: typeof cwd;
declare const url_d_fromFileSystemPath: typeof fromFileSystemPath;
declare const url_d_getExtension: typeof getExtension;
declare const url_d_getHash: typeof getHash;
declare const url_d_getProtocol: typeof getProtocol;
declare const url_d_hasProtocol: typeof hasProtocol;
declare const url_d_isFileSystemPath: typeof isFileSystemPath;
declare const url_d_isHttpUrl: typeof isHttpUrl;
declare const url_d_isURI: typeof isURI;
declare const url_d_sanitize: typeof sanitize;
declare const url_d_stripHash: typeof stripHash;
declare const url_d_toFileSystemPath: typeof toFileSystemPath;
declare const url_d_unsanitize: typeof unsanitize;
declare namespace url_d {
  export { url_d_cwd as cwd, url_d_fromFileSystemPath as fromFileSystemPath, url_d_getExtension as getExtension, url_d_getHash as getHash, url_d_getProtocol as getProtocol, url_d_hasProtocol as hasProtocol, url_d_isFileSystemPath as isFileSystemPath, url_d_isHttpUrl as isHttpUrl, url_d_isURI as isURI, resolve$1 as resolve, url_d_sanitize as sanitize, url_d_stripHash as stripHash, url_d_toFileSystemPath as toFileSystemPath, url_d_unsanitize as unsanitize };
}

declare const Parser: stampit.Stamp<Parser$1>;

declare const Resolver: stampit.Stamp<Resolver$1>;

declare const HttpResolver: stampit.Stamp<HttpResolver$1>;

declare const ResolveStrategy: stampit.Stamp<ResolveStrategy$1>;

declare const DereferenceStrategy: stampit.Stamp<DereferenceStrategy$1>;

declare class AncestorLineage<T extends Element> extends Array<Set<T>> {
    includesCycle(element: T): boolean;
    includes(searchElement: Set<T> | T, fromIndex?: number): boolean;
    findItem(predicate: (item: T) => boolean): T | undefined;
}

declare const BundleStrategy: stampit.Stamp<BundleStrategy$1>;

declare const defaultOptions: ReferenceOptions;

declare const merge: (lObj: ReferenceOptions, rObj: Record<string, any>) => ReferenceOptions;

declare const Reference: stampit.Stamp<Reference$1>;

declare const ReferenceSet: stampit.Stamp<ReferenceSet$1>;

declare class BundleError extends ApiDOMError {
}

declare class MaximumBundleDepthError extends BundleError {
}

declare class UnmatchedBundleStrategyError extends BundleError {
}

declare class DereferenceError extends ApiDOMError {
}

declare class EvaluationElementIdError extends ApiDOMError {
}

declare class JsonSchema$anchorError extends ApiDOMError {
}

declare class EvaluationJsonSchema$anchorError extends JsonSchema$anchorError {
}

declare class JsonSchemaUriError extends ApiDOMError {
}

declare class EvaluationJsonSchemaUriError extends JsonSchemaUriError {
}

declare class InvalidJsonSchema$anchorError extends JsonSchema$anchorError {
    constructor(anchor: string);
}

declare class MaximumDereferenceDepthError extends DereferenceError {
}

declare class ResolveError extends ApiDOMError {
}

declare class MaximumResolveDepthError extends ResolveError {
}

declare class ParseError extends ApiDOMError {
}

declare class ParserError extends ParseError {
}

declare class PluginError extends ApiDOMError {
    plugin: any;
    constructor(message: string, options: {
        cause?: Error;
        plugin: any;
    });
}

declare class ResolverError extends ResolveError {
}

declare class UnmatchedDereferenceStrategyError extends DereferenceError {
}

declare class UnmatchedResolveStrategyError extends ResolveError {
}

declare class UnmatchedResolverError extends ResolverError {
}

declare const readFile: (uri: string, options?: {}) => Promise<Buffer>;
declare const parse: (uri: string, options?: {}) => Promise<ParseResultElement>;
declare const resolve: (uri: string, options?: {}) => Promise<ReferenceSet$1>;
declare const resolveApiDOM: <T extends Element>(element: T, options?: {}) => Promise<ReferenceSet$1>;
declare const dereference: (uri: string, options?: {}) => Promise<ParseResultElement>;
declare const dereferenceApiDOM: <T extends Element>(element: T, options?: {}) => Promise<T>;
declare const bundle: (uri: string, options?: {}) => Promise<ParseResultElement>;

export { BundleError, BundleStrategy, AncestorLineage as DereferenceAncestorLineage, DereferenceError, DereferenceStrategy, EvaluationElementIdError, EvaluationJsonSchema$anchorError, EvaluationJsonSchemaUriError, File, HttpResolver, InvalidJsonSchema$anchorError, JsonSchema$anchorError, JsonSchemaUriError as JsonSchemaURIError, MaximumBundleDepthError, MaximumDereferenceDepthError, MaximumResolveDepthError, ParseError, Parser, ParserError, PluginError, Reference, ReferenceSet, ResolveError, ResolveStrategy, Resolver, ResolverError, UnmatchedBundleStrategyError, UnmatchedDereferenceStrategyError, UnmatchedResolveStrategyError, UnmatchedResolverError, bundle, dereference, dereferenceApiDOM, merge as mergeOptions, defaultOptions as options, parse, readFile, resolve, resolveApiDOM, url_d as url };
