/*! For license information please see tsparticles.interaction.external.grab.min.js.LICENSE.txt */
!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e(require("@tsparticles/engine"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine"],e);else{var o="object"==typeof exports?e(require("@tsparticles/engine")):e(t.window);for(var i in o)("object"==typeof exports?exports:t)[i]=o[i]}}(this,(t=>(()=>{var e={303:e=>{e.exports=t}},o={};function i(t){var n=o[t];if(void 0!==n)return n.exports;var r=o[t]={exports:{}};return e[t](r,r.exports,i),r.exports}i.d=(t,e)=>{for(var o in e)i.o(e,o)&&!i.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var n={};return(()=>{i.r(n),i.d(n,{Grab:()=>o,GrabLinks:()=>e,loadExternalGrabInteraction:()=>a});var t=i(303);class e{constructor(){this.blink=!1,this.consent=!1,this.opacity=1}load(e){e&&(void 0!==e.blink&&(this.blink=e.blink),void 0!==e.color&&(this.color=t.OptionsColor.create(this.color,e.color)),void 0!==e.consent&&(this.consent=e.consent),void 0!==e.opacity&&(this.opacity=e.opacity))}}class o{constructor(){this.distance=100,this.links=new e}load(t){t&&(void 0!==t.distance&&(this.distance=t.distance),this.links.load(t.links))}}function r(e,o,i,n,r){e.canvas.draw((e=>{const s=o.getPosition();!function(e,o,i,n,r,s){(0,t.drawLine)(e,i,n),e.strokeStyle=(0,t.getStyleFromRgb)(r,s),e.lineWidth=o,e.stroke()}(e,o.retina.linksWidth??0,s,r,i,n)}))}class s extends t.ExternalInteractorBase{constructor(t){super(t)}clear(){}init(){const t=this.container,e=t.actualOptions.interactivity.modes.grab;e&&(t.retina.grabModeDistance=e.distance*t.retina.pixelRatio)}interact(){const e=this.container,o=e.actualOptions.interactivity;if(!o.modes.grab||!o.events.onHover.enable||e.interactivity.status!==t.mouseMoveEvent)return;const i=e.interactivity.mouse.position;if(!i)return;const n=e.retina.grabModeDistance;if(!n||n<0)return;const s=e.particles.quadTree.queryCircle(i,n,(t=>this.isEnabled(t)));for(const a of s){const s=a.getPosition(),c=(0,t.getDistance)(s,i);if(c>n)continue;const l=o.modes.grab.links,d=l.opacity,p=d-c*d/n;if(p<=0)continue;const b=l.color??a.options.links?.color;if(!e.particles.grabLineColor&&b){const i=o.modes.grab.links;e.particles.grabLineColor=(0,t.getLinkRandomColor)(b,i.blink,i.consent)}const u=(0,t.getLinkColor)(a,void 0,e.particles.grabLineColor);u&&r(e,a,u,p,i)}}isEnabled(e){const o=this.container,i=o.interactivity.mouse,n=(e?.interactivity??o.actualOptions.interactivity).events;return n.onHover.enable&&!!i.position&&(0,t.isInArray)("grab",n.onHover.mode)}loadModeOptions(t,...e){t.grab||(t.grab=new o);for(const o of e)t.grab.load(o?.grab)}reset(){}}async function a(t,e=!0){await t.addInteractor("externalGrab",(t=>Promise.resolve(new s(t))),e)}})(),n})()));