/*! For license information please see tsparticles.move.base.min.js.LICENSE.txt */
!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t(require("@tsparticles/engine"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine"],t);else{var i="object"==typeof exports?t(require("@tsparticles/engine")):t(e.window);for(var n in i)("object"==typeof exports?exports:e)[n]=i[n]}}(this,(e=>(()=>{var t={303:t=>{t.exports=e}},i={};function n(e){var o=i[e];if(void 0!==o)return o.exports;var a=i[e]={exports:{}};return t[e](a,a.exports,n),a.exports}n.d=(e,t)=>{for(var i in t)n.o(t,i)&&!n.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var o={};return(()=>{n.r(o),n.d(o,{loadBaseMover:()=>s});var e=n(303);const t=1;function i(i,n,o,a,s,r){!function(i,n){const o=i.options,a=o.move.path;if(!a.enable)return;if(i.lastPathTime<=i.pathDelay)return void(i.lastPathTime+=n.value);const s=i.pathGenerator?.generate(i,n);s&&i.velocity.addTo(s);a.clamp&&(i.velocity.x=(0,e.clamp)(i.velocity.x,-t,t),i.velocity.y=(0,e.clamp)(i.velocity.y,-t,t));i.lastPathTime-=i.pathDelay}(i,r);const c=i.gravity,l=c?.enable&&c.inverse?-t:t;s&&o&&(i.velocity.x+=s*r.factor/(60*o)),c?.enable&&o&&(i.velocity.y+=l*(c.acceleration*r.factor)/(60*o));const p=i.moveDecay;i.velocity.multTo(p);const y=i.velocity.mult(o);c?.enable&&a>0&&(!c.inverse&&y.y>=0&&y.y>=a||c.inverse&&y.y<=0&&y.y<=-a)&&(y.y=l*a,o&&(i.velocity.y=y.y/o));const v=i.options.zIndex,d=(t-i.zIndexFactor)**v.velocityRate;y.multTo(d);const{position:u}=i;u.addTo(y),n.vibrate&&(u.x+=Math.sin(u.x*Math.cos(u.y)),u.y+=Math.cos(u.y*Math.sin(u.x)))}class a{init(t){const i=t.options.move.gravity;t.gravity={enable:i.enable,acceleration:(0,e.getRangeValue)(i.acceleration),inverse:i.inverse},function(t){const i=t.container,n=t.options.move.spin;if(!n.enable)return;const o=n.position??{x:50,y:50},a={x:.01*o.x*i.canvas.size.width,y:.01*o.y*i.canvas.size.height},s=t.getPosition(),r=(0,e.getDistance)(s,a),c=(0,e.getRangeValue)(n.acceleration);t.retina.spinAcceleration=c*i.retina.pixelRatio,t.spin={center:a,direction:t.velocity.x>=0?e.RotateDirection.clockwise:e.RotateDirection.counterClockwise,angle:t.velocity.angle,radius:r,acceleration:t.retina.spinAcceleration}}(t)}isEnabled(e){return!e.destroyed&&e.options.move.enable}move(n,o){const a=n.options,s=a.move;if(!s.enable)return;const r=n.container,c=r.retina.pixelRatio;n.retina.moveSpeed??=(0,e.getRangeValue)(s.speed)*c,n.retina.moveDrift??=(0,e.getRangeValue)(n.options.move.drift)*c;const l=function(e){return e.slow.inRange?e.slow.factor:t}(n),p=n.retina.moveSpeed*r.retina.reduceFactor,y=n.retina.moveDrift,v=(0,e.getRangeMax)(a.size.value)*c,d=p*(s.size?n.getRadius()/v:1)*l*(o.factor||1)/2,u=n.retina.maxSpeed??r.retina.maxSpeed;s.spin.enable?function(i,n){const o=i.container;if(!i.spin)return;const a={x:i.spin.direction===e.RotateDirection.clockwise?Math.cos:Math.sin,y:i.spin.direction===e.RotateDirection.clockwise?Math.sin:Math.cos};i.position.x=i.spin.center.x+i.spin.radius*a.x(i.spin.angle),i.position.y=i.spin.center.y+i.spin.radius*a.y(i.spin.angle),i.spin.radius+=i.spin.acceleration;const s=Math.max(o.canvas.size.width,o.canvas.size.height),r=.5*s;i.spin.radius>r?(i.spin.radius=r,i.spin.acceleration*=-t):i.spin.radius<0&&(i.spin.radius=0,i.spin.acceleration*=-t),i.spin.angle+=.01*n*(t-i.spin.radius/s)}(n,d):i(n,s,d,u,y,o),function(t){const i=t.initialPosition,{dx:n,dy:o}=(0,e.getDistances)(i,t.position),a=Math.abs(n),s=Math.abs(o),{maxDistance:r}=t.retina,c=r.horizontal,l=r.vertical;if(!c&&!l)return;if((c&&a>=c||l&&s>=l)&&!t.misplaced)t.misplaced=!!c&&a>c||!!l&&s>l,c&&(t.velocity.x=.5*t.velocity.y-t.velocity.x),l&&(t.velocity.y=.5*t.velocity.x-t.velocity.y);else if((!c||a<c)&&(!l||s<l)&&t.misplaced)t.misplaced=!1;else if(t.misplaced){const n=t.position,o=t.velocity;c&&(n.x<i.x&&o.x<0||n.x>i.x&&o.x>0)&&(o.x*=-(0,e.getRandom)()),l&&(n.y<i.y&&o.y<0||n.y>i.y&&o.y>0)&&(o.y*=-(0,e.getRandom)())}}(n)}}async function s(e,t=!0){await e.addMover("base",(()=>Promise.resolve(new a)),t)}})(),o})()));