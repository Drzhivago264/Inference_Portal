/*! For license information please see tsparticles.updater.out-modes.min.js.LICENSE.txt */
!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e(require("@tsparticles/engine"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine"],e);else{var o="object"==typeof exports?e(require("@tsparticles/engine")):e(t.window);for(var i in o)("object"==typeof exports?exports:t)[i]=o[i]}}(this,(t=>(()=>{var e={303:e=>{e.exports=t}},o={};function i(t){var n=o[t];if(void 0!==n)return n.exports;var s=o[t]={exports:{}};return e[t](s,s.exports,i),s.exports}i.d=(t,e)=>{for(var o in e)i.o(e,o)&&!i.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var n={};return(()=>{i.r(n),i.d(n,{loadOutModesUpdater:()=>d});var t=i(303);class e{constructor(e){this.container=e,this.modes=[t.OutMode.bounce,t.OutMode.split]}update(e,o,i,n){if(!this.modes.includes(n))return;const s=this.container;let r=!1;for(const[,t]of s.plugins)if(void 0!==t.particleBounce&&(r=t.particleBounce(e,i,o)),r)break;if(r)return;const a=e.getPosition(),c=e.offset,d=e.getRadius(),u=(0,t.calculateBounds)(a,d),p=s.canvas.size;!function(e){if(e.outMode!==t.OutMode.bounce&&e.outMode!==t.OutMode.split||e.direction!==t.OutModeDirection.left&&e.direction!==t.OutModeDirection.right)return;e.bounds.right<0&&e.direction===t.OutModeDirection.left?e.particle.position.x=e.size+e.offset.x:e.bounds.left>e.canvasSize.width&&e.direction===t.OutModeDirection.right&&(e.particle.position.x=e.canvasSize.width-e.size-e.offset.x);const o=e.particle.velocity.x;let i=!1;if(e.direction===t.OutModeDirection.right&&e.bounds.right>=e.canvasSize.width&&o>0||e.direction===t.OutModeDirection.left&&e.bounds.left<=0&&o<0){const o=(0,t.getRangeValue)(e.particle.options.bounce.horizontal.value);e.particle.velocity.x*=-o,i=!0}if(!i)return;const n=e.offset.x+e.size;e.bounds.right>=e.canvasSize.width&&e.direction===t.OutModeDirection.right?e.particle.position.x=e.canvasSize.width-n:e.bounds.left<=0&&e.direction===t.OutModeDirection.left&&(e.particle.position.x=n),e.outMode===t.OutMode.split&&e.particle.destroy()}({particle:e,outMode:n,direction:o,bounds:u,canvasSize:p,offset:c,size:d}),function(e){if(e.outMode!==t.OutMode.bounce&&e.outMode!==t.OutMode.split||e.direction!==t.OutModeDirection.bottom&&e.direction!==t.OutModeDirection.top)return;e.bounds.bottom<0&&e.direction===t.OutModeDirection.top?e.particle.position.y=e.size+e.offset.y:e.bounds.top>e.canvasSize.height&&e.direction===t.OutModeDirection.bottom&&(e.particle.position.y=e.canvasSize.height-e.size-e.offset.y);const o=e.particle.velocity.y;let i=!1;if(e.direction===t.OutModeDirection.bottom&&e.bounds.bottom>=e.canvasSize.height&&o>0||e.direction===t.OutModeDirection.top&&e.bounds.top<=0&&o<0){const o=(0,t.getRangeValue)(e.particle.options.bounce.vertical.value);e.particle.velocity.y*=-o,i=!0}if(!i)return;const n=e.offset.y+e.size;e.bounds.bottom>=e.canvasSize.height&&e.direction===t.OutModeDirection.bottom?e.particle.position.y=e.canvasSize.height-n:e.bounds.top<=0&&e.direction===t.OutModeDirection.top&&(e.particle.position.y=n),e.outMode===t.OutMode.split&&e.particle.destroy()}({particle:e,outMode:n,direction:o,bounds:u,canvasSize:p,offset:c,size:d})}}class o{constructor(e){this.container=e,this.modes=[t.OutMode.destroy]}update(e,o,i,n){if(!this.modes.includes(n))return;const s=this.container;switch(e.outType){case t.ParticleOutType.normal:case t.ParticleOutType.outside:if((0,t.isPointInside)(e.position,s.canvas.size,t.Vector.origin,e.getRadius(),o))return;break;case t.ParticleOutType.inside:{const{dx:o,dy:i}=(0,t.getDistances)(e.position,e.moveCenter),{x:n,y:s}=e.velocity;if(n<0&&o>e.moveCenter.radius||s<0&&i>e.moveCenter.radius||n>=0&&o<-e.moveCenter.radius||s>=0&&i<-e.moveCenter.radius)return;break}}s.particles.remove(e,void 0,!0)}}class s{constructor(e){this.container=e,this.modes=[t.OutMode.none]}update(e,o,i,n){if(!this.modes.includes(n))return;if((e.options.move.distance.horizontal&&(o===t.OutModeDirection.left||o===t.OutModeDirection.right))??(e.options.move.distance.vertical&&(o===t.OutModeDirection.top||o===t.OutModeDirection.bottom)))return;const s=e.options.move.gravity,r=this.container,a=r.canvas.size,c=e.getRadius();if(s.enable){const i=e.position;(!s.inverse&&i.y>a.height+c&&o===t.OutModeDirection.bottom||s.inverse&&i.y<-c&&o===t.OutModeDirection.top)&&r.particles.remove(e)}else{if(e.velocity.y>0&&e.position.y<=a.height+c||e.velocity.y<0&&e.position.y>=-c||e.velocity.x>0&&e.position.x<=a.width+c||e.velocity.x<0&&e.position.x>=-c)return;(0,t.isPointInside)(e.position,r.canvas.size,t.Vector.origin,c,o)||r.particles.remove(e)}}}class r{constructor(e){this.container=e,this.modes=[t.OutMode.out]}update(e,o,i,n){if(!this.modes.includes(n))return;const s=this.container;switch(e.outType){case t.ParticleOutType.inside:{const{x:o,y:i}=e.velocity,n=t.Vector.origin;n.length=e.moveCenter.radius,n.angle=e.velocity.angle+Math.PI,n.addTo(t.Vector.create(e.moveCenter));const{dx:r,dy:a}=(0,t.getDistances)(e.position,n);if(o<=0&&r>=0||i<=0&&a>=0||o>=0&&r<=0||i>=0&&a<=0)return;e.position.x=Math.floor((0,t.randomInRange)({min:0,max:s.canvas.size.width})),e.position.y=Math.floor((0,t.randomInRange)({min:0,max:s.canvas.size.height}));const{dx:c,dy:d}=(0,t.getDistances)(e.position,e.moveCenter);e.direction=Math.atan2(-d,-c),e.velocity.angle=e.direction;break}default:if((0,t.isPointInside)(e.position,s.canvas.size,t.Vector.origin,e.getRadius(),o))return;switch(e.outType){case t.ParticleOutType.outside:{e.position.x=Math.floor((0,t.randomInRange)({min:-e.moveCenter.radius,max:e.moveCenter.radius}))+e.moveCenter.x,e.position.y=Math.floor((0,t.randomInRange)({min:-e.moveCenter.radius,max:e.moveCenter.radius}))+e.moveCenter.y;const{dx:o,dy:i}=(0,t.getDistances)(e.position,e.moveCenter);e.moveCenter.radius&&(e.direction=Math.atan2(i,o),e.velocity.angle=e.direction);break}case t.ParticleOutType.normal:{const i=e.options.move.warp,n=s.canvas.size,r={bottom:n.height+e.getRadius()+e.offset.y,left:-e.getRadius()-e.offset.x,right:n.width+e.getRadius()+e.offset.x,top:-e.getRadius()-e.offset.y},a=e.getRadius(),c=(0,t.calculateBounds)(e.position,a);o===t.OutModeDirection.right&&c.left>n.width+e.offset.x?(e.position.x=r.left,e.initialPosition.x=e.position.x,i||(e.position.y=(0,t.getRandom)()*n.height,e.initialPosition.y=e.position.y)):o===t.OutModeDirection.left&&c.right<-e.offset.x&&(e.position.x=r.right,e.initialPosition.x=e.position.x,i||(e.position.y=(0,t.getRandom)()*n.height,e.initialPosition.y=e.position.y)),o===t.OutModeDirection.bottom&&c.top>n.height+e.offset.y?(i||(e.position.x=(0,t.getRandom)()*n.width,e.initialPosition.x=e.position.x),e.position.y=r.top,e.initialPosition.y=e.position.y):o===t.OutModeDirection.top&&c.bottom<-e.offset.y&&(i||(e.position.x=(0,t.getRandom)()*n.width,e.initialPosition.x=e.position.x),e.position.y=r.bottom,e.initialPosition.y=e.position.y);break}}}}}const a=(t,e)=>t.default===e||t.bottom===e||t.left===e||t.right===e||t.top===e;class c{constructor(t){this._updateOutMode=(t,e,o,i)=>{for(const n of this.updaters)n.update(t,i,e,o)},this.container=t,this.updaters=[]}init(i){this.updaters=[];const n=i.options.move.outModes;a(n,t.OutMode.bounce)?this.updaters.push(new e(this.container)):a(n,t.OutMode.out)?this.updaters.push(new r(this.container)):a(n,t.OutMode.destroy)?this.updaters.push(new o(this.container)):a(n,t.OutMode.none)&&this.updaters.push(new s(this.container))}isEnabled(t){return!t.destroyed&&!t.spawning}update(e,o){const i=e.options.move.outModes;this._updateOutMode(e,o,i.bottom??i.default,t.OutModeDirection.bottom),this._updateOutMode(e,o,i.left??i.default,t.OutModeDirection.left),this._updateOutMode(e,o,i.right??i.default,t.OutModeDirection.right),this._updateOutMode(e,o,i.top??i.default,t.OutModeDirection.top)}}async function d(t,e=!0){await t.addParticleUpdater("outModes",(t=>Promise.resolve(new c(t))),e)}})(),n})()));