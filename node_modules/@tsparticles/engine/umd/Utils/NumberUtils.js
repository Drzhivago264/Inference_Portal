(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../Enums/Directions/MoveDirection.js", "../Core/Utils/Vectors.js", "./TypeUtils.js", "../Core/Utils/Constants.js"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAlpha = exports.calcExactPositionOrRandomFromSizeRanged = exports.calcExactPositionOrRandomFromSize = exports.calcPositionOrRandomFromSizeRanged = exports.calcPositionOrRandomFromSize = exports.calcPositionFromSize = exports.collisionVelocity = exports.getParticleBaseVelocity = exports.getParticleDirectionAngle = exports.degToRad = exports.getDistance = exports.getDistances = exports.setRangeValue = exports.getRangeMax = exports.getRangeMin = exports.getRangeValue = exports.randomInRange = exports.mix = exports.clamp = exports.getRandom = exports.setRandom = exports.getEasing = exports.addEasing = void 0;
    const MoveDirection_js_1 = require("../Enums/Directions/MoveDirection.js");
    const Vectors_js_1 = require("../Core/Utils/Vectors.js");
    const TypeUtils_js_1 = require("./TypeUtils.js");
    const Constants_js_1 = require("../Core/Utils/Constants.js");
    let _random = Math.random;
    const easings = new Map(), double = 2, doublePI = Math.PI * double;
    function addEasing(name, easing) {
        if (easings.get(name)) {
            return;
        }
        easings.set(name, easing);
    }
    exports.addEasing = addEasing;
    function getEasing(name) {
        return easings.get(name) ?? ((value) => value);
    }
    exports.getEasing = getEasing;
    function setRandom(rnd = Math.random) {
        _random = rnd;
    }
    exports.setRandom = setRandom;
    function getRandom() {
        const min = 0, max = 1;
        return clamp(_random(), min, max - Number.EPSILON);
    }
    exports.getRandom = getRandom;
    function clamp(num, min, max) {
        return Math.min(Math.max(num, min), max);
    }
    exports.clamp = clamp;
    function mix(comp1, comp2, weight1, weight2) {
        return Math.floor((comp1 * weight1 + comp2 * weight2) / (weight1 + weight2));
    }
    exports.mix = mix;
    function randomInRange(r) {
        const max = getRangeMax(r), minOffset = 0;
        let min = getRangeMin(r);
        if (max === min) {
            min = minOffset;
        }
        return getRandom() * (max - min) + min;
    }
    exports.randomInRange = randomInRange;
    function getRangeValue(value) {
        return (0, TypeUtils_js_1.isNumber)(value) ? value : randomInRange(value);
    }
    exports.getRangeValue = getRangeValue;
    function getRangeMin(value) {
        return (0, TypeUtils_js_1.isNumber)(value) ? value : value.min;
    }
    exports.getRangeMin = getRangeMin;
    function getRangeMax(value) {
        return (0, TypeUtils_js_1.isNumber)(value) ? value : value.max;
    }
    exports.getRangeMax = getRangeMax;
    function setRangeValue(source, value) {
        if (source === value || (value === undefined && (0, TypeUtils_js_1.isNumber)(source))) {
            return source;
        }
        const min = getRangeMin(source), max = getRangeMax(source);
        return value !== undefined
            ? {
                min: Math.min(min, value),
                max: Math.max(max, value),
            }
            : setRangeValue(min, max);
    }
    exports.setRangeValue = setRangeValue;
    function getDistances(pointA, pointB) {
        const dx = pointA.x - pointB.x, dy = pointA.y - pointB.y, squareExp = 2;
        return { dx: dx, dy: dy, distance: Math.sqrt(dx ** squareExp + dy ** squareExp) };
    }
    exports.getDistances = getDistances;
    function getDistance(pointA, pointB) {
        return getDistances(pointA, pointB).distance;
    }
    exports.getDistance = getDistance;
    function degToRad(degrees) {
        const PIDeg = 180;
        return (degrees * Math.PI) / PIDeg;
    }
    exports.degToRad = degToRad;
    function getParticleDirectionAngle(direction, position, center) {
        if ((0, TypeUtils_js_1.isNumber)(direction)) {
            return degToRad(direction);
        }
        const empty = 0, half = 0.5, quarter = 0.25, threeQuarter = half + quarter;
        switch (direction) {
            case MoveDirection_js_1.MoveDirection.top:
                return -Math.PI * half;
            case MoveDirection_js_1.MoveDirection.topRight:
                return -Math.PI * quarter;
            case MoveDirection_js_1.MoveDirection.right:
                return empty;
            case MoveDirection_js_1.MoveDirection.bottomRight:
                return Math.PI * quarter;
            case MoveDirection_js_1.MoveDirection.bottom:
                return Math.PI * half;
            case MoveDirection_js_1.MoveDirection.bottomLeft:
                return Math.PI * threeQuarter;
            case MoveDirection_js_1.MoveDirection.left:
                return Math.PI;
            case MoveDirection_js_1.MoveDirection.topLeft:
                return -Math.PI * threeQuarter;
            case MoveDirection_js_1.MoveDirection.inside:
                return Math.atan2(center.y - position.y, center.x - position.x);
            case MoveDirection_js_1.MoveDirection.outside:
                return Math.atan2(position.y - center.y, position.x - center.x);
            default:
                return getRandom() * doublePI;
        }
    }
    exports.getParticleDirectionAngle = getParticleDirectionAngle;
    function getParticleBaseVelocity(direction) {
        const baseVelocity = Vectors_js_1.Vector.origin;
        baseVelocity.length = 1;
        baseVelocity.angle = direction;
        return baseVelocity;
    }
    exports.getParticleBaseVelocity = getParticleBaseVelocity;
    function collisionVelocity(v1, v2, m1, m2) {
        const double = 2;
        return Vectors_js_1.Vector.create((v1.x * (m1 - m2)) / (m1 + m2) + (v2.x * double * m2) / (m1 + m2), v1.y);
    }
    exports.collisionVelocity = collisionVelocity;
    function calcPositionFromSize(data) {
        return data.position?.x !== undefined && data.position.y !== undefined
            ? {
                x: (data.position.x * data.size.width) / Constants_js_1.percentDenominator,
                y: (data.position.y * data.size.height) / Constants_js_1.percentDenominator,
            }
            : undefined;
    }
    exports.calcPositionFromSize = calcPositionFromSize;
    function calcPositionOrRandomFromSize(data) {
        return {
            x: ((data.position?.x ?? getRandom() * Constants_js_1.percentDenominator) * data.size.width) / Constants_js_1.percentDenominator,
            y: ((data.position?.y ?? getRandom() * Constants_js_1.percentDenominator) * data.size.height) / Constants_js_1.percentDenominator,
        };
    }
    exports.calcPositionOrRandomFromSize = calcPositionOrRandomFromSize;
    function calcPositionOrRandomFromSizeRanged(data) {
        const position = {
            x: data.position?.x !== undefined ? getRangeValue(data.position.x) : undefined,
            y: data.position?.y !== undefined ? getRangeValue(data.position.y) : undefined,
        };
        return calcPositionOrRandomFromSize({ size: data.size, position });
    }
    exports.calcPositionOrRandomFromSizeRanged = calcPositionOrRandomFromSizeRanged;
    function calcExactPositionOrRandomFromSize(data) {
        return {
            x: data.position?.x ?? getRandom() * data.size.width,
            y: data.position?.y ?? getRandom() * data.size.height,
        };
    }
    exports.calcExactPositionOrRandomFromSize = calcExactPositionOrRandomFromSize;
    function calcExactPositionOrRandomFromSizeRanged(data) {
        const position = {
            x: data.position?.x !== undefined ? getRangeValue(data.position.x) : undefined,
            y: data.position?.y !== undefined ? getRangeValue(data.position.y) : undefined,
        };
        return calcExactPositionOrRandomFromSize({ size: data.size, position });
    }
    exports.calcExactPositionOrRandomFromSizeRanged = calcExactPositionOrRandomFromSizeRanged;
    function parseAlpha(input) {
        const defaultAlpha = 1;
        if (!input) {
            return defaultAlpha;
        }
        return input.endsWith("%") ? parseFloat(input) / Constants_js_1.percentDenominator : parseFloat(input);
    }
    exports.parseAlpha = parseAlpha;
});
