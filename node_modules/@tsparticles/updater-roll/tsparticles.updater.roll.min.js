/*! For license information please see tsparticles.updater.roll.min.js.LICENSE.txt */
!function(e,o){if("object"==typeof exports&&"object"==typeof module)module.exports=o(require("@tsparticles/engine"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine"],o);else{var l="object"==typeof exports?o(require("@tsparticles/engine")):o(e.window);for(var t in l)("object"==typeof exports?exports:e)[t]=l[t]}}(this,(e=>(()=>{var o={303:o=>{o.exports=e}},l={};function t(e){var n=l[e];if(void 0!==n)return n.exports;var a=l[e]={exports:{}};return o[e](a,a.exports,t),a.exports}t.d=(e,o)=>{for(var l in o)t.o(o,l)&&!t.o(e,l)&&Object.defineProperty(e,l,{enumerable:!0,get:o[l]})},t.o=(e,o)=>Object.prototype.hasOwnProperty.call(e,o),t.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{t.r(n),t.d(n,{loadRollUpdater:()=>s});var e,o=t(303);!function(e){e.both="both",e.horizontal="horizontal",e.vertical="vertical"}(e||(e={}));const l=2*Math.PI;class a{constructor(){this.enable=!1,this.value=0}load(e){e&&(void 0!==e.enable&&(this.enable=e.enable),void 0!==e.value&&(this.value=(0,o.setRangeValue)(e.value)))}}class r{constructor(){this.darken=new a,this.enable=!1,this.enlighten=new a,this.mode=e.vertical,this.speed=25}load(e){e&&(void 0!==e.backColor&&(this.backColor=o.OptionsColor.create(this.backColor,e.backColor)),this.darken.load(e.darken),void 0!==e.enable&&(this.enable=e.enable),this.enlighten.load(e.enlighten),void 0!==e.mode&&(this.mode=e.mode),void 0!==e.speed&&(this.speed=(0,o.setRangeValue)(e.speed)))}}class i{getTransformValues(e){const o=e.roll?.enable&&e.roll,l=o&&o.horizontal,t=o&&o.vertical;return{a:l?Math.cos(o.angle):void 0,d:t?Math.sin(o.angle):void 0}}init(t){!function(t){const n=t.options.roll;if(n?.enable)if(t.roll={enable:n.enable,horizontal:n.mode===e.horizontal||n.mode===e.both,vertical:n.mode===e.vertical||n.mode===e.both,angle:(0,o.getRandom)()*l,speed:(0,o.getRangeValue)(n.speed)/360},n.backColor)t.backColor=(0,o.rangeColorToHsl)(n.backColor);else if(n.darken.enable&&n.enlighten.enable){const e=(0,o.getRandom)()>=o.halfRandom?o.AlterType.darken:o.AlterType.enlighten;t.roll.alter={type:e,value:(0,o.getRangeValue)(e===o.AlterType.darken?n.darken.value:n.enlighten.value)}}else n.darken.enable?t.roll.alter={type:o.AlterType.darken,value:(0,o.getRangeValue)(n.darken.value)}:n.enlighten.enable&&(t.roll.alter={type:o.AlterType.enlighten,value:(0,o.getRangeValue)(n.enlighten.value)});else t.roll={enable:!1,horizontal:!1,vertical:!1,angle:0,speed:0}}(t)}isEnabled(e){const o=e.options.roll;return!e.destroyed&&!e.spawning&&!!o?.enable}loadOptions(e,...o){e.roll||(e.roll=new r);for(const l of o)e.roll.load(l?.roll)}update(e,o){this.isEnabled(e)&&function(e,o){const t=e.options.roll,n=e.roll;if(!n||!t?.enable)return;const a=n.speed*o.factor,r=l;n.angle+=a,n.angle>r&&(n.angle-=r)}(e,o)}}async function s(e,o=!0){await e.addParticleUpdater("roll",(()=>Promise.resolve(new i)),o)}})(),n})()));